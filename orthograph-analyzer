#!/usr/bin/env perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2012 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write clean code
use warnings;       # cry if something seems odd
use autodie;        # die automatically on I/O functions

# Core modules
use Archive::Tar;   # handling tar archives
use Benchmark qw( timediff timestr );  # timing functions
use Carp;           # carp and croak: warn and die with call stack
use Config;         # allows checking for system configuration in $Config
use DBD::mysql;     # MySQL database driver 
use DBI;            # database interface 
use Data::Dumper;   # great for debugging
use Digest::SHA;    # SHA hashing: good idea or not?
use File::Basename; # provides basename()
use File::Path qw( make_path remove_tree ); # this also uses File::Spec
use File::Temp;     # temporary files
use FindBin;        # locate the dir of this script during compile time
use IO::Dir;        # object-oriented access to dirs
use IO::File;       # object-oriented access to files
# look into File::Find instead of doing the directory walk yourself

# Custom modules
use lib $FindBin::Bin;     # $Bin is the directory of the original script
use IO::Tee;               # not custom, but supplied because from CPAN
use Seqload::Fasta;        # object-oriented access to fasta files
use Wrapper::Hmmsearch;    # object-oriented interface to hmmsearch
use Wrapper::Blastp;       # object-oriented interface to blastp
use Wrapper::Mysql;        # wrapper functions for MySQL
use Orthograph::Functions; # functions for all Orthograph tools
use Orthograph::Config;    # configuration in global hashref $config; also handles command line arguments

my $program_name = 'Orthograph';
my $version = 'alpha4';
# this message will be printed later when we have a log file handle
my $message = "$program_name\: Orthology prediction using a Graph-based,\n" .
	"Reciprocal Approach with Profile Hidden Markov models\n" .
	"Copyright 2012 Malte Petersen <mptrsen\@uni-bonn.de>\n" .
	"Version $version\n\n";
my $program_file = $FindBin::Script;

#--------------------------------------------------
# Only use threads if the system supports it.
# The whole threads system is totally not implemented yet,
# do not attempt to use it!
#-------------------------------------------------- 
my $use_threads = 0;#{{{
if ($use_threads == 1 and $Config{'useithreads'}) {
  $message .= "Using threads.\n\n";
  #use Wrapper::Threaded;
}
elsif ($use_threads == 1 and not $Config{'useithreads'}) {
  warn "Warning: Cannot use threads: Your version of Perl was not compiled with threading support. Not using threads.\n\n";
	$use_threads = 0;
}
else {
	$message .= "Not using threads.\n\n";
	$use_threads = 0;
}#}}}

#--------------------------------------------------
# # Copy configuration
#-------------------------------------------------- 
my $config = $Orthograph::Config::config;

printf "%s = %s\n", $_, $config->{$_} foreach sort keys %$config;

#--------------------------------------------------
# # Programs in the order of their use
#-------------------------------------------------- 
my $alignment_program          = $config->{'alignment-program'};
my $hmmbuild_program           = $config->{'hmmbuild-program'};
my $translateprog              = $config->{'translate-program'};
my $hmmsearchprog              = $config->{'hmmsearch-program'};
my $blastprog                  = $config->{'blast-program'};
my $makeblastdbprog            = $config->{'makeblastdb-program'};

#--------------------------------------------------
# # These variables can be set in the config file
#-------------------------------------------------- 
#{{{
my $aaoutdir                   = $config->{'aaoutdir'};
my $backup_ext                 = $config->{'backup-extension'};
my $blast_max_hits             = $config->{'blast-max-hits'};
my $blastoutdir                = $config->{'blastoutdir'};
my $blast_evalue_threshold     = $config->{'blast-evalue-threshold'};
my $blast_score_threshold      = $config->{'blast-score-threshold'};
my $clear_database             = $config->{'clear-database'};
my $clear_files                = $config->{'clear-files'};
my $configfile                 = $config->{'configfile'};
my $continue                   = $config->{'continue'};
my $debug                      = $config->{'debug'};
my $estfile                    = $config->{'estfile'};
my $hmmfile                    = $config->{'hmmfile'};
my $hmmoutdir                  = $config->{'hmmsearch-output-dir'};
my $hmmsearch_evalue_threshold = $config->{'hmmsearch-evalue-threshold'};
my $hmmsearch_score_threshold  = $config->{'hmmsearch-score-threshold'};
my $logfile                    = $config->{'logfile'};
my $max_blast_searches         = $config->{'max-blast-searches'};

# MySQL settings
my $mysql_dbname               = $config->{'mysql-database'};
my $mysql_dbpwd                = $config->{'mysql-password'};
my $mysql_dbserver             = $config->{'mysql-server'};
my $mysql_dbuser               = $config->{'mysql-username'};

my $mysql_table_blast          = $config->{'mysql_table_blast'};
my $mysql_table_blastdbs       = $config->{'mysql_table_blastdbs'};
my $mysql_table_ests           = $config->{'mysql_table_ests'};
my $mysql_table_hmmsearch      = $config->{'mysql_table_hmmsearch'};
my $mysql_table_log_evalues    = $config->{'mysql_table_log_evalues'};
my $mysql_table_set_details    = $config->{'mysql_table_set_details'};
my $mysql_table_aaseqs         = $config->{'mysql_table_aaseqs'};
my $mysql_table_seqpairs       = $config->{'mysql_table_sequence_pairs'};
my $mysql_table_taxa           = $config->{'mysql_table_taxa'};
my $mysql_table_orthologs      = $config->{'mysql_table_orthologs'};
my $outdir                     = $config->{'output-directory'};
my $orthoset                   = $config->{'ortholog-set'};
my $preparedb                  = $config->{'prepare'};
my $quiet                      = $config->{'quiet'};
my $reftaxa                    = $config->{'reference-taxa'};
# substitution character for selenocysteine, which normally leads to blast freaking out
my $u_subst                    = $config->{'substitute-u-with'};
my $sets_dir                   = $config->{'sets-dir'};
my $species_name               = $config->{'species-name'};
my $verbose                    = $config->{'verbose'};
#}}}

#--------------------------------------------------
# # More variables
#-------------------------------------------------- 
#{{{
my $EMPTY                   = q{};
my $alndir                  = $EMPTY;
my $blastcount              = 0;
my $blastdb                 = $EMPTY;
my $blasthitcount_total     = 0;
my $count                   = 0;
my $hmmcount                = 0;
my $hmmdir                  = $EMPTY;
my $hmmhitcount             = 0;
my $hmmhitcount_total       = 0;
my $hmmresultfileref        = $EMPTY;
my $listspecies             = 0;
my $logdir                  = $EMPTY;
my $mysql_col_aaseq         = 'aa_seq';
my $mysql_col_blastdbpath   = 'blastdb_path';
my $mysql_col_date          = 'date';
my $mysql_col_digest        = 'digest';
my $mysql_col_end           = 'end';
my $mysql_col_evalue        = 'evalue';
my $mysql_col_log_evalue    = 'log_evalue';
my $mysql_col_hdr           = 'header';
my $mysql_col_hmm           = 'hmm';
my $mysql_col_id            = 'id';
my $mysql_col_longname      = 'longname';
my $mysql_col_name          = 'name';
my $mysql_col_orthoid       = 'ortholog_gene_id';
my $mysql_col_query         = 'query';
my $mysql_col_score         = 'score';
my $mysql_col_seq           = 'sequence';
my $mysql_col_seqpair       = 'sequence_pair';
my $mysql_col_setid         = 'setid';
my $mysql_col_start         = 'start';
my $mysql_col_target        = 'target';
my $mysql_col_taxid         = 'taxid';
my $mysql_col_taxon         = 'taxon';
my $mysql_dbi               = "dbi\:mysql\:$mysql_dbname\:$mysql_dbserver";
my $num_ests                = 0;
my $num_hmms                = 0;
my $orthocount              = 0;
my $protfile                = $EMPTY;
my $set_id                  = 0;
my $species_id              = 0;
my $stderr                  = undef;
my $stdout                  = undef;
my $t0;  # these are used for timing 
my $t1;  # these are used for timing 
my $timestamp_diff          = 0;
my $timestamp_end           = 0; # will hold the time at the end
my $timestamp_start         = scalar time;
my @lt                      = localtime time;
my $timestring              = sprintf "%04d-%02d-%02d_%02d:%02d", $lt[5] + 1900, $lt[4] + 1, $lt[3], $lt[2], $lt[1];
# create new temporary directory and set it to not be deleted 
my $tmpdir                  = File::Temp->newdir(
                               'UNLINK' => 0,
                               'TEMPLATE' => File::Spec->catdir($outdir, 'tmpXXXX'));
my @backup                  = ( );
my @hmmfiles                = ( );
my @reftaxa                 = ( );
my @seqobjs                 = ( );
#}}}

$tmpdir->unlink_on_destroy(0) if $debug;

#--------------------------------------------------
# # Special case: Prepare the MySQL database by dropping and recreating all
# # tables if requested, then exit
#-------------------------------------------------- 
if ($preparedb) {#{{{
	local $| = 1;
  print "Setting MySQL database $mysql_dbname to a clean slate... ";
	local $| = 0;
  &preparedb;
  print "OK\nMySQL database now ready to run $program_name.\n";
  exit;
}#}}}

#--------------------------------------------------
# # Another special case: List the species for which analysis data is present,
# # then exit
#-------------------------------------------------- 
if ($listspecies) {
	&listspecies;
	exit(0);
}

#--------------------------------------------------
# # Normal run. Input error checking, reporting etc
#-------------------------------------------------- 
&intro;

# get the set id
$set_id = Wrapper::Mysql::get_set_id($orthoset);

# prepare the HMMs
$hmmdir = &make_hmms($orthoset);
# prepare the BLAST database
$blastdb = &make_blastdb($set_id);

#--------------------------------------------------
# # create list of reference taxa and HMM files 
#-------------------------------------------------- 
if ($reftaxa) { @reftaxa = split(/\s*,\s*/, $reftaxa) }
else { @reftaxa = Wrapper::Mysql::get_taxa_in_set($set_id) }
@hmmfiles = &hmmlist($hmmdir);
$num_hmms = scalar(@hmmfiles);


unless ($quiet) {#{{{
	print $stdout "Using temporary directory $tmpdir.\n"
		if $tmpdir;
  print $stdout "Using HMM dir $hmmdir with ", scalar(@hmmfiles), " HMM files.\n" 
    if $hmmdir;
  print $stdout "Using HMM file $hmmfile.\n" 
    if $hmmfile;
  print $stdout "HMMsearch e-Value cutoff: $hmmsearch_evalue_threshold.\n" 
    if $hmmsearch_evalue_threshold;
  print $stdout "Score cutoff: $hmmsearch_score_threshold.\n"
    if $hmmsearch_score_threshold;
}#}}}

#--------------------------------------------------
# # translate the ESTs to protein, feed that stuff to the database
#-------------------------------------------------- 
$protfile = &translate_est(File::Spec->catfile($estfile));#{{{

# clear database of data from the same species
if ($clear_database) {
	print $stdout "Clearing database of previous results from '$species_name'...\n" unless $quiet;
	$t0 = scalar time;
	my $n_deleted = &clear_db($species_name) or print $stderr "Warning: Failed to clear database for species $species_name!\n";
	$t1 = scalar time;
	printf $stdout "Deleted %d records from database.\nTransaction took %.1f seconds.\n", $n_deleted, $t1 - $t0 unless $quiet;
}

# get the taxon id. create a new entry in the taxa table or return existing one
$species_id = Wrapper::Mysql::insert_taxon_into_table($species_name) or print $stderr "Warning: Failed to get species id: $DBI::errstr";
print $stdout "Got taxon id $species_id for '$species_name'\n" unless $quiet;

unless ($continue) {
	# store est data into the database:
	print $stdout "Storing translated sequences to MySQL database '$mysql_dbname' on $mysql_dbserver...\n" unless $quiet;

	# LOAD DATA INFILE; third arg must be ref to array of column names
	$t0 = scalar time;
	&load_data_infile($protfile, $mysql_table_ests, [ $mysql_col_digest, $mysql_col_taxid, $mysql_col_date, $mysql_col_hdr, $mysql_col_seq ]);
	$t1 = scalar time;
	printf $stdout "Transaction took %.1f seconds.\n", $t1 - $t0 unless $quiet;
}


# get number of sequences for this species, report or die
$num_ests = Wrapper::Mysql::get_number_of_ests_for_specid($species_id);
if ($num_ests != 0) {
	printf($stdout "%d sequences of %s in database '%s' on %s. \n",
		$num_ests,
		$species_name,
		$mysql_dbname,
		$mysql_dbserver) unless $quiet;
}
else {
	print $stderr "No sequences found for taxon id $species_id. Something went wrong. Check your input. Exiting.\n" and exit(1);
}

# get the transcripts with their new ID back from the database. TODO is this efficient?
$protfile = &get_transcripts($species_id);
#}}}

#--------------------------------------------------
# # Setup the Orthograph modules. These are all class methods.
#-------------------------------------------------- 

# verbose output #{{{
if ($verbose) {
	Wrapper::Hmmsearch->verbose(1);
	Wrapper::Blastp->verbose(1);
}

# debug output
if ($debug) {
	$verbose = 1;
	Wrapper::Hmmsearch->debug(1);
	Wrapper::Blastp->debug(1);
}

# e-value and score thresholds
Wrapper::Hmmsearch->evalue_threshold($hmmsearch_evalue_threshold)
	if $hmmsearch_evalue_threshold;
Wrapper::Blastp->evalue_threshold($blast_evalue_threshold)
	if $blast_evalue_threshold;
Wrapper::Hmmsearch->score_threshold($hmmsearch_score_threshold)
	if $hmmsearch_score_threshold;
Wrapper::Blastp->score_threshold($blast_score_threshold)
	if $blast_score_threshold;
# maximum number of hits to save for blast
Wrapper::Blastp->max_hits($blast_max_hits)
	if $blast_max_hits;

# the output directories
Wrapper::Hmmsearch->outdir($hmmoutdir);
Wrapper::Blastp->outdir($blastoutdir);

# the programs
Wrapper::Hmmsearch->searchprog($hmmsearchprog);
Wrapper::Blastp->searchprog($blastprog);

#}}}

#--------------------------------------------------
# # HMMsearch the protfile using all HMMs
#-------------------------------------------------- 
printf($stdout "HMMsearching the protein file using all %d HMMs in %s\:\n", scalar(@hmmfiles), $hmmdir)
	unless $quiet;
$hmmcount = 0;
$hmmhitcount = 0;

HMMFILE:
foreach my $hmmfile (@hmmfiles) {#{{{
	++$hmmcount;
	$blastcount = 0;	# reset counter

	# create new hmmobject with a hmm file, should have all the necessary info for doing hmmsearch
	my $hmmobj = Wrapper::Hmmsearch->new($hmmfile); 

	# now do the hmmsearch on the protfile
	$hmmobj->search($protfile);

	# count the hmmsearch hits
	printf($stdout "%4d first-tier hits for %s (%2.1f%% complete)\n", 
		$hmmobj->hitcount(),
		basename($hmmobj->hmmfile()),
		($hmmcount * 100 / $num_hmms)) unless $quiet;
	# and do not care further with HMM files that did not return any result
	if ($hmmobj->hitcount() == 0) { 
		next HMMFILE;
	}

	# add hitcount to total number of hmm hits,
	# print list of hits if verbose
	$hmmhitcount_total += $hmmobj->hitcount();
	if ($verbose) {
		my $hits = $hmmobj->hits_arrayref();
		for (my $i = 0; $i < scalar @$hits; $i++) {
			printf $stdout "     [%d] %s, e-value %2.1e\n",
				$i + 1,
				$hits->[$i]->{'target'},
				$hits->[$i]->{'evalue'};
		}
	}

	#--------------------------------------------------
	# # push results to database 
	#-------------------------------------------------- 
	&insert_results_into_table($mysql_table_hmmsearch, $hmmobj->hits_arrayref());
	print $stdout "     ... pushed to database.\n" if $verbose;
	++$hmmhitcount;
	
	#--------------------------------------------------
	# # the reciprocal search
	#-------------------------------------------------- 

	# get hmmsearch results from database; use the first array item since they all share the query (HMM) ID 
	my @hmmresults = @{Wrapper::Mysql::get_hmmresults($hmmobj->hits_arrayref->[0]{'query'})};

	# don't do too many blast searches...
	my $max = scalar(@hmmresults) >= $max_blast_searches ? $max_blast_searches : scalar(@hmmresults);

	HMMRESULT:
	for (my $n = 0; $n < $max; ++$n) { #{{{
 		++$count;

		# setup a temporary file to hold the sequence to be blasted
		my $tmpfile = File::Temp->new(
			'UNLINK' => 0, 
			'TEMPLATE' => File::Spec->catfile($tmpdir, basename($hmmobj->hmmfile) . '-XXXX'));
		# don't delete this file if debugging
		$tmpfile->unlink_on_destroy(0) if $debug;
		# get sequence length
		my ($start, $end) = ($hmmresults[$n][2] - 1, $hmmresults[$n][3] - 1);
		my $length = $end - $start;
		# write fasta header and sequence to the tempfile
		printf($tmpfile ">%s\n%s\n", $hmmresults[$n]->[0], substr($hmmresults[$n]->[1], $start, $length));
		printf($stdout "Wrote sequence [%d] (from %d to %d) to tmpfile %s\n", $n + 1, $start, $end, $tmpfile) if $debug;

		#--------------------------------------------------
		# # run blastp 
		#-------------------------------------------------- 
		# shiny new blastp object
		my $blastobj = Wrapper::Blastp->new($blastdb);

		# generate a blast output file name from the HMM name and the hit number
		my $blastoutfile = File::Spec->catfile($blastoutdir, $hmmobj->hmmname . '-' . $hmmresults[$n]->[0] . '-' . basename($blastdb) .  '.blast');

		# do the blastp search; skip if no hits obtained
		$blastobj->blastp($tmpfile, $blastoutfile);

		printf($stdout "       %4d BLASTP hits detected for [%d] against %s, e-value below %2.1e\n",
			$blastobj->hitcount,
			$n + 1,
			basename($blastdb),
			$blast_evalue_threshold) if $verbose;

		$blasthitcount_total += $blastobj->hitcount();

		# skip to next if BLAST finds nothing
		if ($blastobj->hitcount() == 0) { next HMMRESULT }

		# insert the blast results into the db. 3-argument form.
		&insert_results_into_table($mysql_table_blast, $blastobj->blasthits_arrayref, basename($blastdb));
		print $stdout "            ... pushed to database.\n" if $verbose;
	} #}}}

	if ($hmmcount <= scalar(@hmmfiles) / 100) {
		print $stdout "\n(Don't be alarmed, the sequence identifiers are SHA256-hashed but their original label is preserved in the database and will be output at the end. Don't be alarmed)\n\n"
			if $verbose;
	}

	# is this a valid candidate? 
	# take the first element of the hit list, they share the same orthoid 
	if (Wrapper::Mysql::reciprocal_match($hmmobj->hmmname, $hmmobj->hits_arrayref()->[1]->{'target'})) {

		# yay
		++$orthocount;
		printf $stdout "!! ^-------Possible orthology detected for %s, confirmed by reciprocal hit! Added to database.\n", $hmmobj->hmmname unless $quiet;

	}
	# otherwise, just continue
	else { next HMMFILE }

	my $orthologs = &get_orthologs($hmmobj->hmmname, $hmmobj->hits_arrayref()->[0]->{'target'});
	next HMMFILE unless defined $$orthologs[0];	# skip empty results

	# write the result to output file
	my $outfh = IO::File->new(File::Spec->catfile($aaoutdir, $$orthologs[0][0] . '.fa'), 'w');
	for (0..$#{$orthologs}) { 
		printf $outfh ">%s:%s:%s\n%s\n", 
			$$orthologs[0][0],  # the ortholog id
			$$orthologs[$_][1],	# the taxon shorthand of the ortholog sequence
			$$orthologs[$_][3],	# the sequence id of the ortholog sequence
			$$orthologs[$_][4]  # the sequence
				or print $stderr "Fatal: Could not write to output file $outfh: $!" and exit(1);
	}
	# the header and sequence of the hit
	# this is the best hit since the SQL query sorts by evalue and we take the first one
	printf $outfh ">%s:%s:%s\n%s\n",
		$$orthologs[0][0],  # the ortholog id
		$species_name,      # the name of the analyzed species 
		# TODO reftaxon id
		$$orthologs[0][5],  # the original sequence id
		$$orthologs[0][6];  # the sequence
	$outfh->close();

}#}}}	# End hmmlist loop

# report, end the program
$timestamp_end = scalar time();
$timestamp_diff = $timestamp_end - $timestamp_start;
printf $stdout "\n%s analysis for %s completed in %d seconds.\n", $program_name, $species_name, $timestamp_diff;
printf $stdout "Searched %d sequences using %d HMMs.\nObtained %d HMM hits and identified %d as putative 1:1 orthologs (%2.2f%%).\n",
	$num_ests,
	$hmmcount,
	$hmmhitcount,
	$orthocount,
	((100 * $orthocount) / $hmmcount);
printf $stdout "Now go look in your output directory %s and run %s.\n", $outdir, 'orthograph-reporter';

# successfully exit :)
exit(0);


###################################################
# # Functions 
###################################################

# Sub: progress_bar
# Prints a self-overwriting, wget-style progress bar.
# This is not written to the log file so it doesn't get cluttered.
# Arguments: scalar int so-far, scalar int total, scalar int width, scalar char "what-to-use-as-char"
sub progress_bar {#{{{
	my ($got, $total, $width, $char) = @_;
	$width ||= 25;
	$char ||= '=';
	my $num_width = length($total);
	local $| = 1;
	printf("|%-${width}s| Progress: %${num_width}s of %s (%.2f%%)\r", $char x (($width-1)*$got/$total) . '>', $got, $total, 100*$got/$total);
	local $| = 0;
	return 1;
}#}}}

# Sub: intro
# Checks input, file/dir presence, etc.
# Returns True if everything is OK.
sub intro {#{{{
	# first things first: 
	# construct output directory paths
	# outdir may be defined in the config file
	$outdir = defined($outdir) ? $outdir : File::Spec->catdir('.', $species_name);

	# the output directory. create if it does not exist.
	if (-d $outdir) {
		# no IO::Tee because the log dir has not been created yet 
		$message .= "Using output dir $outdir.\n" unless $quiet;
	}
	else {
		# no IO::Tee because the log dir has not been created yet 
		$message .= "Output dir $outdir does not exist, creating...\n" unless $quiet;
		&makedir($outdir) or die "Fatal: Failed to create output directory '$outdir'\n";
	}

	# the other dirs
	$aaoutdir = File::Spec->catdir($outdir, $aaoutdir);
	$hmmoutdir = defined($hmmoutdir) ? File::Spec->catdir($outdir, $hmmoutdir) : File::Spec->catdir($outdir, basename($hmmsearchprog));
  $blastoutdir = defined($blastoutdir) ? File::Spec->catdir($outdir, $blastoutdir) : File::Spec->catdir($outdir, basename($blastprog));

	# setup the log file
	if ($logfile) {
		# new log file handle
		my $logfh = IO::File->new($logfile, 'w') or die "Fatal: Could not create log file '$logfile': $!\n";  
		$stdout = IO::Tee->new(
			\*STDOUT,  # reference to STDOUT typeglob
			$logfh, 
		);
		$stderr = IO::Tee->new(
			\*STDERR,  # reference to STDERR typeglob
			$logfh,
		);
		# print the messages that were collected so far
		print $stdout $message;
		print $stdout "Writing to log file $logfile\n";
	}
	# default logfile: 'orthograph-' plus a timestamp
	else {
		$logdir = File::Spec->catdir($outdir, 'log');
		if (-d $logdir) {
			$message .= "Using log dir $logdir.\n" unless $quiet;
		}
		else {
			$message .= "Log dir $logdir does not exist, creating...\n" unless $quiet;
			&makedir($logdir) or die "Fatal: Failed to create log directory $logdir\n";
		}
		$logfile = File::Spec->catfile($logdir,  'orthograph-' . $timestamp_start . '.log');
		my $logfh = IO::File->new($logfile, 'w') or die "Fatal: Could not create log file '$logfile': $!\n";
		$stdout = IO::Tee->new(
			\*STDOUT,
			$logfh,
		);
		$stderr = IO::Tee->new(
			\*STDERR,
			$logfh,
		);
		# print the messages that were collected so far
		print $stdout $message;
		print $stdout "Using log file $logfile.\n";
	}

	print $stderr "Fatal: Species name needed (-taxon NAME)!\n" and exit(1)
		unless ($species_name);
	
	print $stderr "Fatal: Ortholog set name required (ortholog_set)!\n" and exit(1)
		unless ($orthoset);

	# mutually exclusive options
	print $stderr "Fatal: Can't operate in both verbose and quiet mode\n" and exit(1)
		if ($verbose and $quiet);

	# mutually exclusive options
	print $stderr "Fatal: Can't use both hmmsearch e-value and score thresholds\n" and exit(1)
		if ($hmmsearch_evalue_threshold and $hmmsearch_score_threshold);

	# the alignment directory (for ortholog set creation)
	unless ($alndir) { $alndir = File::Spec->catdir($sets_dir, $orthoset, 'aln') }
	if (-d $alndir) {
		print $stdout "Alignment dir $alndir exists.\n" unless $quiet;
	}
	else {
		print $stdout "Alignment dir $alndir does not exist, creating...\n" unless $quiet;
		&makedir($alndir) or print $stderr "Fatal: Failed to create directory $alndir\n" and exit(1);
	}

	# the HMM directory
	unless ($hmmdir) { $hmmdir = File::Spec->catdir($sets_dir, $orthoset, 'hmms') }
	if (-d $hmmdir) {
		print $stdout "HMM dir $hmmdir exists.\n" unless $quiet;
	}
	else {
		print $stdout "HMM dir $hmmdir does not exist, creating...\n" unless $quiet;
		&makedir($hmmdir) or print $stderr "Fatal: Failed to create directory $hmmdir\n" and exit(1);
	}

	# the EST file
	if (-e $estfile) {
		print $stdout "EST file $estfile exists.\n" unless $quiet;
	}
	else {
		print $stderr "Fatal: EST file $estfile does not exist!\n" and exit(1);
	}

	# the HMMsearch output directory
	if (-d $hmmoutdir) {
		print $stdout "HMMsearch output dir $hmmoutdir exists.\n" unless $quiet;
		if ($clear_files) {
			&cleardir($hmmoutdir);
			print $stdout "Purged HMMsearch output dir $hmmoutdir of old result files.\n" unless $quiet;
		}
		else {
			&schedule_for_backup($hmmoutdir);
		}
	}
	else {
		print $stdout "HMMsearch output dir $hmmoutdir does not exist, creating...\n" unless $quiet;
		&makedir($hmmoutdir) or print $stderr "Fatal: Failed to create directory $hmmoutdir\n" and exit(1);
	}

  # the BLASTP output directory
  if (-d $blastoutdir) {
    print $stdout "BLASTP output dir $blastoutdir exists.\n" unless $quiet;
		if ($clear_files) {
			&cleardir($blastoutdir);
			print $stdout "Purged BLAST output dir $blastoutdir of old result files.\n" unless $quiet;
		}
		else {
			&schedule_for_backup($blastoutdir);
		}
  }
  else {
    print $stdout "BLASTP output dir $blastoutdir does not exist, creating...\n" unless $quiet;
    &makedir($blastoutdir) or print $stderr "Fatal: Failed to create directory $blastoutdir\n" and exit(1);
  }
	# the aa output directory
	if (-d $aaoutdir) {
		print $stdout "AA output dir $aaoutdir exists.\n" unless $quiet;
		if ($clear_files) {
			&cleardir($aaoutdir);
			print $stdout "Purged AA output dir $aaoutdir of old result files.\n" unless $quiet;
		}
		else {
			&schedule_for_backup($aaoutdir);
		}
	}
	else {
		print $stdout "AA output dir $aaoutdir does not exist, creating...\n" unless $quiet;
		&makedir($aaoutdir) or print $stderr "Fatal: Failed to create directory $aaoutdir\n" and exit(1);
	}

	# do the backup; create a tarball if desired
	print $stdout "Backing up old output files...\n" unless $quiet;
	my $tarfile = &create_tarball(@backup);
	print $stdout "Old output files backed up in $tarfile.\n" unless $quiet;
	undef(@backup);	# not needed anymore
	undef($tarfile);
	if ($clear_files) {
		# empty the directories
		&cleardir($hmmoutdir);
		&cleardir($blastoutdir);
		&cleardir($aaoutdir);
	}

	# does the set exist?
	# TODO rewrite this part using parametrized queries to protect from SQL injections?
	unless ( Wrapper::Mysql::set_exists($orthoset) ) {
		die "Set '$orthoset' does not exist in database '$mysql_dbname'. Typo in config file $configfile? Use $program_file-manager first to set up your ortholog sets. Ask your administrator.\n";
	}

	# everything is fine
	return 1;
}#}}}

# Sub: hmmlist
# Expects: scalar string directory path
# Returns: array hmmfiles
sub hmmlist {#{{{
	my $hmmdir = shift;
	if (-e $hmmdir) {
		my $dir = IO::Dir->new(File::Spec->catdir($hmmdir));
		while (my $file = $dir->read()) {
		  push(@hmmfiles, File::Spec->catfile($hmmdir, $file)) if ($file =~ /\.hmm$/);
		}
		$dir->close();
		return(sort(@hmmfiles));
	}
	else {
		print $stdout "single hmm\n" if $verbose;
		push(@hmmfiles, $hmmfile);
		return(@hmmfiles);
	}
}#}}}

# Sub: translate_est
# Translate a nucleotide fasta file to protein in all six reading frames
# Expects: scalar string filename
# Returns: scalar string filename (protfile)
sub translate_est {#{{{
  my ($infile) = shift;
  (my $outfile = $infile) =~ s/(\.[^.]*$)/_prot$1/;
  print $stdout "Translating $estfile in all six reading frames...\n" unless $quiet;
  if (-e $outfile) {
    print $stdout "$outfile exists, using this one.\n" unless $quiet;
    return($outfile);
  }
  my @translateline = qq($translateprog $infile > $outfile);
  system(@translateline) and die();
  return($outfile);
}#}}}

# sub: backup_old_output_files
# input: reference to list of relevant contigs
sub schedule_for_backup {#{{{
  my $outfile = shift;
	if (-d $outfile) {	# it's a directory
		my $dirh = IO::Dir->new($outfile);
		while (my $file = $dirh->read()) {
			next if $file =~ /^\./;
			&schedule_for_backup(File::Spec->catfile($outfile, $file));
		}
		$dirh->close();
	}
  elsif (-f $outfile) {
    push(@backup, $outfile);
  }
	return 1;
}#}}}

# sub: create_tarball
# writes a compressed tar archive
# Expects: list of files
# Returns: scalar string tarfilename
sub create_tarball {#{{{
	my @files = @_;
	my $tarfile = File::Spec->catfile($outdir, 'backup-' . $timestring . '.tar.bz2');
	my $tarball = Archive::Tar->new();
	$tarball->setcwd($outdir);
	$tarball->add_files(@files);
	$tarball->write($tarfile, COMPRESS_BZIP) or print $stderr "Fatal: Could not create tarball: $!\n" and exit(1);
	return $tarfile;
}#}}}

# Sub: makedir
# Creates a directory with parent directories if it does not already exist
# Expects: scalar string dirname
# Returns: True if successful
sub makedir {#{{{
  my $dir = shift;
  if (-e $dir and not -d $dir) {
    print $stderr "Fatal: $dir exists, but is not a directory! This will most likely lead to problems later. Exiting.\n" and exit(1);
  }
  elsif (!make_path($dir, { verbose => 0 })) {
    warn "Warning: Could not create $dir: $!\n";
    return 0;
  }
  return 1;
}#}}}

# Sub: cleardir
# Empties a directory of non-dotfiles
# Arguments: scalar string dirname
sub cleardir {#{{{
	my $dir = shift;
	opendir(my $dirh, $dir)
		or print $stderr "Fatal: Couldn't open dir $dir\: $!" and exit(1);
	foreach (readdir($dirh)) {
		next if $_ =~ /^\.\.?$/;
		unlink(File::Spec->catfile($dir, $_))
			or print $stderr "Warning: Could not delete file " . File::Spec->catfile($dir, $_) . ": $!";
	}
	closedir($dirh)
		or print $stderr "Fatal: Couldn't close dir $dir\: $!" and exit(1);
	return 1;
}#}}}

# Sub: preparedb
# Generate a clean database, deleting all existing tables and starting from scratch
# Returns: True on success
sub preparedb {#{{{
	my $query_create_ests = "CREATE TABLE $mysql_table_ests ( 
		`$mysql_col_id`        BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
		`$mysql_col_digest`    CHAR(32)     NOT NULL,           
		`$mysql_col_taxid`     INT UNSIGNED NOT NULL,       
		`$mysql_col_date`      INT UNSIGNED,
		`$mysql_col_hdr`       VARCHAR(255) NOT NULL,       
		`$mysql_col_seq`       MEDIUMBLOB DEFAULT NULL,
		PRIMARY KEY (`$mysql_col_id`),
		UNIQUE INDEX (`$mysql_col_digest`),
		INDEX (`$mysql_col_taxid`),
		INDEX (`$mysql_col_hdr`)
		)";

	my $query_create_hmmsearch = "CREATE TABLE $mysql_table_hmmsearch (
		$mysql_col_id        BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
		$mysql_col_taxid     INT UNSIGNED NOT NULL,       
		$mysql_col_query     VARCHAR(255) NOT NULL,       
		$mysql_col_target    CHAR(32)     NOT NULL,       
		$mysql_col_score     DOUBLE       NOT NULL,
		$mysql_col_evalue    VARCHAR(100) NOT NULL,
		$mysql_col_log_evalue DOUBLE       NOT NULL DEFAULT '-999',
		$mysql_col_start     INT          NOT NULL,
		$mysql_col_end       INT          NOT NULL,
		PRIMARY KEY ($mysql_col_id),
		UNIQUE INDEX ($mysql_col_query, $mysql_col_target),
		INDEX ($mysql_col_taxid),
		INDEX ($mysql_col_query),
		INDEX ($mysql_col_target),
		INDEX ($mysql_col_log_evalue)
		)";
	
	my $query_create_blast = "CREATE TABLE $mysql_table_blast (
		$mysql_col_id            BIGINT UNSIGNED NOT NULL AUTO_INCREMENT, 
		$mysql_col_taxid         INT UNSIGNED NOT NULL,       
		$mysql_col_blastdbpath   VARCHAR(255) NOT NULL,
		$mysql_col_query         CHAR(32)     NOT NULL,       
		$mysql_col_target        INT UNSIGNED NOT NULL,       
		$mysql_col_score         DOUBLE       NOT NULL,
		$mysql_col_evalue        VARCHAR(100) NOT NULL,
		$mysql_col_log_evalue     DOUBLE       NOT NULL DEFAULT '-999',
		$mysql_col_start         INT UNSIGNED NOT NULL,
		$mysql_col_end           INT UNSIGNED NOT NULL,
		PRIMARY KEY ($mysql_col_id),
		UNIQUE INDEX($mysql_col_query, $mysql_col_target),
		INDEX ($mysql_col_taxid),
		INDEX ($mysql_col_query),
		INDEX ($mysql_col_target),
		INDEX ($mysql_col_log_evalue)
		)";

	# open connection
	my $dbh = Wrapper::Mysql::mysql_dbh();

	# drop all tables
	foreach ($mysql_table_ests, $mysql_table_hmmsearch, $mysql_table_blast) {
		my $query_drop = "DROP TABLE IF EXISTS $_";
		print $stdout "$query_drop;\n" if $verbose;
		my $sql = $dbh->prepare($query_drop);
		$sql->execute()
		  or print $stderr "Fatal: Could not execute SQL query: $!\n" and exit(1);
	}

	# create all tables
	foreach my $query ($query_create_ests, $query_create_hmmsearch, $query_create_blast) {
		printf $stdout "$query;\n" if $verbose;
		my $sql = $dbh->prepare($query);
		$sql->execute()
		  or print $stderr "Fatal: Could not execute SQL query: $!\n" and exit(1);
	}

	# disconnect
	$dbh->disconnect();

	return 1;
} #}}}


# Sub: clear_db
# clears the database of previous results from the same species 
sub clear_db {#{{{

	my $species_name = shift;
	return unless $species_name;

	# get the species id from the database
	my $specid = &Wrapper::Mysql::get_taxid_for_species($species_name);
	return unless $specid;

	# count number of records 
	my $n = 0;

	# clear previous results from the same species
	my $dbh = Wrapper::Mysql::mysql_dbh();
	foreach my $table ($mysql_table_ests, $mysql_table_hmmsearch) {
		my $query = "DELETE FROM $table WHERE $mysql_col_taxid = ?";
		my $sth = $dbh->prepare($query);
		$n += $sth->execute( $specid );
	}
	my $sth = $dbh->prepare("DELETE FROM $mysql_table_taxa WHERE $mysql_col_id = ?");
	$n     += $sth->execute($specid) or print $stderr "$!" and exit(1);
	# disconnect ASAP
	$dbh->disconnect();

	return $n;
}#}}}

# Sub: insert_results_into_table
#	inserts the results of either hmmsearch or blastp into a mysql database
# Expects: scalar string TABLENAME, reference to array HITS, scalar string BLASTDATABASE (optional)
# Returns: Number of inserted results (hitcount)
sub insert_results_into_table {#{{{
	my $table = shift;
	my $hits  = shift;
	# called with 3 args, we are dealing with a blast result
	my $blastdb = (scalar @_ == 1) ? shift : undef;
	if (ref $blastdb) { confess 'Usage: insert_results_into_table($table, $columns_ref, $blastdb)' }
	my $hitcount;
	
	# this is a BLASTP result, we need the column 'blastdb'
	if ($blastdb) {
		my $query_insert_result = "INSERT IGNORE INTO $table (
			`$mysql_col_taxid`,
			`$mysql_col_blastdbpath`,
			`$mysql_col_query`,
			`$mysql_col_target`,
			`$mysql_col_score`,
			`$mysql_col_evalue`,
			`$mysql_col_log_evalue`,
			`$mysql_col_start`,
			`$mysql_col_end`,
			) VALUES (
			?,
			?,
			?,
			?,
			?,
			?,
			?,
			?,
			?)";
		my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
		my $sql = $dbh->prepare($query_insert_result);

		# this is a reference to an array of hashes
		foreach my $hit (@$hits) {
			$sql->execute(
				$species_id,
				$blastdb,
				$hit->{'query'},  # query (HMM)
				$hit->{'target'}, # target (header)
				$hit->{'score'},  # score
				$hit->{'evalue'},  # evalue
				$hit->{'evalue'} != 0 ? log($hit->{'evalue'}) : -999,  # natural logarithm only if not 0
				$hit->{'start'},
				$hit->{'end'},
			) or print $stderr "Fatal: Could not push to database!\n" and exit(1);
			++$hitcount;
		}
		$dbh->disconnect;
		return $hitcount;
	}
	# this is a HMMsearch result, need 8 columns
	else {
		# SQL query for pushing HMMsearch results to the db
		my $query_insert_result = "INSERT IGNORE INTO $table (
			`$mysql_col_taxid`,
			`$mysql_col_query`,
			`$mysql_col_target`,
			`$mysql_col_score`,
			`$mysql_col_evalue`,
			`$mysql_col_log_evalue`,
			`$mysql_col_start`,
			`$mysql_col_end`
			) VALUES (
			?,
			?,
			?,
			?,
			?,
			?,
			?,
			?)";

		my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
		my $sql = $dbh->prepare($query_insert_result);

		# this is a reference to an array of hashes
		foreach my $hit (@$hits) {
			$sql->execute(
				$species_id,
				$hit->{'query'},  # query (HMM)
				$hit->{'target'}, # target (header)
				$hit->{'score'},  # score
				$hit->{'evalue'}, # evalue
				$hit->{'evalue'} != 0 ? log($hit->{'evalue'}) : -999,	# natural logarithm only if not 0
				$hit->{'start'},	# start of hit domain
				$hit->{'end'}			# end of hit domain
			) or print $stderr "Fatal: Could not push to database!\n" and exit(1);
			++$hitcount;
		}
		$dbh->disconnect;
		return $hitcount;
	}
}#}}}

# Sub: file_is_empty
# tests whether a file is empty (i.e., contains nothing or only empty lines)
# Expects: scalar string path to file
# Returns: True if file is empty, false otherwise
sub file_is_empty {
	my $file = shift;
	my $fh = IO::File->new($file);
	while (<$fh>) {
		/^\s*$/ ? next : return 0;	# skip empty lines
	}
	return 1;
}

# Sub: make_hmms
# Generate HMMs for a given core-ortholog set
# Arguments: scalar string ortholog set name
# Returns: True if successful
sub make_hmms {#{{{
	my $set = shift;
	my $set_id = Wrapper::Mysql::get_set_id($set);
	my $hmmsuffix = '.hmm';
	# does the alignment dir exist?
	if (!-e $alndir) {
		&makedir($alndir) or print $stderr "Fatal: Failed to create directory $alndir\n" and exit(1);
	}
	# does the HMM dir exist?
	if (!-e $hmmdir) {
		&makedir($hmmdir) or print $stderr "Fatal: Failed to create directory $hmmdir\n" and exit(1);
	}
	print $stdout "Generating ortholog set $set...  This may take a long time, please be patient.\n" unless $quiet;

	# get the ortholog set from the database
	my $data = Wrapper::Mysql::get_ortholog_groups_for_set($set_id);

	my $num_orthoids = scalar(keys(%$data));
	my $o = 0;
	foreach my $orthoid (keys(%$data)) {
		&progress_bar($o, $num_orthoids, 25, '-');
		++$o;
		my $hmmfile = File::Spec->catfile($hmmdir, $orthoid . $hmmsuffix);

		# does this HMM already exist?
		# if so, skip to the next
		if (-e $hmmfile and not &file_is_empty($hmmfile)) { next }

		# if it exists, but the file is empty (this happens if you cancel the build
		# process), rebuild this HMM
		elsif (-e $hmmfile and &file_is_empty($hmmfile)) { print $stderr "Warning: Rebuilding HMM for $orthoid due to empty HMM file\n" }

		# no, create new fasta file and so on
		my $fafile = File::Spec->catfile($alndir, $orthoid . '.fa');
		my $fafh = IO::File->new($fafile, 'w');
		foreach my $id (keys(%{$data->{$orthoid}})) {
			printf($fafh ">%s\n%s\n", $id, $$data{$orthoid}{$id})
				or die("Fatal: Could not write to file '$fafh'\: $!\n");
		}
		$fafh->close();

		# align
		my $alnfile = &align($fafile, $orthoid)
			or die("Fatal: Alignment failed for '$fafh'\: $!\n");

		# convert to stockholm
		my $stockhfile = &fasta2stockholm($alnfile, $orthoid)
			or die("Fatal: Conversion to Stockholm format failed for '$alnfile'\: $!\n");

		# build HMM
		&hmmbuild($stockhfile, $hmmfile)
			or die("Fatal: HMM generation failed for '$alnfile'\: $!\n");
	}
	undef($data);	# free memory... well, it's bound to go out of scope anyway
	return($hmmdir);
}#}}}

# Sub: align
# Generate a fasta alignment from a fasta file
# Arguments: Scalar string filename, scalar string orthoid
# Returns: Scalar string alignment filename on success, false otherwise
sub align {#{{{
	my $fafile = shift;
	my $orthoid = shift;
	(my $fasuffix = $fafile) =~ /(\.(fa|fas|fasta))/;
	my $alnsuffix = '.aln';
	my @alignment_cmd = qq($alignment_program $fafile 2> /dev/null);	# this prints the alignment to STDOUT, must be captured somehow
	print $stdout "@alignment_cmd\n" if $debug;
	my $alnf = File::Spec->catfile($alndir, $orthoid . '.aln.fa');
	my $aln = `@alignment_cmd`
		or print $stderr "Fatal: Alignment for $orthoid failed: $?\n" and exit(1);
	my $alnfh = IO::File->new($alnf, 'w')
		or print $stderr "Fatal: Could not open alignment file '$alnf' for writing: $!\n" and exit(1);
	print $alnfh $aln
		or print $stderr "Fatal: Could not write alignment to file $alnf\: $!\n" and exit(1);
	$alnfh->close();
	return $alnf;
}#}}}

# Sub: fasta2stockholm
# Converts a fasta file into a stockholm file. Warning: Does no validity checking whatsoever!
# Arguments: Scalar string filename
# Returns: Scalar string filename
sub fasta2stockholm {#{{{
	my $fafile = shift;
	my $orthoid = shift;
	my $fh = Seqload::Fasta->open($fafile);
	my $stockhf = File::Spec->catfile($alndir, $orthoid . '.stockh');
	my $stockhfh = IO::File->new($stockhf, 'w')
		or print $stderr "Fatal: Could not open file '$stockhf' for writing: $!\n" and exit(1);
	print $stockhfh "# STOCKHOLM 1.0\n";
	while (my ($h, $s) = $fh->next_seq()) {
		printf($stockhfh "%-50s %s\n", $h, $s)
			or print $stderr "Fatal: Could not write Stockholm file $stockhfh\: $!" and exit(1);
	}
	print $stockhfh "//";
	close($stockhfh);
	return $stockhf;
}#}}}

# Sub: hmmbuild
# Generates a hidden Markov model (HMM) file from an alignment (fasta) file.
# Arguments: Scalar string filename, scalar string hmmfilename
# Returns: True on success, false otherwise
sub hmmbuild {#{{{
	my $alnfile = shift;
	my $hmmfile = shift;
	my $alnsuffix = '.aln';
	my $hmmsuffix = '.hmm';
	my $hmmname = basename($hmmfile, $hmmsuffix);
	my @hmmbuild_cmd = qq($hmmbuild_program -n $hmmname $hmmfile $alnfile > /dev/null);
	print $stdout "@hmmbuild_cmd\n" if $debug;
	system(@hmmbuild_cmd) and
		return 0;
	return $hmmfile;
}#}}}

# Sub: make_blastdb 
# Create a BLAST database from a file. Pulls everything from the MySQL database.
# Arguments: Scalar string ortholog set name
# Returns: Scalar string path_to_blastdbfile
sub make_blastdb {#{{{
	my $setid = shift or croak('Usage: make_blastdb(SETID)');

	# build the paths for input and output
	my $dbfile = File::Spec->catfile($sets_dir, $orthoset, 'blast', $orthoset);
	my $infile = File::Spec->catfile($dbfile . ".fa");

	# check whether a database already exists
	if (-e File::Spec->catfile($dbfile . '.psq')) {
		print $stdout "BLAST DB for set $orthoset exists in $dbfile.\n" unless $quiet;
		return $dbfile;
	}

	# database not extant, we have to create it
	print $stdout "BLAST DB for set $orthoset does not exist, creating in $dbfile...\n"
		unless $quiet;
	my $infh = File::Temp->new();
	# get the sequences from the database
	my $sequences = Wrapper::Mysql::get_aaseqs_for_set($setid);

	# write to output file
	while (my ($h, $s) = each %$sequences) {
		# warn if the sequence has invalid characters
		if ($s =~ /([^ACDEFGHIKLMNPQRSTVWXYZUX]+)/) {
			print $stderr "Warning: Invalid characters '$1' in protein sequence $h. Let's hope BLAST will not choke on this one.\n";
		}
		# but write out anyway
		printf($infh ">%s\n%s\n", $h, $s)
			or print $stderr "Fatal: Could not write to makeblastdb input file $infile\: $!\n" and exit(1);
	}
	undef $sequences;
	close($infh);
	

	# make blast database
	my @makeblastdbcmd = qq($makeblastdbprog -in $infh -out $dbfile -input_type fasta -dbtype prot -title $orthoset > /dev/null);
	print $stdout "@makeblastdbcmd\n" if $debug;
	system(@makeblastdbcmd) and print $stderr "Fatal: makeblastdb failed: $!\n" and exit(1);
	return $dbfile;
}#}}}

# Sub: load_data_infile
# LOAD DATA LOCAL INFILE into a table
# Arguments: scalar string filename, scalar string tablename, reference to list of columns
# Returns: scalar int number of loaded rows
sub load_data_infile {#{{{
	my $protfile = shift(@_);
	my $table_ests = shift(@_) or croak 'Usage: &load_data_infile($protfile, $mysql_table_ests [, $columns_reference])';
	my $columns;
	my $list;
	if (scalar(@_)) {
		$columns = shift(@_);
		unless (ref($columns)) {
			croak 'Usage: &load_data_infile($protfile, $mysql_table_ests [, $columns_reference])';
		}
		$list = join(',', @$columns);
	}

	# Create temporary csv file for high-speed reading into database
	my $tmpfh = File::Temp->new('UNLINK' => 1, 'TEMPLATE' => File::Spec->catfile('/tmp', 'XXXX'));
	my $protfh = Seqload::Fasta->open($protfile);
	while (my ($h, $s) = $protfh->next_seq()) {
		$h =~ s/,/ /g;	# remove all commas from the header, they confuse the csv parser
		$s =~ s/-//g;	# remove all gaps from the sequence
		if ($s =~ /([^ACDEFGHIKLMNPQRSTVWYX*])/i) {
			# change all Us to X if requested
			if ($u_subst and $s =~ s/U/$u_subst/gi) {
				print $stderr "Warning: Selenocysteine character ('U') replaced with '$u_subst' in sequence $h.\n";
			}
			else {
				print $stderr "Warning: Sequence $h contains nonstandard amino acid symbol '$1'! Make sure your alignment program tolerates this.\n";
			}
		}
		printf($tmpfh "%s,%d,%d,%s,%s\n", 
			# good idea or not?
			# good idea
			Digest::SHA->sha256_hex($h, $s),
			$species_id,
			$timestamp_start,
			$h,
			$s
		);
	}
	$tmpfh->close();
	# no need to close the protfh since we're already through it, it gets closed automagically

	# load data from csv file into database
	my $query = "LOAD DATA LOCAL INFILE '$tmpfh' INTO TABLE $table_ests FIELDS TERMINATED BY ',' ($list)";

	# open connection
	my $dbh = Wrapper::Mysql::mysql_dbh();
	my $sth = $dbh->prepare($query);
	$num_ests = $sth->execute();
	# disconnect ASAP and die if errors
	$dbh->disconnect;
	defined($DBI::errstr) ? die($DBI::errstr, "\n") :	return $num_ests;
}#}}}

# Sub: get_transcripts 
# Get transcript sequences from the database, using their ID as header
# Arguments: None
# Returns: Filehandle
sub get_transcripts {#{{{
	my $species_id = shift;
	my $tmpfh = File::Temp->new('UNLINK' => 1, 'TEMPLATE' => File::Spec->catfile($tmpdir, 'XXXX'));
	my $nseqs = 0;
	my $data = Wrapper::Mysql::get_transcripts($species_id);
	while (my $row = shift @$data) {
		printf($tmpfh ">%s\n%s\n", $$row[0], $$row[1])
			or print $stderr "Fatal: Could not write to file $tmpfh\: $!\n" and exit(1);
		++$nseqs;
	}
	print $stdout "Wrote $nseqs sequences to $tmpfh\n" unless $quiet;
	return $tmpfh;
}#}}}

# Sub: get_orthologs
# Get orthologous sequences from the database, the final result handler
# Arguments: ortholog id
# Returns: filename
sub get_orthologs {#{{{
	my $orthoid = shift;
	my $estdigest = shift;
	# what do we want from the database?
	# TODO rewrite this part using parametrized queries to protect from SQL injections?
	my $query = "SELECT DISTINCT
			$mysql_table_orthologs.$mysql_col_orthoid AS orthogroup,
			$mysql_table_taxa.$mysql_col_name	        AS name,
			$mysql_table_ests.$mysql_col_digest       AS EST_digest,
      $mysql_table_aaseqs.$mysql_col_hdr        AS AA_header,
      $mysql_table_aaseqs.$mysql_col_seq        AS AA_seq,
      $mysql_table_ests.$mysql_col_hdr          AS EST_hdr,
      $mysql_table_ests.$mysql_col_seq          AS EST_seq
    FROM $mysql_table_aaseqs
		INNER JOIN $mysql_table_taxa
			ON $mysql_table_aaseqs.$mysql_col_taxid = $mysql_table_taxa.$mysql_col_id
    INNER JOIN $mysql_table_blast 
			ON $mysql_table_aaseqs.$mysql_col_id = $mysql_table_blast.$mysql_col_target 
    INNER JOIN $mysql_table_hmmsearch 
			ON $mysql_table_blast.$mysql_col_query = $mysql_table_hmmsearch.$mysql_col_target  
    INNER JOIN $mysql_table_ests 
			ON $mysql_table_hmmsearch.$mysql_col_target = $mysql_table_ests.$mysql_col_digest 
    INNER JOIN $mysql_table_orthologs 
			ON $mysql_table_hmmsearch.$mysql_col_query = $mysql_table_orthologs.$mysql_col_orthoid
		INNER JOIN $mysql_table_seqpairs
			ON $mysql_table_orthologs.$mysql_col_seqpair = $mysql_table_seqpairs.$mysql_col_id 
		WHERE $mysql_table_orthologs.$mysql_col_orthoid = ?
			AND $mysql_table_ests.$mysql_col_digest       = ?
			AND $mysql_table_seqpairs.$mysql_col_aaseq    = $mysql_table_aaseqs.$mysql_col_id
		ORDER BY $mysql_table_hmmsearch.$mysql_col_evalue, $mysql_table_blast.$mysql_col_evalue";
	my $dbh = Wrapper::Mysql::mysql_dbh();
	my $sql = $dbh->prepare($query);
	$sql->execute( $orthoid, $estdigest );
	my $result = $sql->fetchall_arrayref();
	$dbh->disconnect();
	return $result;
}#}}}

__END__

# Documentation#{{{
=head1 NAME

Orthograph

=head1 DESCRIPTION

F<Ortho>logy prediction using a F<G>raph-based, F<R>eciprocal F<A>pproach with
F<P>rofile F<H>idden F<M>odels

=head1 SYNOPSIS

orthograph [OPTIONS]

=head1 WARNING

B<This documentation is outdated!> It will catch up with recent development on
another day. However, careful work has been put into the README file, which
also contains a quickstart guide. Please refer to that. 

=head1 DESCRIPTION

Orthograph expects a certain table structure for the core-ortholog set. You may
run the provided script orthograph_manager with the B<-c> switch once, which
does exactly that.

=head1 OPTIONS

=head2 -c CONFIGFILE

Use CONFIGFILE instead of orthograph.conf. Any options on the command line override
options set in the config file.

=head2 -v

Verbose output. More information about the HMMsearch and BLAST hits. Normally
you don't want to see this. If you are really interested in what Orthograph is
thinking during the analysis, uncomment this. Verbose and quiet are mutually
exclusive.

=head2 -q

Quiet output. Uncomment this if you don't want to be bothered during the
analysis. Verbose and quiet are mutually exclusive.

No other options documented yet. Use the config file, please.

=head1 CONFIG FILE

The configuration file allows to set all options available on the command line
so that the user is spared having to use a very long command every time.

The config file has to be in ini-style: 

	# this is a comment
	translateprog  = fastatranslate
	hmmdir         = /home/malty/thesis/orthograph/hmms
	estfile        = /home/malty/data/cleaned/Andrena_vaga.fa
	mysql_dbname   = orthograph
	mysql_dbserver = localhost

etc. Empty lines and comments are ignored, keys and values have to be separated
by an equal sign. 

For your convenience, there is an example config file provided in this package.
You may customize it to your local environment.

=head2 AVAILABLE OPTIONS:

=head2 estfile

The fasta file containing the EST sequence database.

=head2 hmmsearch_evalue_threshold

e-Value threshold for the HMM search. Must be a number in scientific notation
like 1e-05 or something.

=head2 hmmdir

The directory containing the HMM files that are used to search the EST
database. See also F<hmmfile>.

=head2 hmmfile

The HMM file to use if you want to run Orthograph on a single HMM.

=head2 hmmsearch_output_dir

The directory name where the hmmsearch output files will be placed.

=head2 hmmsearchprog

The hmmsearch program. On most systems, this is 'hmmsearch', which is the
default. Change this if your binary has a different name.

=head2 mysql_dbname

MySQL: Database name. Ask your administrator if you don't know.

=head2 mysql_dbpassword

MySQL: Database password. Ask your administrator if you don't know.

=head2 mysql_dbserver

MySQL: Database server. Normally 'localhost'. Ask your administrator if you
don't know.

=head2 mysql_dbuser

MySQL: Database user name. Ask your administrator if you don't know.

=head2 mysql_table_ests

MySQL: Table name for the EST sequences. Ask your administrator if you don't
know.

=head2 mysql_table_hmmsearch

MySQL: Table name for the HMMsearch results. Ask your administrator if you
don't know.

=head2 mysql_table_blast

MySQL: Table name for the BLAST results. Ask your administrator if you don't
know.

=head2 output_directory

Output directory to use by Orthograph. It will be created if it does not exist.

=head2 quiet

Quiet operation: Orthograph will retain most of the status messages.

=head2 species_name

Name of the analyzed species. Will occur in the database as well as in all
output files in appropriate places.

=head2 hmmsearch_score_threshold

Score threshold for the HMM search. Must be a number.

=head2 translate_program

The tool to use for translation of the EST sequence file. The program must
accept a fasta file name as input and provide its output on STDOUT, which is
then being redirected into a file that Orthograph uses.

=head2 verbose

Be verbose (output more information about what is going on). 

=head1 AUTHOR

Written by Malte Petersen <mptrsen@uni-bonn.de>

=head1 COPYRIGHT

Copyright (C) 2012 Malte Petersen 

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details. You
should have received a copy of the GNU General Public License along with this
program; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
Suite 330, Boston, MA 02111-1307 USA

=cut
#}}}}
