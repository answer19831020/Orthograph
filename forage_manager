#!/usr/bin/perl
# Documentation before the code#{{{
=head1 NAME 

B<forage_manager> - prepare a MySQL database for running Forage

=head1 SYNOPSIS

B<forage_manager> -u USERNAME -p PASSWORD FASTAFILE

=head1 DESCRIPTION

Prepares a core orthologs database for running Forage. Basically, reads a fasta
file and loads its content into a temporary table. Due to the usage of the
MySQL LOAD INFILE routine, this process is pretty fast. After that, the content
is processed and distributed into the Forage database structure.

This script is designed to work with ortholog set fasta files generated by
OrthoDB5 (http://cegg.unige.ch/orthodb5). Therefore, the FASTA headers have
to be formatted in a certain way:

  >TAXSH:xxxxxx SomeIdentifier EOG5XXXXX OriginalIdentifier 

Where the following applies: 

=over 2

=item * TAXSH is the 5-letter taxon shorthand that OrthoDB uses; xxxxxx is an identifier that nobody knows what it's good for.

=item * SomeIdentifier is just some other identifier (I haven't figured out what this corresponds to)

=item * EOG5XXXXX is the OrthoDB ID. This will later be used to cluster the orthologs together.

=item * OriginalIdentifier is the original (i.e. official gene set) identifier for this particular orthologous sequence.

=back

None of these need to be unique, but the combination of all three must be.

The fields must be separated by whitespace and in this particular order. The
forage_manager script does not perform any recognition on the fields whatsoever. If
you download your orthologous sequences from OrthoDB, no problems should arise.

Nucleotide fasta files need a similar, but simpler format:

  >TAXSH Identifier

Where TAXSH is the 5-letter taxon shorthand that OrthoDB uses, and Identifier is
the sequence ID. Some of these may or may not correspond to IDs that occur in
ortholog set headers. This is later used for identification of corresponding
peptide-nucleotide pairs. Text after the Identifier will be ignored.

B<forage> expects a certain table structure. You may create it by hand using
the SQL statement found at the end of this manual by or whatever workflow you
fancy, or you may run B<forage_manager -c> once, which does the same thing.
=cut#}}}

use strict;
use warnings;
use Carp;
use Getopt::Long;
use File::Temp;     # temporary files
use File::Spec;
use Seqload::Fasta qw(fasta2csv check_if_fasta); # object-oriented access to fasta files, fasta2csv converter
use DBI;
use DBD::mysql;
use Seqload::Fasta;
use Data::Dumper;


my $dbname       = 'forage';
my $dbserver     = '127.0.0.1';
my $username     = undef;
my $name         = undef;
my $pwd          = undef;
my $setname      = undef;
my $prefix       = 'forage_';
my $blastdir     = '';
my $create       = 0;
my $delete       = 0;
my $overwrite    = 0;
my $reassignorthologs = 0;
my $isnucleotide = 0;
my $ispeptide    = 0;
my $listogs      = 0;
my $listsets     = 0;
my $temptable    = 'temp';
my $sql;
# table names
my %t            = (
	'blastdbs'     => 'blastdbs',
	'ogs'          => 'ogs',
	'orthologs'    => 'orthologs',
	'seqpairs'     => 'sequence_pairs',
	'aaseqs'       => 'aaseqs',
	'ntseqs'       => 'ntseqs',
	'seqtypes'     => 'seqtypes',
	'set_details'  => 'set_details',
	'taxa'         => 'taxa',
	'users'        => 'users',
	'temp'         => 'temp',
);
	
my %names;
my $description;
my $ogs_name;
my $total_seqs;


#{{{POD: Options
=head1 OPTIONS

=head2 -p PASSWORD

Password for the connection. No default; this must be set.

=head2 -u USERNAME

Username for the connection. No default; this must be set.

=head2 -c

(Re-)creates the necessary table structure. B<Careful, this will wipe out everything
you had in the table.> You should not do this more than once in the process of using
Forage unless you know what you are doing.

=head2 -D DATABASE

Database name to use. Defaults to 'forage'.

=head2 -h HOST

Database server. Defaults to '127.0.0.1', which is (mostly) equivalent to
'localhost'.

=head2 -blastdir /BLAST/DATABASE/PREFIX

BLAST database prefix. Must point to a directory containing the BLAST
databases. These themselves must be each in its own directory, e.g., like so:

  /home/username/blast/apismellifera
  /home/username/blast/drosophilamelanogaster

The directory name of each BLAST database must match with the taxon name in the
fasta headers, and the BLAST database inside it must be named as F<taxon_prot>.

If all is setup like described, the prefix would be specified as: B<-b
/home/username/blast>.

=head2 -prefix PREFIX

Table name prefix. Useful if you want to employ multiple forage instances on
the same database. Tables will be named 'prefix_tablename'. The underscore is
added automatically. Defaults to 'forage'.

=head2 -o

Overwrite existing data. This is necessary when re-loading an ortholog set with
a name that already exists in the database. Be cautious; this may cause data
disintegration (duplicates and orphan entries and stuff like that). Unless you
know what you are doing, prefer deleting and re-creating to overwriting.

=head2 -r

Reassign orthologs. May be called manually after proteome data has been added
to establish orthology relationships between nucleotide and peptide sequences.
This is called automatically when adding an ortholog set from OrthoDB and when
adding nucleotide data..

=head2 -t TEMPTABLE

Temporary table name to use. Defaults to 'temp'.

=head2 -nuc 

Load nucleotide data. These fasta files must have headers formatted as
described above. The script will load them into the database and re-assign the
nucleotide/peptide pairs based on the headers (so these must correspond).

=head2 -pep

Load nucleotide data. These fasta files must have headers formatted as follows:

  >TAXSH SEQUENCE_ID

The script will load them into the database and re-assign the
nucleotide/peptide pairs based on the headers (so these must correspond).

=cut#}}}

GetOptions(
	'D=s'      => \$dbname,
	'prefix=s' => \$prefix,
	'blastdir=s' => \$blastdir,
	'c'        => \$create,
	'delete'   => \$delete,
	'h=s'      => \$dbserver,
	'lo'       => \$listogs,
	'ls'       => \$listsets,
	'n=s'      => \$name,
	'o'        => \$overwrite,
	'p=s'      => \$pwd,
	's=s'      => \$setname,
	't=s'      => \$temptable,
	'u=s'      => \$username,
	'r'        => \$reassignorthologs,
	'nuc'      => \$isnucleotide,
	'pep'      => \$ispeptide,
	);
my $infile = shift @ARGV;

# make sure there is at least one underscore at the end of the prefix
$prefix =~ s/_$//;
$prefix .= '_';
# prepend the prefix to the table names. useful for dropping all of 'em.
$t{$_} = $prefix.$t{$_} foreach keys(%t);

# name == username unless defined name
$name = $username unless defined($name);

# to start off with nt and aa sequence types
my $insert_seqtypes = "INSERT IGNORE INTO $t{'seqtypes'} (type) VALUES ('nt'),('aa')";

# the queries for the individual tables
my %create_table = (#{{{
	# table: blastdbs
	'blastdbs' => "CREATE TABLE `$t{'blastdbs'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `setid`        INT(10) UNSIGNED DEFAULT NULL, UNIQUE(setid),
    `blastdb_path` VARCHAR(255)     DEFAULT NULL)",
	
	# table: ogs
	'ogs' => "CREATE TABLE `$t{'ogs'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `type`         CHAR(3),
    `taxid`        INT(10) UNSIGNED, UNIQUE(taxid),
    `version`      VARCHAR(255))",
	
	# table: ortholog_set
	'ortholog_set' => "CREATE TABLE `$t{'orthologs'}` (
    `id`               INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `setid`            INT(10) UNSIGNED NOT NULL,
    `ortholog_gene_id` VARCHAR(10)      NOT NULL,
    `sequence_pair`    INT(10) UNSIGNED NOT NULL,
    UNIQUE INDEX (setid, ortholog_gene_id, sequence_pair))",

	# table: sequence_pairs
	'sequence_pairs' => "CREATE TABLE `$t{'seqpairs'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxid`        INT(10) UNSIGNED NOT NULL,
    `ogs_id`       INT(10) UNSIGNED NOT NULL,
    `aa_seq`       INT(10) UNSIGNED NOT NULL, INDEX(aa_seq),
    `nt_seq`       INT(10) UNSIGNED, INDEX(nt_seq), 
    `date`         INT(11) UNSIGNED,
    `user`         INT(10) UNSIGNED,
		UNIQUE(aa_seq))",

	# table: sequences_aa
	'aa_sequences' => "CREATE TABLE `$t{'aaseqs'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxid`        INT(10) NOT NULL, INDEX(taxid),
    `header`       VARCHAR(512) NOT NULL, UNIQUE(header),
    `sequence`     MEDIUMBLOB,
    `user`         INT(10) UNSIGNED,
    `date`         INT(11) UNSIGNED)",

	# table: sequences_nt
	'nt_sequences' => "CREATE TABLE `$t{'ntseqs'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxid`        INT(10) NOT NULL, INDEX(taxid),
    `header`       VARCHAR(512) NOT NULL, UNIQUE(header),
    `sequence`     MEDIUMBLOB,
    `user`         INT(10) UNSIGNED,
    `date`         INT(11) UNSIGNED)",

	# table: set_details
	'set_details' => "CREATE TABLE `$t{'set_details'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(255), UNIQUE(name),
    `description`  BLOB)",

	# table: taxa
	'taxa' => "CREATE TABLE `$t{'taxa'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(20),  UNIQUE(name),
    `longname`     VARCHAR(255))",
	
	# table: users
	'users' => "CREATE TABLE `$t{'users'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(255), UNIQUE(name))",
	# table: seqtypes
	'seqtypes' => "CREATE TABLE `$t{'seqtypes'}` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `type`         CHAR(3),     UNIQUE(type))",
);#}}}

unless (defined $username and defined $pwd ) {
	die "Fatal: You must specify database username (-u) and password (-p) AND core-ortholog set name (-s).\n";
}

#--------------------------------------------------
# # if you really want to delete everything...
#-------------------------------------------------- 
if ($delete) {
	&drop_tables;
	print "OK.\n";
	exit;
}
#--------------------------------------------------
# # if you only want me to create the tables, fine. this will give you a clean slate.
#-------------------------------------------------- 
if ($create) {
	&drop_tables;
	&create_tables;
	print "OK.\n";
	exit;
}

#--------------------------------------------------
# Just list the present ortholog sets, then exit
# TODO make this less redundant!
#-------------------------------------------------- 
if ($listsets) {
	my $sets = &get_ortholog_sets();
	my $maxlen_set  = 0;
	my $maxlen_desc = 0;
	# determine maximum length of set names for the table
	foreach (keys(%$sets)) {
		$maxlen_set = length($_) if (length($_) > $maxlen_set);
		$maxlen_desc = length($$sets{$_}) if (length($$sets{$_}) > $maxlen_desc);
	}
	print "The following ortholog sets are presently installed:\n";
	printf("%-${maxlen_set}s  %-${maxlen_desc}s\n", 'Set name', 'description');
	printf("%-${maxlen_set}s--%-${maxlen_desc}s\n", '-' x $maxlen_set, '-' x $maxlen_desc);
	foreach (keys(%$sets)) {
		printf("%-${maxlen_set}s  %s\n", $_, $$sets{$_});
	}
	exit;
}

if ($listogs) {
	my $ogs = &list_ogs();
	my $maxlen_longname = 0;
	my $maxlen_version  = 0;
	foreach (keys %$ogs) {
		$maxlen_version = length($_) if (length($_) > $maxlen_version);
		$maxlen_longname = length($$ogs{$_}) if (length($$ogs{$_}) > $maxlen_longname);
	}
	print "The following OGS are presently installed:\n";
	printf("%-${maxlen_longname}s  %s\n", 'Taxon', 'OGS version');
	printf("%s  %11s\n", '-' x 5, '-' x 11);
	foreach (keys(%$ogs)) {
		printf("%-${maxlen_longname}s  %s\n", $_, $$ogs{$_});
	}
	exit;
}

if ($isnucleotide) {
	# 0 for nucleotide
	&load_taxon($infile, 0) or die("Fatal: Nucleotide loading failed\n");
	exit;
}
elsif ($ispeptide) {
	unless ($blastdir) {
		$blastdir = &getblastdir();
	}
	# 1 for amino-acid
	&load_taxon($infile, 1, $blastdir) or die("Fatal: Peptide loading failed\n");
	exit;
}

# otherwise, this must be an orthodb file

#--------------------------------------------------
# # continue and gather information
#-------------------------------------------------- 

($infile) or die "Usage: $0 [-nt|-pep] FASTAFILE\n";

# TODO stop here if db structure is not present!

print "Setting up core ortholog set in $dbname on $dbserver... (press CTRL+C to abort)\n";

if (!$setname) { $setname = &get_setname() }

if (&mysql_check("SELECT name FROM $t{'set_details'} WHERE name = '$setname'")) {
	warn "Warning: An ortholog set with this name already exists in $dbname on $dbserver.\n";
	unless ($overwrite) {
		die "Pick a different name or use -o for overwriting.\n";
	}
	$| = 1;
	print "Overwriting existing entries (may cause data disintegration). ";
	print "Are you sure (y/n)? ";
	$| = 0;
	my $yn = readline(STDIN);
	chomp $yn;
	unless ($yn eq 'y') {
		print "OK, exiting.\n";
		exit;
	}
}

print "Enter a description for the set (optional but recommended): "; 
$description = <STDIN>;
chomp $description;

unless (defined $setname) { croak "Fatal: You must specify the core-ortholog set name (-s).\n" }

#--------------------------------------------------
# # read the input file and create a CSV file with everything we know 
#-------------------------------------------------- 

my $tmpfile = File::Temp->new();

my $faobj = Seqload::Fasta->open($infile);
no warnings;	# disable warnings for printing of the NULL column
while (my ($hdr, $seq) = $faobj->next_seq()) {
	++$total_seqs;
	my @line = split(/\s+/, $hdr, 5);	# maximum of five fields, the last one may contain whitespace
	$line[0] =~ s/:.*//;	# remove everything from the colon
	printf $tmpfile "%s,%s,%s,%s,%s,%s,%s,%s\n", 
		$line[0],     # taxon shorthand
		undef,        # this will later be the full name
		$setname,	    # set name
		$line[2],     # orthodb id, e.g. EOG500001
		File::Spec->catdir($blastdir), # blast database directory
		$line[3],     # original proteome id
		$seq,         # sequence
		$description; # set description
}
use warnings;	# resume yelling 
$faobj->close();

#--------------------------------------------------
# # create a temporary table for high-speed loading of the data. we can sort it out later.
#-------------------------------------------------- 

my $create_temp_table_query = "CREATE TABLE $temptable (
    `name`     VARCHAR(255), INDEX(name),
    `longname` VARCHAR(255),
		`orthoset` VARCHAR(255), INDEX(orthoset),
		`orthoid`  VARCHAR(255), INDEX(orthoid),
		`blastdb`  VARCHAR(255),
		`header`   VARCHAR(512), INDEX(header),
		`sequence` VARCHAR(255),
		`description` VARCHAR(255))";
my $loadquery = "LOAD DATA LOCAL INFILE '$tmpfile' 
  INTO TABLE $temptable FIELDS TERMINATED BY ',' (
		name,
		longname,
		orthoset,
		orthoid,
		blastdb,
		header,
		sequence,
		description)";

my $dbh = &mysql_dbh();
$dbh->do("DROP TABLE IF EXISTS $temptable") or die "Fatal: Could not DROP TABLE $temptable\n";
$dbh->do($create_temp_table_query) or die "Fatal: Could not CREATE TABLE $temptable\n";
$dbh->do($loadquery) or die "Fatal: Could not LOAD DATA into temporary table $temptable\n";
$dbh->disconnect;

print "Successfully loaded $total_seqs sequences from $infile into $temptable on $dbserver.\n";

# get name and longname from the temp table; they do not get updated automatically
$dbh = &mysql_dbh();
$sql = $dbh->prepare("SELECT DISTINCT name, longname FROM temp");
$sql->execute();
while (my @result = $sql->fetchrow) {
	$names{$result[0]} = '';
}
$dbh->disconnect;

# ask the user for the taxon names that aren't complete
foreach (sort(keys %names)) {
	unless ($names{$_}) {
		print "Enter complete name for the shorthand '$_': ";
		$names{$_} = <STDIN>;
		chomp $names{$_};
	}
}

# update the temptable with the collected info
$dbh = &mysql_dbh;
foreach (keys %names) {
	$sql = $dbh->prepare("UPDATE $temptable SET longname='" . $names{$_} . "' WHERE name='" . $_ . "'");
	$sql->execute();
}
$dbh->disconnect;

#--------------------------------------------------
# # temptable is now complete. going to insert the data into the main table 
#-------------------------------------------------- 

# TODO check whether the proteome header format is right (protein id only)!
# TODO import the proteome data via a second temptable

my @queries = (
	# user name
	"INSERT IGNORE INTO $t{'users'} (name) VALUES ('$username')",
	# taxa (name, longname)
	"INSERT IGNORE INTO $t{'taxa'} (name, longname) 
    SELECT DISTINCT $temptable.name, $temptable.longname 
    FROM $temptable",
	# set name + description
	"INSERT IGNORE INTO $t{'set_details'} (name, description)
    SELECT DISTINCT $temptable.orthoset, $temptable.description 
    FROM $temptable LIMIT 1",
	# blast databases
	"INSERT IGNORE INTO $t{'blastdbs'} (setid, blastdb_path) 
    SELECT DISTINCT $t{'set_details'}.id, $temptable.blastdb 
    FROM $temptable LEFT JOIN $t{'set_details'} 
    ON $t{'set_details'}.name = $temptable.orthoset",
	# pep sequences
	"INSERT IGNORE INTO $t{'aaseqs'} (taxid, header, sequence, user, date) 
    SELECT $t{'taxa'}.id, $temptable.header, $temptable.sequence, $t{'users'}.id, UNIX_TIMESTAMP()
    FROM $temptable LEFT JOIN $t{'taxa'} 
    ON $temptable.name  = $t{'taxa'}.name
    INNER JOIN $t{'users'}
    ON $t{'users'}.name = '$username'",
	# delete everything where header or sequence is NULL or empty
	"DELETE FROM $t{'aaseqs'}
    WHERE $t{'aaseqs'}.header IS NULL
    OR $t{'aaseqs'}.sequence IS NULL
    OR $t{'aaseqs'}.header = ''
    OR $t{'aaseqs'}.sequence = ''",
	# sequence pairs (pep-nuc)
	"INSERT IGNORE INTO $t{'seqpairs'} (taxid, ogs_id, aa_seq, nt_seq, date, user)
    SELECT $t{'taxa'}.id, $t{'ogs'}.id, $t{'aaseqs'}.id, $t{'ntseqs'}.id, UNIX_TIMESTAMP(), $t{'users'}.id
    FROM $t{'taxa'}
    INNER JOIN $t{'aaseqs'}
    ON $t{'aaseqs'}.taxid = $t{'taxa'}.id
    LEFT JOIN $t{'ogs'}
    ON $t{'taxa'}.id = $t{'ogs'}.taxid
    LEFT JOIN $t{'ntseqs'}
    ON $t{'aaseqs'}.header = $t{'ntseqs'}.header
    INNER JOIN $t{'users'}
    ON $t{'users'}.name = '$username'",
	# orthologous groups
	"INSERT IGNORE INTO $t{'orthologs'} (setid, ortholog_gene_id, sequence_pair) 
    SELECT $t{'set_details'}.id, $temptable.orthoid, $t{'seqpairs'}.id 
    FROM $t{'aaseqs'} 
    INNER JOIN $temptable 
    ON $t{'aaseqs'}.header = $temptable.header 
    INNER JOIN $t{'seqpairs'} 
    ON $t{'seqpairs'}.aa_seq = $t{'aaseqs'}.id 
    INNER JOIN $t{'set_details'} 
    ON $t{'set_details'}.name = $temptable.orthoset",
);

$dbh = &mysql_dbh;
my $nrows;
foreach (@queries) {
	print $_ . ";\n";
	$nrows = $dbh->do($_) or die();
	($nrows > 0) ? printf("Query OK, %d rows affected\n", $nrows) : print "Query OK\n";
}
$dbh->disconnect;

if ($nrows == 0) {	# the last one 
	print "No orthology relationships have been established. This is most likely the case if nucleotide data is unavailable for any of the taxa you uploaded peptide sequences for.\n";
	print "Done.\n";
	exit; 
}
else {	# something has changed
}

#--------------------------------------------------
# # Functions follow 
#-------------------------------------------------- 
# Sub: mysql_dbh
# Returns a MySQL database handle
sub mysql_dbh {#{{{
	return DBI->connect("DBI:mysql:$dbname:$dbserver", $username, $pwd);
}#}}}

# Sub: mysql_check
# Check whether the result of a query is present or not, return appropriate
# Arguments: Scalar string QUERY
# Returns: 1 or 0 depending on presence of result
sub mysql_check {#{{{
	my $query = shift;
	unless ($query) { croak "Usage: mysql_check(QUERY)\n"; }
	my @results;
	my $dbh = &mysql_dbh;
	my $sql = $dbh->prepare($query);
	$sql->execute();
	if ($sql->fetchrow_array()) {
		return 1;
	}
	return 0;
}#}}}

# Sub: mysql_get
# Get from the database the result of a SQL query
# Arguments: QUERY as a string literal
# Returns: Reference to array of arrays (result lines->fields)
sub mysql_get {#{{{
	my $query = shift;
	unless ($query) { croak "Usage: mysql_get(QUERY)\n" }
  # prepare anonymous array
	my $results = [ ];
  # connect and fetch stuff
	my $dbh = &mysql_dbh;
	my $sql = $dbh->prepare($query);
	$sql->execute();
	while (my @result = $sql->fetchrow_array() ) {
		push(@$results, \@result);
	}
	$sql->finish();
	$dbh->disconnect; # disconnect ASAP
	return $results;
}#}}}

# drop all tables. no really, all that start with $prefix.
sub drop_tables {#{{{
	my $dbh = &mysql_dbh() or die "Could not connect to MySQL database server: $!\n";
	print 'DROPing tables: ', join(", ", values(%t)), "\n";
	foreach my $table (keys(%t)) {
		$dbh->do("DROP TABLE IF EXISTS $t{$table}") or die "Could not execute drop query: $!\n";
	}
}#}}}


# create tables. makes use of the %create_table hash.
sub create_tables {#{{{
	my $dbh = &mysql_dbh();
	foreach (values %create_table) {
		print $_, ";\n";
		$dbh->do($_) or die "Could not exec query: $!\n";
	}
	$dbh->do($insert_seqtypes);	# start off with 'nt' and 'aa' seqtypes
	$dbh->disconnect;
}#}}}

# Sub: load_taxon
# Loads sequence data into the database.
# Arguments: scalar string filename to nucleotide fasta file, scalar TRUE or FALSE. If TRUE, also:
#		scalar string BLAST directory for creating the BLAST database
# Returns: 1 on success, 0 otherwise
sub load_taxon {#{{{
	my $inf = shift(@_);
	my $mode = shift(@_);
	my $seqtable = $mode ? $t{'aaseqs'} : $t{'ntseqs'};
	my $otherseqtable = $mode ? $t{'ntseqs'} : $t{'aaseqs'};
	my $seqcol = $mode ? 'aa_seq' : 'nt_seq';
	my $otherseqcol = $mode ? 'nt_seq' : 'aa_seq';
	my $type = $mode ? 'nt' : 'aa';
	if ($mode) {
		my $blastdb = shift(@_) or croak("Usage: load_taxon(INFILE, [1|0] [,BLAST_DIR])\n"); 
	}
	my $total_seqs = 0;
	my $diemsg = "Fatal: Sequence header format wrong in line %d. Expected format must be '>TAXSH Identifier foobar'. See documentation for more information\n";

	my $tmpfh = File::Temp->new(UNLINK => 1);
	my $infh = Seqload::Fasta->open($inf);
	while (my ($hdr, $seq) = $infh->next_seq()) {
		my @fields = split(/\s+/, $hdr);
		if (scalar(@fields) < 2) {
			die(sprintf("$diemsg", $.));
		}
		elsif (length($fields[0]) != 5 or $fields[0] !~ /^\w+$/) {
			die(sprintf("$diemsg", $.));
		}
		print $tmpfh "$fields[0],$fields[1],$seq\n";
		++$total_seqs;
	}
	$tmpfh->close();

	# get taxon shorthand
	my $list = &mysql_get("SELECT * FROM $t{'taxa'}");
	print "This is a list of present taxa in the database:\n";
	for (my $i = 0; $i < scalar(@$list); ++$i) {
		printf("%2d. %s %s\n", $$list[$i][0], $$list[$i][1], $$list[$i][2]);
	}
	print "Please enter a number to select one of the taxa (don't fuck with this, no error-catching has been implemented yet): ";
	my $in = <STDIN>;
	chomp $in;
	my $taxon;
	if ($in =~ /^\d+$/) {
		$taxon = $$list[$in-1][0];
	}
	print "Please enter the OGS version for the data you just uploaded: ";
	my $ogsversion = <STDIN>;
	chomp $ogsversion;

	# ok; insert ogs version into database
	my $dbh = &mysql_dbh();
	$dbh->do("INSERT IGNORE INTO $t{'ogs'} (type, taxid, version) VALUES ('$type', '$taxon', '$ogsversion')");
	$dbh->disconnect();

	# queries:
	my @queries = (
		# create the temporary table
		"CREATE TABLE $temptable (
		`id`       INT(11)      NOT NULL PRIMARY KEY AUTO_INCREMENT,
		`taxsh`    CHAR(5)      NOT NULL,
		`header`   VARCHAR(255) NOT NULL,
		`sequence` MEDIUMBLOB)",
		# load data into temp table
		"LOAD DATA LOCAL INFILE '$tmpfh' 
		INTO TABLE $temptable 
		FIELDS TERMINATED BY ',' 
		(taxsh, header, sequence)",
		# insert data into main table. IGNORE is important to avoid duplicates.
		"INSERT IGNORE INTO $seqtable (taxid, header, sequence)
		SELECT $t{'taxa'}.id, $temptable.header, $temptable.sequence 
		FROM $temptable 
		LEFT JOIN $t{'taxa'} 
		ON $temptable.taxsh = $t{'taxa'}.name",
		# insert sequence pairs relationships
		"INSERT INTO $t{'seqpairs'} (taxid, ogs_id, $otherseqcol, $seqcol, date, user) 
		SELECT $t{'taxa'}.id, $t{'ogs'}.id, $otherseqtable.id, $seqtable.id, UNIX_TIMESTAMP(), '$username'
		FROM $t{'taxa'}
		RIGHT JOIN $seqtable
		ON $seqtable.taxid = $t{'taxa'}.id
		LEFT JOIN $t{'ogs'}
		ON $t{'taxa'}.id = $t{'ogs'}.taxid
		LEFT JOIN $otherseqtable
		ON $otherseqtable.header = $seqtable.header
		WHERE $t{'taxa'}.id = $taxon
		ON DUPLICATE KEY UPDATE $t{'seqpairs'}.$seqcol = $seqtable.id,
		$t{'seqpairs'}.$otherseqcol = $otherseqtable.id",
	);
	# execute all queries
	$dbh = &mysql_dbh();
	$dbh->do("DROP TABLE IF EXISTS $temptable") or return 0;
	foreach (@queries) {
		print "$_\n";
		my $nrows = $dbh->do($_) or return 0;
		printf("Query OK, %d rows affected.\n", $nrows);
	}
	$dbh->disconnect();
	my $seqpairs = &mysql_get("SELECT COUNT(*) FROM $t{'seqpairs'} WHERE $t{'seqpairs'}.taxid = $taxon");
	printf "Query OK. Loaded %d new sequences into %s on %s.\n", $$seqpairs[0][0], $dbname, $dbserver;
	return 1;
}#}}}

# Sub: load_peptides
# Loads peptide data into the database and re-generates the BLAST databases
# Arguments: scalar string filename
# Returns: true on success, false otherwise
sub load_peptides {
	my $inf = shift;
}

# Sub: create_blastdb
# Generates a BLAST database 
# Expects: scalar string dirname
# Returns: File::Spec path object for the BLAST database
sub create_blastdb {#{{{
	my $infiles = shift;
	my $taxsh = '';
	if (scalar(@_) > 0) {
		$taxsh = shift;
	}
	else {
		($taxsh = $infile) =~ s/\.(fa|fas|fasta|fsta|fsa)$//;
	}
	if (&check_if_fasta == 0) {
		return 0;
	}
	# TODO
	my $blastdir = &mysql_get("SELECT blastdb_path FROM $t{'blastdbs'} WHERE ");
	my $outfile = File::Spec->catfile($taxsh);
	my @makeblastdbcmd = qq(makeblastdb -in $infile -out $outfile -input_type fasta -title $taxsh);
}#}}}

# Sub: get_setname
# Listens for the set name on STDIN
# Arguments: none
# Returns: scalar string setname
sub get_setname {#{{{
	print "Enter the set name (required; ASCII only): ";
	$setname = <STDIN>;
	chomp $setname;
	if ($setname =~ /[^a-zA-Z0-9_]/) {
		die "Error: Must be alphanumeric (a-z, 0-9, and underscore).\n";
	}
	return $setname;
}#}}}

sub getblastdir {#{{{
	my $bd = &mysql_get("SELECT blastdb_path FROM $t{'blastdbs'} LIMIT 1");
	if (!$bd) {
		print "Enter the location where the BLAST database directories are located (required): ";
		$blastdir = <STDIN>;
		chomp $blastdir;
	}
	else {
		$blastdir = $$bd[0][0];	# array of arrays, only element
	}
	return $blastdir;
}#}}}

# Sub: get_ortholog_sets
# Get list of ortholog sets from the database
# Arguments: none
# Returns: hash reference of set names => description
sub get_ortholog_sets {#{{{
	my %sets = ();
	my $query = "SELECT * FROM $t{'set_details'}";
	my $data = &mysql_get($query);
	foreach my $item (@$data) {
		$sets{$$item[1]} = $$item[2];
	}
	return(\%sets);
}#}}}

#TODO merge with get_ortholog_sets() into one function that accepts a query
# Sub: list_ogs
# Get list of OGS in the database
# Arguments: none
# Returns: array reference (list of OGS)
sub list_ogs {#{{{
	my %ogslist = ();
	my $data = &mysql_get("SELECT DISTINCT $t{'taxa'}.name , $t{'ogs'}.version from $t{'aaseqs'} inner join $t{'seqpairs'} on $t{'aaseqs'}.id  = $t{'seqpairs'}.aa_seq inner join $t{'taxa'} on $t{'seqpairs'}.taxid = $t{'taxa'}.id inner join $t{'ogs'} on $t{'taxa'}.id = $t{'ogs'}.taxid");
	foreach my $item (@$data) {
		$ogslist{$$item[0]} = $$item[1];
	}
	return(\%ogslist);
}#}}}

#{{{ POD: Appendix
=head1 APPENDIX 

=head2 SQL Statement for creating the database structure

-- MySQL dump 10.13  Distrib 5.1.61, for redhat-linux-gnu (x86_64)
--
-- Host: localhost    Database: forage
-- ------------------------------------------------------
-- Server version	5.1.61-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `forage`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `forage` /*!40100 DEFAULT CHARACTER SET latin1 */;

USE `forage`;

--
-- Table structure for table `forage_aaseqs`
--

DROP TABLE IF EXISTS `forage_aaseqs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_aaseqs` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `taxid` int(10) NOT NULL,
  `header` varchar(512) NOT NULL,
  `sequence` mediumblob,
  `user` int(10) unsigned DEFAULT NULL,
  `date` int(11) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `header` (`header`),
  KEY `taxid` (`taxid`)
) ENGINE=MyISAM AUTO_INCREMENT=206817 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_blast`
--

DROP TABLE IF EXISTS `forage_blast`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_blast` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `spec` varchar(255) NOT NULL,
  `blastdb_path` varchar(255) NOT NULL,
  `query` varchar(255) NOT NULL,
  `target` varchar(255) NOT NULL,
  `score` float NOT NULL,
  `evalue` float NOT NULL,
  UNIQUE KEY `query_2` (`query`,`target`),
  KEY `id` (`id`),
  KEY `spec` (`spec`),
  KEY `query` (`query`),
  KEY `target` (`target`)
) ENGINE=MyISAM AUTO_INCREMENT=9713 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_blastdbs`
--

DROP TABLE IF EXISTS `forage_blastdbs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_blastdbs` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `setid` int(10) unsigned DEFAULT NULL,
  `blastdb_path` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `setid` (`setid`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_blastp`
--

DROP TABLE IF EXISTS `forage_blastp`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_blastp` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `spec` varchar(255) NOT NULL,
  `blastdb_path` varchar(255) NOT NULL,
  `query` varchar(255) NOT NULL,
  `target` varchar(255) NOT NULL,
  `score` float NOT NULL,
  `evalue` float NOT NULL,
  UNIQUE KEY `query_2` (`query`,`target`),
  KEY `id` (`id`),
  KEY `spec` (`spec`),
  KEY `query` (`query`),
  KEY `target` (`target`)
) ENGINE=MyISAM AUTO_INCREMENT=1403 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_ests`
--

DROP TABLE IF EXISTS `forage_ests`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_ests` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `digest` char(32) NOT NULL,
  `spec` varchar(255) NOT NULL,
  `date` int(11) unsigned DEFAULT NULL,
  `header` varchar(255) NOT NULL,
  `sequence` mediumblob,
  KEY `id` (`id`),
  KEY `digest` (`digest`),
  KEY `spec` (`spec`),
  KEY `header` (`header`)
) ENGINE=MyISAM AUTO_INCREMENT=630001 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_hmmsearch`
--

DROP TABLE IF EXISTS `forage_hmmsearch`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_hmmsearch` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `spec` varchar(255) NOT NULL,
  `query` varchar(255) NOT NULL,
  `target` varchar(255) NOT NULL,
  `score` float NOT NULL,
  `evalue` float NOT NULL,
  UNIQUE KEY `query_2` (`query`,`target`),
  KEY `id` (`id`),
  KEY `spec` (`spec`),
  KEY `query` (`query`),
  KEY `target` (`target`)
) ENGINE=MyISAM AUTO_INCREMENT=7405 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_ntseqs`
--

DROP TABLE IF EXISTS `forage_ntseqs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_ntseqs` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `taxid` int(10) NOT NULL,
  `header` varchar(512) NOT NULL,
  `sequence` mediumblob,
  `user` int(10) unsigned DEFAULT NULL,
  `date` int(11) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `header` (`header`),
  KEY `taxid` (`taxid`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_ogs`
--

DROP TABLE IF EXISTS `forage_ogs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_ogs` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `type` char(3) DEFAULT NULL,
  `taxid` int(10) unsigned DEFAULT NULL,
  `version` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `taxid` (`taxid`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_orthologs`
--

DROP TABLE IF EXISTS `forage_orthologs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_orthologs` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `setid` int(10) unsigned NOT NULL,
  `ortholog_gene_id` varchar(10) NOT NULL,
  `sequence_pair` int(10) unsigned NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `setid` (`setid`,`ortholog_gene_id`,`sequence_pair`)
) ENGINE=MyISAM AUTO_INCREMENT=6853 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_seqtypes`
--

DROP TABLE IF EXISTS `forage_seqtypes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_seqtypes` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `type` char(3) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `type` (`type`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_sequence_pairs`
--

DROP TABLE IF EXISTS `forage_sequence_pairs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_sequence_pairs` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `taxid` int(10) unsigned NOT NULL,
  `ogs_id` int(10) unsigned NOT NULL,
  `aa_seq` int(10) unsigned NOT NULL,
  `nt_seq` int(10) unsigned DEFAULT NULL,
  `date` int(11) unsigned DEFAULT NULL,
  `user` int(10) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `aa_seq_2` (`aa_seq`),
  KEY `aa_seq` (`aa_seq`),
  KEY `nt_seq` (`nt_seq`)
) ENGINE=MyISAM AUTO_INCREMENT=206816 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_set_details`
--

DROP TABLE IF EXISTS `forage_set_details`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_set_details` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `description` blob,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_taxa`
--

DROP TABLE IF EXISTS `forage_taxa`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_taxa` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) DEFAULT NULL,
  `longname` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `forage_users`
--

DROP TABLE IF EXISTS `forage_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `forage_users` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

=cut

=pod

=head1 AUTHOR

Written by Malte Petersen <mptrsen@uni-bonn.de>

=head1 COPYRIGHT

Copyright (C) 2012 Malte Petersen 

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
=cut#}}}
