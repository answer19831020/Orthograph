#!/usr/bin/env perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2014 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write clean code
use warnings;       # cry if something seems odd
use autodie;        # die automatically on I/O functions

# Core modules
use Carp;           # carp and croak: warn and die with call stack
use File::Temp;     # temporary files
use File::Path qw( remove_tree make_path );	# this also uses File::Spec
use FindBin;        # locate the dir of this script during compile time
use Getopt::Long;   # parse command line arguments
use Data::Dumper;   # good for debugging

# Custom modules
use lib $FindBin::Bin;                   # $Bin is the directory of the original script
use Seqload::Fasta qw( check_if_fasta ); # object-oriented access to fasta files
use Orthograph::Functions;               # functions for all Orthograph tools
use Orthograph::Config;                  # configuration in global hashref $config

#--------------------------------------------------
# # Copy configuration
#-------------------------------------------------- 
my $config = $Orthograph::Config::config;

#--------------------------------------------------
# # The user only wants help
#-------------------------------------------------- 
if ($config->{'help'}) {
	Orthograph::Functions::print_usage($config) and exit;
}


#--------------------------------------------------
# # These variables can be set in the config file
#-------------------------------------------------- 

my $database_backend          = $config->{'database-backend'};
my $db_dbname                 = $config->{'mysql-database'};
my $db_dbpwd                  = $config->{'mysql-password'};
my $db_dbserver               = $config->{'mysql-server'};
my $db_dbuser                 = $config->{'mysql-username'};
my $db_prefix                 = $config->{'db-prefix'};
my $db_table_aaseqs           = $config->{'db_table_aaseqs'};
my $db_table_blast            = $config->{'db_table_blast'};
my $db_table_blastdbs         = $config->{'db_table_blastdbs'};
my $db_table_ests             = $config->{'db_table_ests'};
my $db_table_hmmsearch        = $config->{'db_table_hmmsearch'};
my $db_table_log_evalues      = $config->{'db_table_log_evalues'};
my $db_table_scores           = $config->{'db_table_scores'};
my $db_table_ntseqs           = $config->{'db_table_ntseqs'};
my $db_table_ogs              = $config->{'db_table_ogs'};
my $db_table_orthologs        = $config->{'db_table_orthologs'};
my $db_table_seqpairs         = $config->{'db_table_sequence_pairs'};
my $db_table_seqtypes         = $config->{'db_table_sequence_types'};
my $db_table_set_details      = $config->{'db_table_set_details'};
my $db_table_taxa             = $config->{'db_table_taxa'};
my $db_table_temp             = $config->{'db_table_temp'};

# Actions
my $create                    = $config->{'create'};
my $delete_all                = $config->{'destroy'};
my $delete_ogs                = $config->{'delete-ogs'};
my $delete_set                = $config->{'delete-set'};
my $listtaxa                  = $config->{'list-taxa'};
my $listsets                  = $config->{'list-sets'};
my $listogs                   = $config->{'list-ogs'};
my $isnucleotide              = $config->{'load-ogs-nucleotide'};
my $ispeptide                 = $config->{'load-ogs-peptide'};
my $overwrite                 = $config->{'overwrite'};

# other variables
my $verbose                   = $config->{'verbose'};
my $outputdir                 = $config->{'output-directory'};
my $reference_taxon_shorthand = $config->{'reference-taxon-shorthand'};
my $ogsversion                = $config->{'ogs-version'};
my $taxon_name                = $config->{'ogs-taxon-name'};
my $orthodb5_format           = $config->{'orthodb5-format'};

# substitution character for selenocysteine, which normally leads to blast freaking out
my $u_subst                   = $config->{'substitute-u-with'};

# which database backend do we use?
my $use_mysql       = $database_backend =~ /mysql/i  ? 1 : 0;
my $use_sqlite      = $database_backend =~ /sqlite/i ? 1 : 0;
my $database        = undef;

# load the database modules at runtime, depending on the backend setting
if ($use_mysql)     {
	require Wrapper::Mysql;
	$database = $config->{'mysql-database'};
}
elsif ($use_sqlite) {
	require Wrapper::Sqlite;
	$database = $config->{'sqlite-database'};
}

# table names. too lazy to change all of them, so i'll just reuse the old hash structure
my $t            = {
	'aaseqs'       => $db_table_aaseqs,
	'blastdbs'     => $db_table_blastdbs,
	'ntseqs'       => $db_table_ntseqs,
	'ogs'          => $db_table_ogs,
	'orthologs'    => $db_table_orthologs,
	'seqpairs'     => $db_table_seqpairs,
	'seqtypes'     => $db_table_seqtypes,
	'set_details'  => $db_table_set_details,
	'taxa'         => $db_table_taxa,
	'temp'         => $db_table_temp,
};

my $blastdir          = '';
my $description       = '';
my $listests          = 0;
my $name              = '';
my $ogs_name          = '';
my $reassignorthologs = 0;
my $setdir            = '';
my $setname           = '';
my $sql               = '';
my $temptable         = $db_table_temp;
my $total_seqs        = 0;
my %names             = ( );

my $infile = '';

unless (defined $db_dbuser and defined $db_dbpwd ) {
	die "Fatal: You must specify database username (--mysql-username) and password (--mysql-password).\n";
}

# name == username unless defined name
$name = $db_dbuser unless defined($name);

#--------------------------------------------------
# # if you really want to delete everything...
#-------------------------------------------------- 
if ($delete_all) {
	print "This will erase your Orthograph database structure. Are you sure (y/n)? ";
	get_yn() or exit;
	print "OK, whatever you say.\n";
	drop_tables();
	print "OK.\n";
	exit;
}
#--------------------------------------------------
# # if you only want me to create the tables, fine. this will give you a clean slate.
#-------------------------------------------------- 
elsif ($create) {
	print "This will create a new Orthograph table structure in the database '$database' with the table prefix '$db_prefix'.\nAny existing Orthograph table structures with that prefix will be erased. Are you sure (y/n)? ";
	get_yn() or exit;
	unless (-e $outputdir) {
		die "Fatal: output directory $outputdir specified, but does not exist\n";
	}
	drop_tables();
	create_tables();
	print "Created Orthograph table structure in database '$database'.\n";
	if ($use_sqlite) {
		if (-z Wrapper::Sqlite::attached_db_file()) {
			unlink Wrapper::Sqlite::attached_db_file();
		}
		else {
			print "Did not delete species database '" . Wrapper::Sqlite::attached_db_file() . "'  as it is not empty\n";
		}
	}
	exit;
}

elsif ($delete_set) { 
	delete_set($delete_set);
	print "OK, removed orthology relationships for set '$delete_set' completely. No sequences were deleted from database.\n";
	exit;
}
elsif ($delete_ogs) {
	print "Deleting OGS sequences from $delete_ogs. Are you sure (y/n)? ";
	get_yn() or exit;
	my $c = delete_ogs($delete_ogs);
	print "OK, removed $c sequences for OGS '$delete_ogs' from the database.\n";
	exit;
}

#--------------------------------------------------
# Just list the present ortholog sets, then exit
# TODO make this less redundant!
#-------------------------------------------------- 
if ($listsets) {
	list_sets() and exit;
}

elsif ($listogs) {
	print_ogs_list() and exit;
}

elsif ($listtaxa) {
	list_set_details() and exit;
}

elsif ($isnucleotide) {
	$infile = $isnucleotide;
	# 1 for nucleotide
	upload_ogs($infile, 1) or fail_and_exit("Nucleotide loading failed");
	exit;
}
elsif ($ispeptide) {
	$infile = $ispeptide;
	# 2 for amino-acid
	upload_ogs($infile, 2) or fail_and_exit("Peptide loading failed");
	exit;
}

# otherwise, this must be an orthodb file
$infile = shift @ARGV or Orthograph::Functions::print_usage($config) and exit 1;
die("Fatal: file not found: $infile\n") unless -f $infile;

#--------------------------------------------------
# # continue and gather information
#-------------------------------------------------- 

# TODO stop here if db structure is not present!
if (!db_structure_present()) {
	fail_and_exit('Orthograph database structure not present! Did you forget to run `orthograph-manager -create`?');
}

print "Setting up core ortholog set from '$infile' in database '$database' on host '$db_dbserver'... (press CTRL+C to abort)\n";

if (!$setname) { $setname = get_setname() }

# TODO rewrite this part using parametrized queries to protect from SQL injections?
if (set_exists($setname)) {
	warn "Warning: An ortholog set with this name already exists in $db_dbname on $db_dbserver.\n";
	unless ($overwrite) {
		print "Pick a different name or use -o for overwriting.\n";
		exit;
	}
	print "Overwriting existing entries (may cause data disintegration). Are you sure (y/n)? ";
	get_yn() or print "OK, exiting\n" and exit;
}

$description = get_answer("\nEnter a description for the set (optional but recommended). IMPORTANT: Do not use any commas (,)");
unless ($description) { print "Caught EOF. Exiting.\n" and exit }
chomp $description;

unless (defined $setname) {
	print "Fatal: You must specify the core-ortholog set name (-s).\n";
	exit;
}

#--------------------------------------------------
# # read the input file and create a CSV file with everything we know 
#-------------------------------------------------- 

# read the input file and associate the taxon shorthands to existing OGS
my $ogsid_for = get_all_ogsids($infile);
exit;

my $tmpfile = make_csv($infile);

load_temp_table_with_data($tmpfile);

my $nrows = fill_tables_from_temp_table($t);


#--------------------------------------------------
# # temptable is now complete. going to insert the data into the main table 
#-------------------------------------------------- 
# TODO check whether the proteome header format is right (protein id only)!
# TODO import the proteome data via a second temptable
# TODO rewrite this part using parametrized queries to protect from SQL injections?

if ($nrows == 0) {	# the last one 
	print "No new orthology relationships have been established. This is most likely the case if nucleotide data is unavailable for any of the taxa you uploaded peptide sequences for or you overwrote existing data.\n";
	print "Done.\n";
	exit; 
}
else {	# something has changed
	my $n_cogs = get_number_of_cogs_for_set($setname);
	printf("Successfully loaded ortholog set %s (%d orthologous groups, %d new sequences) into database.\n", $setname, $n_cogs, $nrows);
	exit;
}

#--------------------------------------------------
# # Functions follow 
#-------------------------------------------------- 

sub get_number_of_cogs_for_set {
	my $setn = shift @_;
	if ($use_mysql) {
		return Wrapper::Mysql::get_number_of_cogs_for_set($setn);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_number_of_cogs_for_set($setn);
	}
}

sub fill_tables_from_temp_table {
	if ($use_mysql) {
		Wrapper::Mysql::fill_tables_from_temp_table($t, $temptable);
	}
	elsif ($use_sqlite) {
		Wrapper::Sqlite::fill_tables_from_temp_table($t, $temptable);
	}
}
#--------------------------------------------------
# # create a temporary table for high-speed loading of the data. we can sort it out later.
#-------------------------------------------------- 

sub load_temp_table_with_data {
	my $csvfile = shift @_;

	if ($use_mysql) {
		Wrapper::Mysql::create_temp_table($temptable);
		Wrapper::Mysql::load_csv_into_temptable($csvfile, $temptable);
	}
	elsif ($use_sqlite) {
		Wrapper::Sqlite::create_temp_table($temptable);
		Wrapper::Sqlite::load_csv_into_temptable($csvfile, $temptable);
	}

	print "Successfully loaded $total_seqs sequences from $infile into database.\n";

	# get name and longname from the temp table; they do not get updated automatically
	my $dbh = get_dbh();
	$sql = $dbh->prepare("SELECT DISTINCT name, longname FROM $temptable");
	$sql->execute();
	while (my @result = $sql->fetchrow) {
		$names{$result[0]} = '';
	}
	$dbh->disconnect;

	# ask the user for the taxon names that aren't complete
	foreach (sort(keys %names)) {
		unless ($names{$_}) {
			$names{$_} = get_answer("Enter complete name for the shorthand '$_' (no commas!)");
		}
	}

	# update the temptable with the collected info
	$dbh = get_dbh();
	foreach (keys %names) {
		$sql = $dbh->prepare("UPDATE $temptable SET longname='$names{$_}' WHERE name='$_'");
		$sql->execute();
	}
	$dbh->disconnect;
}

sub get_dbh {
	if ($use_mysql) {
		my $dbh = Wrapper::Mysql::get_dbh() or fail_and_exit('Couldn not get a database connection');
		return $dbh;
	}
	elsif ($use_sqlite) {
		my $dbh = Wrapper::Sqlite::get_dbh() or fail_and_exit('Could not get a database connection');
		return $dbh;
	}
}

sub fail_and_exit {
	my $msg = shift @_;
	print STDERR 'Fatal: ' . $msg . "\n";
	exit 1;
}

sub set_exists {
	my $setname = shift;
	if ($use_mysql) {
		my $query = "SELECT name FROM $t->{'set_details'} WHERE name = '$setname'";
		return Wrapper::Mysql::check($query)
	}
	elsif ($use_sqlite) {
		my $query = "SELECT name FROM $t->{'set_details'} WHERE name = '$setname'";
		return Wrapper::Sqlite::check($query)
	}
}


# drop all tables. no really, all that start with $prefix.
sub drop_tables {
	if ($use_mysql) {
		Wrapper::Mysql::drop_tables($t);
	}
	elsif ($use_sqlite) {
		Wrapper::Sqlite::drop_tables($t);
	}
}


# create tables. makes use of the %create_table hash.
sub create_tables {
	if ($use_mysql) {
		Wrapper::Mysql::create_tables($t);
	}
	elsif ($use_sqlite) {
		Wrapper::Sqlite::create_tables($t);
	}
}

# sub: make_csv
# generate a csv file from the ortholog set fasta file
sub make_csv {
	my $inf = shift @_;
	my $fh = File::Temp->new(UNLINK=>1);
	my $faobj = Seqload::Fasta->open($inf);

	my $taxon_shorthand = '';
	my $orthodb_id      = '';
	my $sequence_id     = '';

	no warnings;	# disable warnings for printing of the NULL column
	while (my ($hdr, $seq) = $faobj->next_seq()) {
		$seq =~ s/-//g;	# remove all gaps from the sequence
		# does the sequence consist of only amino acid symbols?
		if ($seq =~ /([^ACDEFGHIKLMNPQRSTVWYX*])/) {
			# change all Us to X if requested
			if ($u_subst and $seq =~ s/U/$u_subst/gi) {
				warn("Warning: Selenocysteine character ('U') replaced with '$u_subst' in sequence '$hdr'.\n");
			}
			else {
				warn("Warning: Sequence $hdr contains nonstandard amino acid symbol '$1'! Make sure your alignment program tolerates this.\n");
			}
		}
		++$total_seqs;
		# no commas in the header please, they confuse the csv parser
		$hdr =~ s/,/_/g;
		my @headerfields = split(/\s+/, $hdr);
		# for backwards compatibility with orthodb 5 format
		if ($orthodb5_format) {
			$taxon_shorthand = $headerfields[0];
			$orthodb_id      = $headerfields[2];
			$sequence_id     = $headerfields[3];
			# only the first 5 characters
			$taxon_shorthand = substr($taxon_shorthand, 0, 5);
		}
		# otherwise, this is recent, i.e., orthodb 7 format
		else {
			$taxon_shorthand = $headerfields[-1];
			$orthodb_id      = $headerfields[-2];
			$sequence_id     = $headerfields[0];
		}

		printf $fh "%s,%s,%s,%s,%s,%s,%s,%s\n", 
			$taxon_shorthand,              # taxon shorthand
			'',                            # this will later be the full name
			$setname,	                     # set name
			$orthodb_id,                   # orthodb id, e.g. EOG500001
			File::Spec->catdir($blastdir), # blast database directory
			$sequence_id,                  # sequence id as it occurs in the ogs
			$seq,                          # sequence
			$description;                  # set description
	}
	use warnings;	# resume yelling 
	undef $faobj;
	$fh->close();
	print "used temporary csv file '$fh'\n" if $verbose;
	return $fh;
}

# sub: get_yn
# Get a response of the type 'y' or 'n'. Prompts the user until she complies :D
# returns 1 on 'y', 0 on 'n'
sub get_yn {
	local $| = 0;
	my $yn = readline(STDIN);
	chomp $yn;
	until ($yn =~ /^[yn]$/) {
		print "Response '$yn' not understood. Are you sure (y/n)? ";
		$yn = readline(STDIN);
		chomp $yn;
	}
	$| = 1;
	if ($yn eq 'n') {
		return 0;
	}
	return 1;
}

sub upload_ogs {
	my $inf = shift;
	my $type = shift;
	
	# get taxon name
	if ($taxon_name) {
		print "Using taxon name '$taxon_name'\n";
	}
	else {
		$taxon_name = get_answer("Please enter the taxon name for this data file");
	}
	# get ogs version
	if ($ogsversion) {
		print "Using OGS version number $ogsversion\n";
	}
	else {
		$ogsversion = get_answer("Please enter the official gene set (OGS) version for this data file");
	}

	# insert taxon into table
	my $taxid = insert_taxon_into_database($taxon_name) or fail_and_exit('Could not insert taxon into database');

	# update OGS table
	my $ogsid = insert_ogs_info_into_database($type, $taxid, $ogsversion) or fail_and_exit('Could not insert OGS info into database');
	print "Got OGS ID $ogsid and taxon ID $taxid for $taxon_name\n" if $verbose;

	# generate a csv file and get a list of headers
	my ($csvf, $hdrs) = make_csv_for_ogs_uploading($inf, $taxid, $type, $ogsid);

	# upload:
	# create temporary table
	create_temptable_for_ogs_data();
	# upload from temporary table
	upload_ogs_sequences($csvf, $hdrs, $taxid, $type, $ogsid) or fail_and_exit('OGS sequence loading failed');

	my $n_seqpairs = get_sequence_count_for_taxon($taxid);
	printf("\n%d sequences for '%s' in database '%s' on %s.\n", $n_seqpairs, $taxon_name, $database, $db_dbserver);
	exit;
}

sub make_csv_for_ogs_uploading {
	my $inf   = shift;
	my $taxid = shift;
	my $type  = shift;
	my $ogsid = shift;
	my $hdrs  = [ ];
	my $tmpfh = File::Temp->new();
	my $fafh  = Seqload::Fasta->open($inf);
	while (my ($hdr, $seq) = $fafh->next_seq()) {
		$hdr =~ s/,/_/g; # remove commas from the header as they confuse the csv parser
		$seq =~ s/-//g;	# remove all gaps from the sequence
		# check if the sequence consists of valid characters
		if ($type == 2) {
			if ($seq =~ /([^ACDEFGHIKLMNPQRSTVWYX*])/) {
				# change all Us to X if requested
				if ($u_subst and $seq =~ s/U/$u_subst/gi) {
					warn("Warning: Selenocysteine character ('U') replaced with '$u_subst' in sequence '$hdr'.\n");
				}
				else {
					warn("Warning: Sequence $hdr contains nonstandard amino acid symbol '$1'! Make sure your alignment program tolerates this.\n");
				}
			}
		}
		else {
			if ($seq =~ /([^ATCGN*])/i) {
				warn("Warning: Sequence $hdr contains nonstandard nucleic acid symbol '$1'!\n");
			}
		}
		# write to csv file
		printf $tmpfh "%d,%d,%d,%s,%s\n",
			$taxid,
			$type,
			$ogsid,
			$hdr,
			$seq,
		;
		# add to list of headers
		push @$hdrs, $hdr;
	}
	$tmpfh->close();

	return ($tmpfh, $hdrs);
}


sub insert_taxon_into_database {
	my $name = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::insert_taxon_into_database($name, 1);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::insert_taxon_into_database($name, 1);
	}
}

sub insert_ogs_info_into_database {
	if ($use_mysql) {
		return Wrapper::Mysql::insert_ogs_info_into_database(@_);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::insert_ogs_info_into_database(@_);
	}
}


sub upload_ogs_sequences {
	if ($use_mysql) {
		return Wrapper::Mysql::upload_ogs_sequences(@_);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::upload_ogs_sequences(@_);
	}
}

sub get_answer {
	my $prompt = shift;
	print "$prompt: ";
	my $ans    = <STDIN>;
	chomp $ans;
	return $ans;
}

sub get_all_ogsids {
	my $inf = shift;
	my $seen = { };
	my @fields = ( );
	open my $fh, '<', $inf;
	while (my $line = <$fh>) {
		# skip the first line if it is some orthodb file
		if ($line =~ /^Group\tGene\tProtein/) { next }
		@fields = split "\t", $line;
		next if exists $seen->{$fields[5]};
		$seen->{$fields[5]} = 0;
	}
	$seen = assign_ogsids_to_taxa($seen);
	return $seen;
}

sub assign_ogsids_to_taxa {
	my $ogsid_for = shift;
	my $list_of_ogs = get_list_of_ogs();
	print "\n";
	print_ogs_list();
	print "\n";
	foreach (sort { $a cmp $b } keys %$ogsid_for) {
		$ogsid_for->{$_} = get_ogsid($list_of_ogs, $_, $ogsid_for)
	}
	return $ogsid_for;
}

sub print_ogs_list {
	my $list_of_ogs = get_list_of_ogs();
	my $len = 0;
	foreach (@$list_of_ogs) {
		if (length $_->[1] > $len) { $len = length $_->[1] };
	}
	print "This is a list of present OGS in the database:\n";
	printf "[%s] %-${len}s  %7s  %s\n", '#', 'Taxon name', 'version', 'sequences';
	printf "%s%-${len}s%s\n", '-' x (length(scalar @$list_of_ogs) + 2), '-' x $len,   '---------------------';
	foreach (@$list_of_ogs) {
		printf "[%d] %-${len}s  %-7s  %d\n", $_->[0], $_->[1], $_->[2], $_->[3];
	}
	return 1;
}

sub get_ogsid {
	my $list_of_ogs = shift;
	my $taxon = shift;
	my $ogsid_for = shift;
	my $prompt = "Enter the OGS ID for $taxon or 0 if you don't want to use this OGS";
	my $id = get_integer($prompt);
	my $ok = 0;
	while (!$ok) {
		# 0 is ok, don't use this ogs
		if ($id == 0) {
			return $id;
		}
		# ogs id doesn't even exist
		if (not grep {$_->[0] == $id} @$list_of_ogs) {
			print "Invalid OGS ID $id. ";
			$id = get_integer($prompt);
		}
		# ogs id has been assigned previously
		elsif (grep { $ogsid_for->{$_} == $id } keys %$ogsid_for) {
			print "OGS ID $id already taken. ";
			$id = get_integer($prompt);
		}
		# ok
		else {
			$ok = 1;
		}
	}
	return $id;
}

sub get_integer {
	my $prompt = shift;
	my $ans = get_answer($prompt);
	while ($ans !~ /^\d+$/) {
		print "Not a valid number. ";
		$ans = get_answer($prompt);
	}
	return $ans;
}


# Sub: load_taxon
# Loads sequence data into the database.
# Arguments: scalar string filename to nucleotide fasta file, scalar TRUE or FALSE. If TRUE, also:
#		scalar string BLAST directory for creating the BLAST database
# Returns: 1 on success, 0 otherwise
sub load_taxon {
	croak("Usage: load_taxon(INFILE, [1|0] [,BLAST_DIR])\n") unless scalar @_ == 2;
	my $inf = shift(@_);
	my $mode = shift(@_);
	# make sure the file exists
	unless (-f $inf) {
		print "File not found: '$inf'\n";
		return 0;
	}
	# the two sequence tables are 'aaseqs' and 'ntseqs'
	# $seqtable and $otherseqtable assume opposing values, respectively,
	# depending on the mode in which the function is called.
	# the same goes for the columns $seqcol and $otherseqcol.
	my $seqtable      = $mode ? $t->{'aaseqs'} : $t->{'ntseqs'};
	my $otherseqtable = $mode ? $t->{'ntseqs'} : $t->{'aaseqs'};
	my $seqcol        = $mode ? 'aa_seq'       : 'nt_seq';
	my $otherseqcol   = $mode ? 'nt_seq'       : 'aa_seq';
	my $type          = $mode ? 2              : 1;  # 1 is 'nt', 2 is 'aa'
	my $hdrs          = [ ];
	my $reference_taxon_id;
	my $reference_taxon_name;

	# get taxon shorthand
	my $list = get_taxon_shorthands();

	# report input file
	print "Using input file $inf\n";

	# the user provided a reference taxon name
	if ($reference_taxon_shorthand) {
		$reference_taxon_id = get_reftaxon_id($reference_taxon_shorthand) or fail_and_exit("Reference taxon '$reference_taxon_shorthand' not found in database");
		print "Using reference taxon $reference_taxon_shorthand (id $reference_taxon_id)\n";
	}
	else {
		print "This is a list of present taxa in the database:\n";
		for (my $i = 0; $i < scalar(@$list); ++$i) {
			printf("%2d. %s %s\n", $i+1, $$list[$i][1], $$list[$i][2]);
		}
		my $in = get_answer("Please enter a number to select one of the taxa (don't fuck with this, no error-catching has been implemented yet)");

		# make sure the user doesn't fuck up
		while (($in !~ /^\d+$/) or ($in > scalar(@$list)) or ($in < 1) or !defined($in)) {
			$in = get_answer("Not understood: '$in'. DO NOT FUCK WITH THIS. Enter one of the numbers to select one of the taxa");
		}
		# correlate that number to the list of taxa
		$reference_taxon_id = $$list[$in-1][0];
		$reference_taxon_name = $$list[$in-1][1];
		printf("You picked %d: %s (%s).\n", $reference_taxon_id, $$list[$in-1][2], $reference_taxon_name);
	}

	if ($ogsversion) {
		print "Using OGS version number $ogsversion\n";
	}
	else {
		$ogsversion = get_answer("Please enter the official gene set (OGS) version for this data file");
	}

	# create a csv file for rapid uploading into the database
	my $tmpfh = File::Temp->new(UNLINK => 1);
	my $infh = Seqload::Fasta->open($inf);
	while (my ($hdr, $seq) = $infh->next_seq()) {
		$hdr =~ s/,/_/g; # remove commas from the header as they confuse the csv parser
		$seq =~ s/-//g;	# remove all gaps from the sequence

		# check if the sequence consists of valid characters
		if ($mode) {
			if ($seq =~ /([^ACDEFGHIKLMNPQRSTVWYX*])/) {
				# change all Us to X if requested
				if ($u_subst and $seq =~ s/U/$u_subst/gi) {
					warn("Warning: Selenocysteine character ('U') replaced with '$u_subst' in sequence '$hdr'.\n");
				}
				else {
					warn("Warning: Sequence $hdr contains nonstandard amino acid symbol '$1'! Make sure your alignment program tolerates this.\n");
				}
			}
		}
		else {
			if ($seq =~ /([^ATCGN*])/i) {
				warn("Warning: Sequence $hdr contains nonstandard nucleic acid symbol '$1'!\n");
			}
		}

		# everything seems ok, write to csv file
		printf $tmpfh "%d,%s,%s\n", $reference_taxon_id, $hdr, $seq;
		# add to list of headers
		push @$hdrs, $hdr;
	}
	$tmpfh->close();

	print "Data look OK, uploading...\n";

	create_temptable_for_ogs_data();
	import_ogs_into_database($tmpfh, $hdrs, $seqtable, $otherseqtable, $seqcol, $otherseqcol, $type, $reference_taxon_id, $ogsversion) or fail_and_exit('Failed to import OGS into database');
	my $n_seqpairs = get_sequence_count_for_taxon($reference_taxon_id);

	printf("\n%d sequences for %s in database %s on %s.\n", $n_seqpairs, $reference_taxon_shorthand, $database, $db_dbserver);
	return 1;
}

sub get_reftaxon_id {
	my $shorthand = shift @_;
	if ($use_mysql) {
		return Wrapper::Mysql::get_reftaxon_id($shorthand);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_reftaxon_id($shorthand);
	}
}

sub get_taxon_shorthands {
	if ($use_mysql) {
		return Wrapper::Mysql::get_taxon_shorthands();
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_taxon_shorthands();
	}
}

sub create_temptable_for_ogs_data {
	if ($use_mysql) {
		return Wrapper::Mysql::create_temptable_for_ogs_data();
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::create_temptable_for_ogs_data();
	}
}

sub import_ogs_into_database {
	if ($use_mysql) {
		return Wrapper::Mysql::import_ogs_into_database(@_);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::import_ogs_into_database(@_);
	}
}

sub get_sequence_count_for_taxon {
	if ($use_mysql) {
		return Wrapper::Mysql::get_sequence_count_for_taxon(@_);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_sequence_count_for_taxon(@_);
	}
}

# Sub: create_blastdb
# Generates a BLAST database 
# Expects: scalar string dirname
# Returns: File::Spec path object for the BLAST database
sub create_blastdb {
	my $infiles = shift;
	my $taxsh = '';
	if (scalar(@_) > 0) {
		$taxsh = shift;
	}
	else {
		($taxsh = $infile) =~ s/\.(fa|fas|fasta|fsta|fsa)$//;
	}
	if (check_if_fasta() == 0) {
		return 0;
	}
	# TODO rewrite this part using parametrized queries to protect from SQL injections?
	# TODO make this work
	my $blastdir = Wrapper::Mysql::mysql_get("SELECT blastdb_path FROM $t->{'blastdbs'} WHERE  = ");
	my $outfile = File::Spec->catfile($taxsh);
	my @makeblastdbcmd = qq(makeblastdb -in $infile -out $outfile -input_type fasta -title $taxsh);
}

# Sub: get_setname
# Listens for the set name on STDIN
# Arguments: none
# Returns: scalar string setname
sub get_setname {
	$setname = get_answer("\nEnter the set name (required; ASCII only, no commas!)");
	unless ($setname) { print "Exiting.\n" and exit }
	if ($setname =~ /[^a-zA-Z0-9_]/) {
		die "Error: Must be alphanumeric (a-z, 0-9, and underscore).\n";
	}
	return $setname;
}

sub getblastdir {
	# TODO rewrite this part using parametrized queries to protect from SQL injections?
	my $bd = Wrapper::Mysql::mysql_get("SELECT blastdb_path FROM $t->{'blastdbs'} LIMIT 1");
	if (!$bd) {
		$blastdir = get_answer("Enter the location where the BLAST database directories are located (required)");
	}
	else {
		$blastdir = $$bd[0][0];	# array of arrays, only element
	}
	return $blastdir;
}


sub list_sets {
	my $maxlen_set  = 0;
	my $maxlen_desc = 0;
	my $sets = get_ortholog_sets();
	if (not $sets) {
		print "No sets in database.\n";
		return 1;
	}
	# determine maximum length of set names for the table
	foreach (keys(%$sets)) {
		$maxlen_set = length($_) if (length($_) > $maxlen_set);
		$maxlen_desc = length($$sets{$_}) if (length($$sets{$_}) > $maxlen_desc);
	}
	print "The following ortholog sets are presently installed:\n";
	printf("%-${maxlen_set}s   %-${maxlen_desc}s\n", 'Set name', 'description');
	printf("%-${maxlen_set}s---%-${maxlen_desc}s\n", '-' x $maxlen_set, '-' x $maxlen_desc);
	foreach (sort keys(%$sets)) {
		printf("%-${maxlen_set}s   %s\n", $_, $$sets{$_});
	}
	return 1;
}


sub list_set_details {
	my %reftaxa_of = get_taxa_in_all_sets();
	my $maxlen_setname  = 0;
	foreach my $setname (keys %reftaxa_of) {
		$maxlen_setname = length($setname) if (length($setname) > $maxlen_setname);
	}
	printf "%-${maxlen_setname}s  %s\n", 'Set name', 'reference taxa';
	printf "%-${maxlen_setname}s--%s\n", '-' x 11, '-' x 14;
	foreach my $setname (sort keys %reftaxa_of) {
		printf("%-${maxlen_setname}s  %s\n", $setname, $reftaxa_of{$setname});
	}
	return 1;
}

# Sub: delete_set
# Delete a set from the database
# Arguments: scalar string setname
# Returns: true if successful, false otherwise
sub delete_set {
	my $setname = shift or confess('Usage: delete_set($SETNAME)');
	my $this_set_dir = File::Spec->catdir($setdir, $setname);
	# TODO rewrite this part using parametrized queries to protect from SQL injections?
	my $data = Wrapper::Mysql::mysql_get("SELECT * FROM $t->{'set_details'} WHERE name = '$setname'");
	if (scalar @{$data} > 1) { die("Oops: Set name not unique. Double-check your database setup!\n") }
	elsif (scalar @{$data} == 0) { die("Oops: Set '$setname' does not exist in the database!\n") }
	my $setid = $$data[0][0];
	my @queries = (
		"DELETE FROM $t->{'set_details'} WHERE $t->{'set_details'}.`id`  = '$setid'",
		"DELETE FROM $t->{'orthologs'}   WHERE $t->{'orthologs'}.`setid` = '$setid'",
		"DELETE FROM $t->{'blastdbs'}    WHERE $t->{'blastdbs'}.`setid`  = '$setid'",
	);
	
	my $dbh = get_dbh();
	foreach (@queries) {
		print $_, "\n";
		$dbh->do($_) or die();
	}
	$dbh->disconnect();

	if (-e $this_set_dir) {
		File::Path->remove_tree($this_set_dir);
		printf "Directory $this_set_dir unlinked.\n"; 
	}
	return 1;
}

sub delete_ogs {
	my $ogsfile = shift @_ or confess("Usage: delete_ogs(OGSFILE)");

	# get taxon shorthand
	# TODO rewrite this part using parametrized queries to protect from SQL injections?
	my $list = get_list_of_taxa();
	print "This is a list of present taxa in the database:\n";
	for (my $i = 0; $i < scalar(@$list); ++$i) {
		printf("%2d. %s %s\n", $i+1, $$list[$i][0], $$list[$i][1]);
	}
	my $in = get_answer("Please enter a number to select one of the taxa (don't fuck with this, no error-catching has been implemented yet)");
	my $taxid;

	# make sure the user doesn't fuck up
	while (($in !~ /^\d+$/) or ($in > scalar(@$list)) or ($in < 1) or !defined($in)) {
		$in = get_answer("Not understood: '$in'. DO NOT FUCK WITH THIS. Enter one of the numbers to select one of the taxa");
	}
	
	# correlate that number to the list of taxa
	$taxid = $$list[$in-1][0];

	# open the file and delete each sequence (slow, I know...)
	my $headers = get_headers_from_fasta($ogsfile);
	my $count = delete_sequences_with_headers($headers);

	delete_taxon($taxid);
	return $count;
}

sub get_headers_from_fasta {
	my $f = shift;
	my $hs = [ ];
	my $fh = Seqload::Fasta->open($f);
	while (my ($h, $s) = $fh->next_seq()) {
		push @$hs, $h;
	}
	undef $fh;
	return $hs;
}

sub delete_sequences_with_headers {
	my $headers = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::delete_sequences_with_headers($headers);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::delete_sequences_with_headers($headers);
	}
}

sub delete_taxon {
	my $specid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::delete_taxon($specid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::delete_taxon($specid);
	}
}

sub get_taxa_in_all_sets{
	my $specid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_taxa_in_all_sets($specid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_taxa_in_all_sets($specid);
	}
}

sub get_ortholog_sets {
	if ($use_mysql) {
		return Wrapper::Mysql::get_ortholog_sets();
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_ortholog_sets();
	}
}

sub get_list_of_ogs{
	if ($use_mysql) {
		return Wrapper::Mysql::get_list_of_ogs();
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_list_of_ogs();
	}
}

sub get_list_of_taxa {
	my $specid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_list_of_taxa($specid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_list_of_taxa($specid);
	}
}

sub db_structure_present {
	if ($use_mysql) {
		return Wrapper::Mysql::db_structure_present();
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::db_structure_present();
	}
}

