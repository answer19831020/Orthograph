#!/usr/bin/perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2012 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write good code
use warnings;       # cry if something seems odd

# Core modules
use Data::Dumper;   # great for debugging
use Config;         # allows checking for system configuration
use Getopt::Long;   # parsing of command line arguments
use Carp;           # alternative warn and die
use File::Path qw(make_path); # mkdir with parent dirs; this also uses File::Spec
use File::Basename; # parsing path names
use File::Temp;     # temporary files
use IO::File;       # object-oriented access to files
use IO::Dir;        # object-oriented access to dirs
use Digest::SHA;    # SHA hashing: good idea or not?
use DBI;	# MySQL database interface 
use DBD::mysql;	# database driver for MySQL
(my $libdir = $0) =~ s/orthograph\.pl$//; 
use lib qw($libdir);
# you might want to look into Log::Message.

# Custom modules
use Orthograph::Hmmsearch;  # object-oriented interface to hmmsearch
use Orthograph::Blastp;     # object-oriented interface to blastp
use Orthograph::Orthocandidate;	# manage candidate orthologs via a OO interface
use Seqload::Fasta qw(fasta2csv); # object-oriented access to fasta files, fasta2csv converter
use Seqload::Mysql; # object-oriented access to fasta-style MySQL databases

my $program_name = 'Orthograph';
my $version = 'alpha1';
print "Orthograph: Orthology prediction using a Graph-based, Reciprocal Approach with Profile Hidden Markov models\n";
print "Copyright 2012 Malte Petersen <mptrsen\@uni-bonn.de>\n";
print "Version $version\n\n";

#--------------------------------------------------
# Only use threads if the system supports it.
# The whole threads system is totally not implemented yet,
# do not attempt to use it!
#-------------------------------------------------- 
my $use_threads = 0;#{{{
if ($use_threads == 1 and $Config{'useithreads'}) {
  print "Using threads.\n";
  use Orthograph::Threaded;
}
elsif ($use_threads == 1 and !$Config{'useithreads'}) {
  die "Fatal: Cannot use threads: Your version of Perl was not compiled with threading support. Not using threads.\n";
}
else {
	print "Not using threads.\n\n";
	$use_threads = 0;
}#}}}

#--------------------------------------------------
# # Variable initialisation
#-------------------------------------------------- 
my $config;                       # will hold the configuration from config file

#--------------------------------------------------
# # Parse config file
#-------------------------------------------------- 
(my $configfile = $0) =~ s/(\.pl)?$/.conf/;#{{{
# mini argument parser for the configfile
for (my $i = 0; $i < scalar @ARGV; ++$i) {
	if ($ARGV[$i] =~ /-c/) {
		if ($ARGV[$i+1] !~ /^-/) {
		  $configfile = $ARGV[$i+1];
		}
		else { warn "Warning: Config file name '$ARGV[$i+1]' not accepted (use './$ARGV[$i+1]' if you mean it). Falling back to '$configfile'\n" }
	}
}
if (-e $configfile) {
  print "Parsing config file '$configfile'.\n";
  $config = &parse_config($configfile);
}#}}}


#--------------------------------------------------
# # Programs in the order of their use
#-------------------------------------------------- 
my $alignment_program = $config->{'alignment_program'} ? $config->{'alignment_program'} : 'mafft --localpair --maxiterate 1000';#{{{
my $hmmbuild_program  = $config->{'hmmbuild_program'} ? $config->{'hmmbuild_program'} : 'hmmbuild';
my $translateprog     = $config->{'translate_program'} ? $config->{'translate_program'} : 'fastatranslate';
my $hmmsearchprog     = $config->{'hmmsearch_program'} ? $config->{'hmmsearch_program'} : 'hmmsearch';
my $blastprog         = $config->{'blast_program'}     ? $config->{'blast_program'}     : 'blastp';
my $makeblastdbprog   = $config->{'makeblastdb_program'} ? $config->{'makeblastdb_program'}     : 'makeblastdb';#}}}

#--------------------------------------------------
# # These variables can be set in the config file
#-------------------------------------------------- 
#{{{
my $aaoutdir       = $config->{'aaoutdir'}              ? $config->{'aaoutdir'}             : 'aa';
my $backup_ext     = $config->{'backup_extension'}      ? $config->{'backup_extension'}     : '.bak';
my $blast_max_hits = $config->{'blast_max_hits'}        ? $config->{'blast_max_hits'}       : 3;
my $blastoutdir    = $config->{'blastoutdir'}           ? $config->{'blastoutdir'}          : 'blastp';
my $blast_evalue_threshold = $config->{'blast_evalue_threshold'}        ? $config->{'blast_evalue_threshold'}       : 10;
my $blast_score_threshold  = $config->{'blast_score_threshold'}         ? $config->{'blast_score_threshold'}        : 10;
my $clear_data     = defined($config->{'clear_data'})  ? $config->{'clear_data'}           : 1;
my $debug          = $config->{'debug'}                ? $config->{'debug'}                : undef;
my $estfile        = $config->{'estfile'}              ? $config->{'estfile'}              : '';
my $hmmfile        = $config->{'hmmfile'}              ? $config->{'hmmfile'}              : '';
my $hmmoutdir      = $config->{'hmmsearch_output_dir'} ? $config->{'hmmsearch_output_dir'} : basename($hmmsearchprog);
my $hmmsearch_evalue_threshold = $config->{'hmmsearch_evalue_threshold'} ? $config->{'hmmsearch_evalue_threshold'}  : undef;
my $hmmsearch_score_threshold = $config->{'hmmsearch_score_threshold'}      ? $config->{'hmmsearch_score_threshold'}      : undef;
my $mysql_dbname   = $config->{'mysql_dbname'}         ? $config->{'mysql_dbname'}         : 'orthograph';
my $mysql_dbpwd    = $config->{'mysql_dbpassword'}     ? $config->{'mysql_dbpassword'}     : 'root';
my $mysql_dbserver = $config->{'mysql_dbserver'}       ? $config->{'mysql_dbserver'}       : 'localhost';
my $mysql_dbuser   = $config->{'mysql_dbuser'}          ? $config->{'mysql_dbuser'}         : 'root';
my $mysql_table_prefix = $config->{'mysql_table_prefix'} ? $config->{'mysql_table_prefix'} : 'orthograph';
# make sure there is exactly one underscore at the end of the prefix
$mysql_table_prefix =~ s/_*$/_/;

my $mysql_table_blast = $config->{'mysql_table_blast'} ?
	$mysql_table_prefix . $config->{'mysql_table_blast'} :
	$mysql_table_prefix . 'blast';
my $mysql_table_core_orthologs = $config->{'mysql_table_core_orthologs'} ?
	$mysql_table_prefix . $config->{'mysql_table_core_orthologs'} :
	$mysql_table_prefix . 'core_orthologs';
my $mysql_table_blastdbs = $config->{'mysql_table_blastdbs'} ?
	$mysql_table_prefix . $config->{'mysql_table_blastdbs'} :
	$mysql_table_prefix . 'blastdbs';
my $mysql_table_ests = $config->{'mysql_table_ests'} ?
	$mysql_table_prefix . $config->{'mysql_table_ests'} :
	$mysql_table_prefix . 'ests';
my $mysql_table_hmmsearch = $config->{'mysql_table_hmmsearch'} ?
	$mysql_table_prefix . $config->{'mysql_table_hmmsearch'} :
	$mysql_table_prefix . 'hmmsearch';
my $mysql_table_set_details = $config->{'mysql_table_set_details'} ?
	$mysql_table_prefix . $config->{'mysql_table_set_details'} :
	$mysql_table_prefix . 'set_details';
my $mysql_table_aaseqs = $config->{'aaseqs'} ?
	$mysql_table_prefix . $config->{'aaseqs'} :
	$mysql_table_prefix . 'aaseqs';
my $mysql_table_seqpairs       = $config->{'sequence_pairs'} ?
	$mysql_table_prefix . $config->{'sequence_pairs'} :
	$mysql_table_prefix . 'sequence_pairs';
my $mysql_table_taxa       = $config->{'taxa'} ?
	$mysql_table_prefix . $config->{'taxa'} :
	$mysql_table_prefix . 'taxa';
my $mysql_table_orthologs      = $config->{'orthologs'} ?
	$mysql_table_prefix . $config->{'orthologs'} :
	$mysql_table_prefix . 'orthologs';
my $outdir         = $config->{'output_directory'}      ? $config->{'output_directory'}     : undef;
my $orthoset       = $config->{'ortholog_set'}          ? $config->{'ortholog_set'}         : undef;
my $quiet          = $config->{'quiet'}                 ? $config->{'quiet'}                : undef;  # I like my quiet
my $reftaxa        = $config->{'reference_taxa'}        ? $config->{'reference_taxa'}       : undef;
my $sets_dir       = $config->{'sets_dir'}              ? $config->{'sets_dir'}             : 'sets';
my $species_name   = $config->{'species_name'}          ? $config->{'species_name'}         : undef;
my $verbose        = $config->{'verbose'}               ? $config->{'verbose'}              : undef;
#}}}

#--------------------------------------------------
# # More variables
#-------------------------------------------------- 
#{{{
my $count               = 0;
my $blastdb;
my $blastcount;
my $blasthitcount_total;
my $hmmdir              = '';
my $hmmresultfileref;
my $hmmcount;
my $hmmhitcount;
my $hmmhitcount_total   = 0;
my $mysql_dbi           = "dbi\:mysql\:$mysql_dbname\:$mysql_dbserver";
my $mysql_col_aaseq     = 'aa_seq';
my $mysql_col_blastdbpath   = 'blastdb_path';
my $mysql_col_date      = 'date';
my $mysql_col_end       = 'end';
my $mysql_col_evalue    = 'evalue';
my $mysql_col_start     = 'start';
my $mysql_col_hdr       = 'header';
my $mysql_col_hmm       = 'hmm';
my $mysql_col_id        = 'id';
my $mysql_col_digest    = 'digest';
my $mysql_col_name      = 'name';
my $mysql_col_orthoid   = 'ortholog_gene_id';
my $mysql_col_query     = 'query';
my $mysql_col_score     = 'score';
my $mysql_col_seq       = 'sequence';
my $mysql_col_seqpair   = 'sequence_pair';
my $mysql_col_setid     = 'setid';
my $mysql_col_spec      = 'spec';
my $mysql_col_target    = 'target';
my $mysql_col_taxid     = 'taxid';
my $mysql_col_taxon     = 'taxon';
my $num_ests;
my $num_hmms;
my $orthocount = 0;
my $preparedb;
my $protfile            = '';
my $timestamp           = time();
my $tmpdir              = File::Temp->newdir(
                            'UNLINK' => 0, 
                            'TEMPLATE' => File::Spec->catdir($outdir, 'tmpXXXX'));
my @hmmfiles;
my @reftaxa;
my @seqobjs;
#}}}

#--------------------------------------------------
# # Get command line options. These may override variables set via the config file.
#-------------------------------------------------- 
#{{{
GetOptions( 'v'        => \$verbose,
	'c'                  => \$configfile,
  'd'                  => \$debug,
	'threads'            => \$use_threads,   # make using threads optional
	'estfile=s'          => \$estfile,
	'E=s'                => \$estfile,
	'blast_evalue=s'     => \$blast_evalue_threshold,
	'blast_score=s'      => \$blast_score_threshold,
	'hmmsearch_evalue=s' => \$hmmsearch_evalue_threshold,
	'hmmsearch_score=s'  => \$hmmsearch_score_threshold,
	'H=s'                => \$hmmfile,
	'hmmsearchprog=s'    => \$hmmsearchprog,
	'preparedb'          => \$preparedb,
	'quiet'              => \$quiet,
	'taxon=s'            => \$species_name,
);#}}}

#--------------------------------------------------
# # Special case: Prepare the MySQL database by dropping and recreating all
# # tables if requested, then exit
#-------------------------------------------------- 
if ($preparedb) {#{{{
	$| = 1;
  print "Setting MySQL database $mysql_dbname to a clean slate... ";
	$| = 0;
  &preparedb;
  print "OK\nMySQL database now ready to run $program_name.\n";
  exit;
}#}}}

#--------------------------------------------------
# # Normal run. Input error checking, reporting etc
#-------------------------------------------------- 
&intro;

# prepare the HMMs
$hmmdir = &make_hmms($orthoset);
# prepare the BLAST database
$blastdb = &make_blastdb($orthoset);

#--------------------------------------------------
# # create list of reference taxa and HMM files 
#-------------------------------------------------- 
# @reftaxa = split(/\s*,\s*/, $reftaxa);	# no more reference taxa for now
@hmmfiles = &hmmlist($hmmdir);
$num_hmms = scalar @hmmfiles;


unless ($quiet) {#{{{
  print "Using HMM dir $hmmdir with ", scalar @hmmfiles, " HMM files.\n" 
    if $hmmdir;
  print "Using HMM file $hmmfile.\n" 
    if $hmmfile;
  print "HMMsearch e-Value cutoff: $hmmsearch_evalue_threshold.\n" 
    if $hmmsearch_evalue_threshold;
  print "Score cutoff: $hmmsearch_score_threshold.\n"
    if $hmmsearch_score_threshold;
}#}}}

#--------------------------------------------------
# # translate the ESTs to protein, feed that shit to the database
#-------------------------------------------------- 
$protfile = &translate_est(File::Spec->catfile($estfile));#{{{

# Clear database of data from the same species
if ($clear_data) {
	print "Clearing database of previous results from '$species_name'...\n" unless $quiet;
	&clear_db;
}
# store est data into the database:
print "Storing translated sequences to MySQL database '$mysql_dbname' on $mysql_dbserver...\n" unless $quiet;

# third arg must be array ref
$num_ests = &load_data_infile($protfile, $mysql_table_ests, [ $mysql_col_digest, $mysql_col_spec, $mysql_col_date, $mysql_col_hdr, $mysql_col_seq ]);

printf "%d sequences stored to database '%s' on %s. Sequence identifiers have been replaced with SHA1 digests of the combination (header, sequence). These are used for internal purposes.\n",
	$num_ests,
	$mysql_dbname,
	$mysql_dbserver unless $quiet;

# number of existing transcript sequences
$num_ests = &mysql_get("SELECT COUNT(*) FROM $mysql_table_ests WHERE $mysql_col_spec = '$species_name'");
$num_ests = $$num_ests[0][0];
printf "%d sequences in database '%s' on %s.\n", 
	$num_ests,
	$mysql_dbname,
	$mysql_dbserver unless $quiet;

# get the transcripts with their new ID back from the database. TODO is this efficient?
$protfile = &get_transcripts();
#}}}

#--------------------------------------------------
# # Setup the $program_name modules. These are all class methods.
#-------------------------------------------------- 

# verbose output; this is a class method#{{{
if ($verbose) {
	Orthograph::Hmmsearch->verbose(1);
	Orthograph::Blastp->verbose(1);
}

if ($debug) {
	Orthograph::Hmmsearch->debug(1);
	Orthograph::Blastp->debug(1);
}

Orthograph::Hmmsearch->evalue_threshold($hmmsearch_evalue_threshold) if $hmmsearch_evalue_threshold;
Orthograph::Hmmsearch->score_threshold($hmmsearch_score_threshold) if $hmmsearch_score_threshold;
Orthograph::Blastp->evalue_threshold($blast_evalue_threshold) if $blast_evalue_threshold;
Orthograph::Blastp->score_threshold($blast_score_threshold) if $blast_score_threshold;

# the output directories
Orthograph::Hmmsearch->outdir($hmmoutdir);
Orthograph::Blastp->outdir($blastoutdir);

# the programs
Orthograph::Hmmsearch->searchprog($hmmsearchprog);
Orthograph::Blastp->set_blast($blastprog);

# maximum number of BLAST hits to save
Orthograph::Blastp->max_hits(3);

#}}}

#--------------------------------------------------
# # HMMsearch the protfile using all HMMs
#-------------------------------------------------- 
printf("HMMsearching the protein file using all %d HMMs in %s\:\n", scalar(@hmmfiles), $hmmdir)
	unless $quiet;
$hmmcount = 0;
$hmmhitcount = 0;

$DB::single=2; # debugging breakpoint
HMMFILE:
foreach my $hmmfile (@hmmfiles) {#{{{
	$DB::single=2; # debugging breakpoint
	++$hmmcount;
	$blastcount = 0;	# reset counter

	# create new hmmobject with a hmm file, should have all the necessary info for doing hmmsearch
	my $hmmobj = Orthograph::Hmmsearch->new($hmmfile); 

	# now do the hmmsearch on the protfile
	$hmmobj->search($protfile);

	# count the hmmsearch hits
	printf("%4d hits for %s (%d%% complete)\n", 
		$hmmobj->hitcount,
		basename($hmmobj->hmmfile),
		($hmmcount * 100 / $num_hmms)) unless $quiet;
	if ($hmmobj->hitcount() == 0) { # do not care further with HMM files that did not return any result
		next HMMFILE;
	}

	# add hitcount to total number of hmm hits,
	# print list of hits if verbose
	$hmmhitcount_total += $hmmobj->hitcount;
	if ($verbose) {
		my $hits = $hmmobj->hits_arrayref();
		for (my $i = 0; $i < scalar @$hits; $i++) {
			printf "     [%d] %s, e-value %2.1e\n", $i + 1, $hits->[$i]->{'target'}, $hits->[$i]->{'evalue'};
		}
	}

	#--------------------------------------------------
	# # push results to database 
	#-------------------------------------------------- 
	&insert_results_into_table($mysql_table_hmmsearch, $hmmobj->hits_arrayref);
	print "     ... pushed to database.\n" if $verbose;
	++$hmmhitcount;
	
	# setup SQL query; use the first array item since they all share the query (HMM) ID 
	my $query_get_sequences = "SELECT $mysql_table_ests.$mysql_col_digest, $mysql_table_ests.$mysql_col_seq
		FROM $mysql_table_ests 
		INNER JOIN $mysql_table_hmmsearch
		ON $mysql_table_hmmsearch.$mysql_col_target = $mysql_table_ests.$mysql_col_digest
		WHERE $mysql_table_hmmsearch.$mysql_col_query = '" . $hmmobj->hits_arrayref->[0]{'query'} . "'";

	#--------------------------------------------------
	# # the reciprocal search
	#-------------------------------------------------- 

	# get the sequences from the database (as array->array reference)
	my @hmmresults = @{&mysql_get($query_get_sequences)};

	HMMRESULT:
	for (my $n = 0; $n < scalar(@hmmresults); ++$n) { #{{{
 		++$count;

		# setup a temporary file to hold the sequence to be blast'ed
		my $tmpfile = File::Temp->new(
			'UNLINK' => 1, 
			'TEMPLATE' => File::Spec->catfile($tmpdir, basename($hmmobj->hmmfile) . '-XXXX'));
		# write fasta header and sequence to the tempfile
		printf($tmpfile ">%s\n%s\n", $hmmresults[$n]->[0], $hmmresults[$n]->[1]);

		#--------------------------------------------------
		# # run blastp 
		#-------------------------------------------------- 
		# shiny new blastp object
		my $blastobj = Orthograph::Blastp->new($blastdb);

		# generate a blast output file name from the HMM name and the hit number
		my $blastoutfile = File::Spec->catfile($blastoutdir, $hmmobj->hmmname . '-' . sprintf("%04d", $n + 1) . '-' . basename($blastdb) .  '.blast');

		# do the blastp search; skip if no hits obtained
		$blastobj->blastp($tmpfile, $blastoutfile);

		printf("       %4d BLASTP hits detected for [%d] against %s, e-value below %2.1e\n",
			$blastobj->hitcount,
			$n + 1,
			basename($blastdb),
			$blast_evalue_threshold) if $verbose;

		$blasthitcount_total += $blastobj->hitcount();

		# skip to next if BLAST finds nothing
		unless ($blastobj->hitcount()) { next HMMRESULT }

		# insert the blast results into the db. 3-argument form.
		&insert_results_into_table($mysql_table_blast, $blastobj->blasthits_arrayref, basename($blastdb));
		print "            ... pushed to database.\n" if $verbose;
	} #}}}

	if ($hmmcount <= scalar(@hmmfiles) / 100) {
		print "\n(Don't be alarmed, the sequence identifiers are SHA1-hashed but their original label is preserved in the database and will be output at the end. Don't be alarmed)\n\n"
			if $verbose;
	}

	my $orthologs = &get_orthologs($hmmobj->hmmname, $hmmobj->hits_arrayref()->[0]->{'target'});
	next HMMFILE unless defined $$orthologs[0];	# skip empty results

	# write the result to output file
	my $outfh = IO::File->new(File::Spec->catfile($aaoutdir, $$orthologs[0][0] . '.fa'), 'w');
	for (0..$#{$orthologs}) { 
		printf $outfh ">%s:%s\n%s\n", 
			$$orthologs[$_][1],	# the taxon shorthand of the ortholog sequence
			$$orthologs[$_][3],	# the sequence id of the ortholog sequence
			$$orthologs[$_][4]  # the sequence
				or croak "Fatal: Could not write to output file $outfh: $!";
	}
	# the header and sequence of the hit
	# this is the best hit since the SQL query sorts by evalue and we take the first one
	printf $outfh ">%s\n%s\n", $$orthologs[0][5], $$orthologs[0][6];
	$outfh->close();
	# yay
	++$orthocount;
	printf "!! ^-------Possible orthology detected for %s! Added candidate to database.\n", $$orthologs[0][0];
	# get the ortholog results from the db
	my $orthocand = Orthograph::Orthocandidate->new($hmmobj->hmmname, $hmmobj->hits_arrayref()->[0]->{'target'});
	Orthograph::Orthocandidate->add($orthocand);
	# printf("Added candidate for %s (%d) to candidate database.\n", $orthocand->orthoid(), Orthograph::Orthocandidate->getindex());

}#}}}

# report, end the program
printf "\n%s analysis for %s complete.\n", $program_name, $species_name;
printf "%d HMMs hit something. %d HMM files processed. \n", $hmmhitcount, $hmmcount unless $quiet;
printf "Searched %d EST sequences using %d HMMs and obtained %d total ortholog hits (%2.2f%%).\n",
	$num_ests, $hmmcount, $orthocount, ((100 * $orthocount) / $hmmcount);
printf "Now go look in your output directory %s.\n", $outdir;

exit;


###################################################
# # Functions 
###################################################

# Sub: mysql_dbh
# Get a database handle
# Arguments: -
# Returns: Database handle
sub mysql_dbh {#{{{
	return DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
}#}}}

# Sub: mysql_get
# Get from the database the result of a SQL query
# Expects: QUERY as a string literal
# Returns: Reference to array of arrays (result lines->fields)
sub mysql_get {#{{{
	my $query = shift;
	unless ($query) { croak "Usage: mysql_get(QUERY)\n" }
  # prepare anonymous array
	my $results = [ ];
  # connect and fetch stuff
	my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
	my $sql = $dbh->prepare($query);
	$sql->execute();
	while (my @result = $sql->fetchrow_array() ) {
		push(@$results, \@result);
	}
	$sql->finish();
	$dbh->disconnect; # disconnect ASAP
	return $results;
}#}}}

# Sub: mysql_do
# Connect to a database, execute a single query (for repetitive queries, you better do that by hand).
# Expects: scalar string SQL query. 
# Returns 1 on result, dies otherwise.

sub mysql_do {#{{{
	my $query = shift;
	unless ($query) { croak "Usage: mysql_do(QUERY)\n" }
	my @fields = @_;
	my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
	my $sql = $dbh->prepare($query);
	$sql->execute(@fields) or die;
	$dbh->disconnect();
	return 1;
}#}}}

# Sub: parse_config
# Parse a simple, ini-style config file where keys are separated from values by '='. 
# Sections are not supported. 
# outputdir = /home/foo/bar
sub parse_config {#{{{
	my $file = shift;
	my $conf = { };
	open(my $fh, '<', $file) or die "Fatal: Could not open config file $file\: $!\n";

	while (my $line = <$fh>) {
		next if $line =~ /^\s*$/; # skip empty lines
		next if $line =~ /^\s*#/; # skip comment lines starting with '#'
		if ($line !~ /^\s*\w+\s*=\s*[\/]?\w+/) {
			die "Fatal: Invalid format in line $. of config file $file:\n$line\n"
		}
		
		# split by '=' producing a maximum of two items
		my ($key, $val) = split('=', $line, 2);

		foreach ($key, $val) {
		  s/\s+$//; # remove all trailing whitespace
		  s/^\s+//; # remove all leading whitespace
		}

		die "Fatal: Configuration option '$key' defined twice in line $. of config file $file\n"
		  if defined $conf->{$key};
		$conf->{$key} = $val;
	}
	close($fh);
	return $conf;
}#}}}

# Sub: progress_bar
# Returns a wget-style progress bar.
# Arguments: 
sub progress_bar {#{{{
	my ($got, $total, $width, $char) = @_;
	$width ||= 25;
	$char ||= '=';
	my $num_width = length($total);
	$| = 1;
	printf("|%-${width}s| Progress: %${num_width}s of %s (%.2f%%)\r", $char x (($width-1)*$got/$total) . '>', $got, $total, 100*$got/$total);
	$| = 0;
}#}}}

# Sub: intro
# Checks input, file/dir presence, etc.
# Returns True if everything is OK.
sub intro {#{{{
	die "Fatal: Species name needed (-taxon NAME)!\n"
		unless ($species_name);
	
	die "Fatal: Ortholog set name required (ortholog_set)!\n"
		unless ($orthoset);

	# mutually exclusive options
	die "Fatal: Can't operate in both verbose and quiet mode\n"
		if ($verbose and $quiet);

	# mutually exclusive options
	die "Fatal: Can't use both e-value and score thresholds\n"
		if ($hmmsearch_evalue_threshold and $hmmsearch_score_threshold);

	# construct output directory paths
	# outdir may be defined in the config file
	$outdir = defined($outdir) ? $outdir : $species_name;
	$aaoutdir = File::Spec->catdir($outdir, $aaoutdir);
	$hmmoutdir = defined($hmmoutdir) ? File::Spec->catdir($outdir, $hmmoutdir) : File::Spec->catdir($outdir, basename($hmmsearchprog));
  $blastoutdir = defined($blastoutdir) ? File::Spec->catdir($outdir, $blastoutdir) : File::Spec->catdir($outdir, basename($blastprog));

	# the HMM directory
	unless ($hmmdir) { $hmmdir = File::Spec->catdir($sets_dir, $orthoset, 'hmms') }
	if (-d $hmmdir) {
		print "HMM dir $hmmdir exists.\n" unless $quiet;
	}
	else {
		print "HMM dir $hmmdir does not exist, creating...\n" unless $quiet;
		&makedir($hmmdir);
	}

	# the EST file
	if (-e $estfile) {
		print "EST file $estfile exists.\n" unless $quiet;
	}
	else {
		die "Fatal: EST file $estfile does not exist!\n";
	}

	# the HMMsearch output directory
	if (-d $hmmoutdir) {
		print "HMMsearch output dir $hmmoutdir exists.\n" unless $quiet;
		if ($clear_data) {
			&cleardir($hmmoutdir);
			print "Purged HMMsearch output dir $hmmoutdir of old result files.\n" unless $quiet;
		}
	}
	else {
		print "HMMsearch output dir $hmmoutdir does not exist, creating...\n" unless $quiet;
		&makedir($hmmoutdir);
	}

  # the BLASTP output directory
  if (-d $blastoutdir) {
    print "BLASTP output dir $blastoutdir exists.\n" unless $quiet;
		if ($clear_data) {
			&cleardir($blastoutdir);
			print "Purged BLAST output dir $blastoutdir of old result files.\n"
				unless $quiet;
		}
  }
  else {
    print "BLASTP output dir $blastoutdir does not exist, creating...\n" unless $quiet;
    &makedir($blastoutdir);
  }
	# the aa output directory
	if (-d $aaoutdir) {
		print "AA output dir $aaoutdir exists.\n" unless $quiet;
		if ($clear_data) {
			&cleardir($aaoutdir);
			print "Purged AA output dir $aaoutdir of old result files.\n"
				unless $quiet;
		}
	}
	else {
		print "AA output dir $aaoutdir does not exist, creating...\n"
			unless $quiet;
		&makedir($aaoutdir);
	}

}#}}}

# Sub: hmmlist
# Expects: nothing (?)
# Returns: array hmmfiles
sub hmmlist {#{{{
	my $hmmdir = shift;
	if (-e $hmmdir) {
		my $dir = IO::Dir->new(File::Spec->catdir($hmmdir));
		while (my $file = $dir->read) {
		  push(@hmmfiles, File::Spec->catfile($hmmdir, $file)) if ($file =~ /\.hmm$/);
		}
		$dir->close;
		return sort @hmmfiles;
	}
	else {
		print "single hmm\n"
		  if $verbose;
		push(@hmmfiles, $hmmfile);
		return @hmmfiles;
	}
}#}}}

# Sub: translate_est
# Translate a nucleotide fasta file to protein in all six reading frames
# Expects: scalar string filename
# Returns: scalar string filename (protfile)
sub translate_est {#{{{
  my ($infile) = shift;
  (my $outfile = $infile) =~ s/(\.fa$)/_prot$1/;
  print "Translating $estfile in all six reading frames...\n" unless $quiet;
  if (-e $outfile) {
    print "$outfile exists, using this one.\n" unless $quiet;
    return $outfile;
  }
  my $translateline = qq('$translateprog' $infile > $outfile);
  die "Fatal: Could not translate $infile: $!\n"
    if system($translateline);

  return $outfile;
}#}}}

# sub: backup_up_old_output_files
# input: reference to list of relevant contigs
sub backup_old_output_files {#{{{
  my ($outfile) = shift @_;
  if (-e $outfile) {
    rename($outfile, File::Spec->catfile($outfile . '.' . $backup_ext)) or die "wah: could not rename $outfile during backup: $!\n";
    print "backed up old file $outfile to ", $outfile.$backup_ext, "\n";
  }
}#}}}

# Sub: makedir
# Creates a directory with parent directories if it does not already exist
# Expects: scalar string dirname
# Returns: True if successful
sub makedir {#{{{
  my $dir = shift;
  if (-e $dir and not -d $dir) {
    die "Fatal: $dir exists, but is not a directory! This will most likely lead to problems later.\n";
  }
  else {
    make_path $dir, { verbose => 0 } or die "Fatal: Could not create $dir: $!\n";
    return 1;
  }
  return 1;
}#}}}

# Sub: cleardir
# Empties a directory of non-dotfiles
# Arguments: scalar string dirname
sub cleardir {#{{{
	my $dir = shift(@_);
	opendir(my $dirh, $dir)
		or croak("Fatal: Couldn't open dir $dir\: $!");
	foreach (readdir($dirh)) {
		next if $_ =~ /^\.\.?$/;
		unlink(File::Spec->catfile($dir, $_))
			or carp("Warning: Could not delete file " . File::Spec->catfile($dir, $_) . ": $!");
	}
	closedir($dirh)
		or croak("Fatal: Couldn't close dir $dir\: $!");
	return 1;
}#}}}

# Sub: preparedb
# Generate a clean database, deleting all existing tables and starting from scratch
# Returns: True on success
sub preparedb {#{{{
	my $query_create_ests = "CREATE TABLE $mysql_table_ests ( 
		$mysql_col_id        INT NOT NULL AUTO_INCREMENT, INDEX($mysql_col_id),
		$mysql_col_digest    CHAR(32) NOT NULL,           INDEX($mysql_col_digest),
		$mysql_col_spec      VARCHAR(255) NOT NULL,       INDEX($mysql_col_spec),
		$mysql_col_date      INT(11) UNSIGNED,
		$mysql_col_hdr       VARCHAR(255) NOT NULL,       INDEX ($mysql_col_hdr),
		$mysql_col_seq       MEDIUMBLOB DEFAULT NULL)";

	my $query_create_hmmsearch = "CREATE TABLE $mysql_table_hmmsearch (
		$mysql_col_id        INT NOT NULL AUTO_INCREMENT, INDEX($mysql_col_id),
		$mysql_col_spec      VARCHAR(255) NOT NULL,       INDEX($mysql_col_spec),
		$mysql_col_query     VARCHAR(255) NOT NULL,       INDEX($mysql_col_query),
		$mysql_col_target    VARCHAR(255) NOT NULL,       INDEX ($mysql_col_target),
		UNIQUE INDEX($mysql_col_query, $mysql_col_target),
		$mysql_col_score     FLOAT NOT NULL,
		$mysql_col_evalue    FLOAT NOT NULL,
		$mysql_col_start      INT(4) NOT NULL,
		$mysql_col_end        INT(4) NOT NULL)";
	
	my $query_create_blast = "CREATE TABLE $mysql_table_blast (
		$mysql_col_id        INT NOT NULL AUTO_INCREMENT, INDEX ($mysql_col_id),
		$mysql_col_spec      VARCHAR(255) NOT NULL,       INDEX ($mysql_col_spec),
		$mysql_col_blastdbpath   VARCHAR(255) NOT NULL,
		$mysql_col_query     VARCHAR(255) NOT NULL,       INDEX ($mysql_col_query),
		$mysql_col_target    VARCHAR(255) NOT NULL,       INDEX ($mysql_col_target),
		UNIQUE INDEX($mysql_col_query, $mysql_col_target),
		$mysql_col_score     FLOAT NOT NULL,
		$mysql_col_evalue    FLOAT NOT NULL)";
	
	# open connection
	my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);

	# drop all tables
	foreach ($mysql_table_ests, $mysql_table_hmmsearch, $mysql_table_blast) {
		my $query_drop = "DROP TABLE IF EXISTS $_";
		print "$query_drop;\n" if $verbose;
		my $sql = $dbh->prepare($query_drop);
		$sql->execute()
		  or die "Could not execute SQL query: $!\n";
	}

	# create all tables
	foreach my $query ($query_create_ests, $query_create_hmmsearch, $query_create_blast) {
		printf "$query;\n" if $verbose;
		my $sql = $dbh->prepare($query);
		$sql->execute()
		  or die "Could not execute SQL query: $!\n";
	}

	# disconnect
	$dbh->disconnect();

	return 1;
} #}}}

# Sub: clear_db
# clears the database of previous results from the same species 
sub clear_db {#{{{
	# clear previous results from the same species
	my $query_clear_ests           = "DELETE FROM $mysql_table_ests 
		                                WHERE $mysql_col_spec = '$species_name'";
	my $query_clear_hmmsearch      = "DELETE FROM $mysql_table_hmmsearch 
		                                WHERE $mysql_col_spec = '$species_name'";
	my $query_clear_blast          = "DELETE FROM $mysql_table_blast 
		                                WHERE $mysql_col_spec = '$species_name'";

	# open connection
	my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);

	my $sql = $dbh->prepare($query_clear_ests);
	$sql->execute() or die "$!\n";
	$sql = $dbh->prepare($query_clear_hmmsearch);
	$sql->execute() or die "$!\n";
	$sql = $dbh->prepare($query_clear_blast);
	$sql->execute() or die "$!\n";

	# disconnect ASAP
	$dbh->disconnect;
	return 1;
}#}}}

# Sub: insert_results_into_table
#	inserts the results of either hmmsearch or blastp into a mysql database
# Expects: scalar string TABLENAME, reference to array HITS, scalar string BLASTDATABASE (optional)
# Returns: Number of inserted results (hitcount)
sub insert_results_into_table {#{{{
	my $table = shift;
	my $hits  = shift;
	# may have been called with 3 args, then we are dealing with a blast result
	my $blastdb = (scalar @_ == 1) ? shift : undef;
	if (ref $blastdb) { confess 'Usage: insert_results_into_table($table, $columns_ref, $blastdb)' }
	my $hitcount;
	
	# this is a BLASTP result, we need the column 'blastdb'
	if ($blastdb) {
		my $query_insert_result = "INSERT IGNORE INTO $table (
			`$mysql_col_spec`,
			`$mysql_col_blastdbpath`,
			`$mysql_col_query`,
			`$mysql_col_target`,
			`$mysql_col_score`,
			`$mysql_col_evalue`) VALUES (
			?,
			?,
			?,
			?,
			?,
			?)";
		my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
		my $sql = $dbh->prepare($query_insert_result);

		# this is a reference to an array of hashes
		foreach my $hit (@$hits) {
			$sql->execute(
				$species_name,
				$blastdb,
				$hit->{'query'},  # query (HMM)
				$hit->{'target'}, # target (header)
				$hit->{'score'},  # score
				$hit->{'evalue'}  # evalue
			) or die "Fatal: Could not push to database!\n";
			++$hitcount;
		}
		$dbh->disconnect;
		return $hitcount;
	}
	# this is a HMMsearch result, need 7 columns
	else {
		# SQL query for pushing HMMsearch results to the db
		my $query_insert_result = "INSERT IGNORE INTO $table (
			`$mysql_col_spec`,
			`$mysql_col_query`,
			`$mysql_col_target`,
			`$mysql_col_score`,
			`$mysql_col_evalue`,
			`$mysql_col_start`,
			`$mysql_col_end`) VALUES (
			?,
			?,
			?,
			?,
			?,
			?,
			?)";

		my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
		my $sql = $dbh->prepare($query_insert_result);

		# this is a reference to an array of hashes
		foreach my $hit (@$hits) {
			$sql->execute(
				$species_name,
				$hit->{'query'},  # query (HMM)
				$hit->{'target'}, # target (header)
				$hit->{'score'},  # score
				$hit->{'evalue'}, # evalue
				$hit->{'start'},	# start of hit domain
				$hit->{'end'}			# end of hit domain
			) or die "Fatal: Could not push to database!\n";
			++$hitcount;
		}
		$dbh->disconnect;
		return $hitcount;
	}
}#}}}

# Sub: get_blastdir_for
# returns the BLASTP database path for a given reference taxon
# Expects: scalar string REFTAXON
# Returns: scalar string PATH TO BLASTDB
sub get_blastdir_for {#{{{
	my $query = "SELECT $mysql_table_blastdbs.blastdb_path FROM $mysql_table_blastdbs INNER JOIN $mysql_table_set_details ON $mysql_table_set_details.id = $mysql_table_blastdbs.setid LIMIT 1";
	my $result = &mysql_get($query);
	my $blastdir = File::Spec->catfile($$result[0][0], $orthoset);
	return $blastdir;
}#}}}

# Sub: make_hmms
# Generate HMMs for a given core-ortholog set
# Arguments: scalar string ortholog set name
# Returns: True if successful
sub make_hmms {#{{{
	my $set = shift;
	my $hmmsuffix = '.hmm';
	my $data = {};
	my $query = "SELECT o.$mysql_col_orthoid, a.id, a.$mysql_col_seq
		FROM $mysql_table_orthologs AS o
    INNER JOIN $mysql_table_seqpairs AS p
    ON o.$mysql_col_seqpair = p.id
    INNER JOIN $mysql_table_aaseqs AS a
    ON a.id = p.$mysql_col_aaseq
    INNER JOIN $mysql_table_set_details AS d
    ON d.id = o.$mysql_col_setid
    WHERE d.$mysql_col_name = '$set'";

	# does the set dir exist?
	if (!-e $hmmdir) {
		&makedir($hmmdir);
	}
	print "Generating ortholog set $set...  This may take a long time, please be patient.\n" unless $quiet;

	# get the ortholog set from the database
	my $dbh = &mysql_dbh();
	my $sql = $dbh->prepare($query);
	$sql->execute() or croak();
	while (my @row = $sql->fetchrow_array()) {
		# load the whole set into memory, i don't give a frak
		$$data{$row[0]}{$row[1]} = $row[2];
	}
	$dbh->disconnect();	# disc asap

	my $num_orthoids = keys(%$data);
	my $o = 0;
	foreach my $orthoid (keys %$data) {
		&progress_bar($o, $num_orthoids, 25, '-');
		++$o;
		my $hmmfile = File::Spec->catfile($hmmdir, $orthoid . $hmmsuffix);
		# does this HMM already exist?
		next if (-e $hmmfile);	
		# no, create new fasta file and so on
		my $fafh = File::Temp->new();
		foreach my $id (keys %{$data->{$orthoid}}) {
			printf($fafh ">%s\n%s\n", $id, $$data{$orthoid}{$id})
				or croak("Fatal: Could not write to file $fafh\: $!");
		}
		$fafh->close();

		# align
		my $alnfile = &align($fafh)
			or croak("Fatal: Alignment failed for $fafh\: $!");

		# convert to stockholm
		my $stockhfile = &fasta2stockholm($alnfile)
			or croak("Fatal: Conversion to Stockholm format failed for $alnfile\: $!");

		# build HMM
		&hmmbuild($stockhfile, $hmmfile)
			or croak("Fatal: HMM generation failed for $alnfile\: $!");
	}
	undef($data);	# free memory... well, it's bound to go out of scope anyway
	return($hmmdir);
}#}}}

# Sub: align
# Generate a fasta alignment from a fasta file
# Arguments: Scalar string filename, scalar string setname
# Returns: Scalar string alignment filename on success, false otherwise
sub align {#{{{
	my $fafile = shift;
	my $set = shift;
	(my $fasuffix = $fafile) =~ /(\.(fa|fas|fasta))/;
	my $alnsuffix = '.aln';
	my @alignment_cmd = qq($alignment_program $fafile);	# this prints the alignment to STDOUT, must be captured somehow
	print "@alignment_cmd\n" if $debug;
	my $tmpf = File::Temp->new();
	print $tmpf `@alignment_cmd 2> /dev/null`
		or croak("Fatal: Could not write to file $tmpf\: $!\n");
	$tmpf->close();
	return $tmpf;
}#}}}

# Sub: fasta2stockholm
# Converts a fasta file into a stockholm file
# Arguments: Scalar string filename
# Returns: Scalar string filename
sub fasta2stockholm {#{{{
	my $fafile = shift;
	my $fh = Seqload::Fasta->open($fafile);
	my $tmpfh = File::Temp->new();
	print $tmpfh "# STOCKHOLM 1.0\n";
	while (my ($h, $s) = $fh->next_seq()) {
		printf($tmpfh "%-50s %s\n", $h, $s)
			or croak("Fatal: Could not write to file $tmpfh\: $!");
	}
	print $tmpfh "//";
	close($tmpfh);
	$fh->close();
	return $tmpfh;
}#}}}

# Sub: hmmbuild
# Generates a hidden Markov model (HMM) file from an alignment (fasta) file.
# Arguments: Scalar string filename, scalar string setname
# Returns: True on success, false otherwise
sub hmmbuild {#{{{
	my $alnfile = shift;
	my $hmmfile = shift;
	my $alnsuffix = '.aln';
	my $hmmsuffix = '.hmm';
	my $hmmname = basename($hmmfile, $hmmsuffix);
	if (-e $hmmfile) { return $hmmfile }
	my @hmmbuild_cmd = qq($hmmbuild_program -n $hmmname $hmmfile $alnfile > /dev/null);
	system(@hmmbuild_cmd) and
		return 0;
	return $hmmfile;
}#}}}

# Sub: make_blastdb 
# Create a BLAST database from a file. Pulls everything from the MySQL database.
# Arguments: Scalar string ortholog set name
# Returns: Scalar string path_to_blastdbfile
sub make_blastdb {#{{{
	my $setname = shift or croak('Usage: make_blastdb($setname)');

	# build the paths for input and output
	my $blastpath = &mysql_get("SELECT DISTINCT $mysql_col_blastdbpath FROM $mysql_table_blastdbs INNER JOIN $mysql_table_set_details ON $mysql_table_set_details.name = '$setname' LIMIT 1");
	my $dbfile = File::Spec->catfile($sets_dir, $setname, 'blast', $setname);
	my $infile = File::Spec->catfile($dbfile . ".fa");

	# check whether a database already exists
	if (-e File::Spec->catfile($dbfile . '.psq')) {
		print "BLAST DB for set $setname exists in $dbfile.\n"
			unless $quiet;
		return $dbfile;
	}

	# database not extant, we have to create it
	$| = 1;
	print "BLAST DB for set $setname does not exist, creating in $dbfile... "
		unless $quiet;
	$| = 0;
	# get the sequences from the database
	my $query = "SELECT $mysql_table_aaseqs.id, $mysql_table_aaseqs.sequence
		FROM $mysql_table_aaseqs
		INNER JOIN $mysql_table_seqpairs
		ON $mysql_table_seqpairs.aa_seq = $mysql_table_aaseqs.id
		INNER JOIN $mysql_table_orthologs
		ON $mysql_table_orthologs.sequence_pair = $mysql_table_seqpairs.id
		INNER JOIN $mysql_table_set_details
		ON $mysql_table_set_details.id = $mysql_table_orthologs.setid
		WHERE $mysql_table_set_details.name = '$setname'";
	my $infh = File::Temp->new();
	my $dbh = &mysql_dbh();
	my $sth = $dbh->prepare($query);
	$sth->execute();
	# write to output file
	while (my ($h, $s) = $sth->fetchrow_array()) {
		# make sure the sequence has only valid characters
		if ($s !~ /^[ABCDEFGHIKLMNPQRSTVWXYZUX]+$/) {
			warn("Warning: Invalid characters in protein sequence $h. Let's hope BLAST will not choke on this one:\n$s");
		}
		printf($infh ">%s\n%s\n", $h, $s)
			or croak("Fatal: Could not write to file $infile\: $!\n");
	}
	$dbh->disconnect();
	close($infh);

	# make blast database
	my @makeblastdbcmd = qq($makeblastdbprog -in $infh -out $dbfile -input_type fasta -title $orthoset > /dev/null);
	system(@makeblastdbcmd) and croak("Fatal: makeblastdb failed: $!\n");
	print "\n";
	return $dbfile;
}#}}}

# Sub: load_data_infile
# LOAD DATA LOCAL INFILE into a table
# Arguments: scalar string filename, scalar string tablename, reference to list of columns
# Returns: scalar int number of loaded rows
sub load_data_infile {#{{{
	my $protfile = shift(@_);
	my $table = shift(@_) or croak 'Usage: &load_data_infile($protfile, $mysql_table_ests [, $columns_reference])';
	my $columns;
	my $list;
	if (scalar(@_)) {
		$columns = shift(@_);
		unless (ref($columns)) {
			croak 'Usage: &load_data_infile($protfile, $mysql_table_ests [, $columns_reference])';
		}
		$list = join(', ', @$columns);
	}

	# Create temporary csv file for high-speed reading into database
	my $tmpfh = File::Temp->new('UNLINK' => 0, 'TEMPLATE' => File::Spec->catfile($tmpdir, 'XXXX'));
	my $protfh = Seqload::Fasta->open($protfile);
	while (my ($h, $s) = $protfh->next_seq()) {
		printf($tmpfh "%s,%s,%d,%s,%s\n", 
			# good idea or not?
			Digest::SHA->sha256_hex($h, $s),
			$species_name,
			time(),
			$h,
			$s
		);
	}
	$protfh->close();
	$tmpfh->close();

	# load data from csv file into database
	my $query = "LOAD DATA LOCAL INFILE '$tmpfh' INTO TABLE $table FIELDS TERMINATED BY ',' ($list)";

	# open connection
	my $dbh = &mysql_dbh();
	$num_ests = $dbh->do($query);
	# disconnect ASAP
	$dbh->disconnect;
	return $num_ests;
}#}}}

# Sub: get_transcripts 
# Get transcript sequences from the database, using their ID as header
# Arguments: None
# Returns: Filehandle
sub get_transcripts {#{{{
	my $tmpfh = File::Temp->new('UNLINK' => 0, 'TEMPLATE' => File::Spec->catfile($tmpdir, 'XXXX'));
	my $query = "SELECT $mysql_col_digest, $mysql_col_seq FROM $mysql_table_ests WHERE $mysql_col_spec = '$species_name'";
	my $dbh = &mysql_dbh();
	my $sth = $dbh->prepare($query);
	$sth->execute();
	while (my ($h, $s) = $sth->fetchrow_array()) {
		printf($tmpfh ">%s\n%s\n", $h, $s)
			or croak("Fatal: Could not write to file $tmpfh\: $!\n");
	}
	$dbh->disconnect();
	return $tmpfh;
}#}}}

# Sub: get_orthologs
# Get orthologous sequences from the database, the final result handler
# Arguments: ortholog id
# Returns: filename
sub get_orthologs {#{{{
	my $orthoid = shift;
	my $estdigest = shift;
	# what do we want from the database?
	my $query = "SELECT DISTINCT
			$mysql_table_orthologs.$mysql_col_orthoid AS orthogroup,
			$mysql_table_taxa.$mysql_col_name	        AS name,
			$mysql_table_ests.$mysql_col_digest       AS EST_digest,
      $mysql_table_aaseqs.$mysql_col_hdr        AS AA_header,
      $mysql_table_aaseqs.$mysql_col_seq        AS AA_seq,
      $mysql_table_ests.$mysql_col_hdr          AS EST_hdr,
      $mysql_table_ests.$mysql_col_seq          AS EST_seq
    FROM $mysql_table_aaseqs
		INNER JOIN $mysql_table_taxa
			ON $mysql_table_aaseqs.$mysql_col_taxid = $mysql_table_taxa.id
    INNER JOIN $mysql_table_blast 
			ON $mysql_table_aaseqs.id = $mysql_table_blast.$mysql_col_target 
    INNER JOIN $mysql_table_hmmsearch 
			ON $mysql_table_blast.$mysql_col_query = $mysql_table_hmmsearch.$mysql_col_target  
    INNER JOIN $mysql_table_ests 
			ON $mysql_table_hmmsearch.$mysql_col_target = $mysql_table_ests.$mysql_col_digest 
    INNER JOIN $mysql_table_orthologs 
			ON $mysql_table_hmmsearch.$mysql_col_query = $mysql_table_orthologs.$mysql_col_orthoid
		INNER JOIN $mysql_table_seqpairs
			ON $mysql_table_orthologs.$mysql_col_seqpair = $mysql_table_seqpairs.id 
		WHERE $mysql_table_orthologs.$mysql_col_orthoid = '$orthoid'
			AND $mysql_table_ests.$mysql_col_digest = '$estdigest'
			AND $mysql_table_seqpairs.$mysql_col_aaseq = $mysql_table_aaseqs.id
		ORDER BY $mysql_table_hmmsearch.$mysql_col_evalue, $mysql_table_blast.$mysql_col_evalue";
	my $dbh = &mysql_dbh();
	my $sql = $dbh->prepare($query);
	$sql->execute();
	my $result = $sql->fetchall_arrayref();
	$dbh->disconnect();
	return $result;
}#}}}

sub insert_orthocandidate {
	my $blah;
}

# Documentation#{{{
=head1 NAME

Orthograph

=head1 DESCRIPTION

F<Ortho>logy prediction using a F<G>raph-based, F<R>eciprocal F<A>pproach with F<P>rofile F<H>idden F<M>odels

=head1 SYNOPSIS

orthograph.pl [OPTIONS]

=head1 DESCRIPTION

Orthograph expects a certain table structure for the core-ortholog set. You may
create it yourself by hand using the following SQL statement or whatever you
fancy, or you may run the provided script orthograph with the B<-c> switch
once, which does the same thing.

  CREATE TABLE core_orthologs (
		id          INT(11) AUTO_INCREMENT PRIMARY KEY,
		taxon       VARCHAR(255) NOT NULL,
		orthoset    VARCHAR(255) NOT NULL,
		hmm         VARCHAR(255) NOT NULL,
		blastdb     VARCHAR(255) NOT NULL, INDEX (blastdb),
		header      VARCHAR(255) NOT NULL, INDEX (header),
		sequence    MEDIUMBLOB)";

=head1 OPTIONS

=head2 -c CONFIGFILE

Use CONFIGFILE instead of orthograph.conf. Any options on the command line override
options set in the config file.

=head1 CONFIG FILE

The configuration file allows to set all options available on the command line
so that the user is spared having to use a very long command every time.

The config file has to be in ini-style: 

	# this is a comment
	translateprog  = fastatranslate
	hmmdir         = /home/malty/thesis/orthograph/hmms
	estfile        = /home/malty/data/cleaned/Andrena_vaga.fa
	mysql_dbname   = orthograph
	mysql_dbserver = localhost
	mysql_dbuser   = root
	mysql_dbpwd    = root
	mysql_table    = ests

etc. Empty lines and comments are ignored, keys and values have to be separated by an equal sign. 

=head2 AVAILABLE OPTIONS:

=head2 estfile

The fasta file containing the EST sequence database.

=head2 hmmsearch_evalue_threshold

e-Value threshold for the HMM search. Must be a number in scientific notation like 1e-05 or something.

=head2 hmmdir

The directory containing the HMM files that are used to search the EST database. See also F<hmmfile>.

=head2 hmmfile

The HMM file to use if you want to run Orthograph on a single HMM.

=head2 hmmsearch_output_dir

The directory name where the hmmsearch output files will be placed.

=head2 hmmsearchprog

The hmmsearch program. On most systems, this is 'hmmsearch', which is the default. Change this if your binary has a different name.

=head2 mysql_dbname

MySQL: Database name. Ask your administrator if you don't know.

=head2 mysql_dbpassword

MySQL: Database password. Ask your administrator if you don't know.

=head2 mysql_dbserver

MySQL: Database server. Normally 'localhost'. Ask your administrator if you don't know.

=head2 mysql_dbuser

MySQL: Database user name. Ask your administrator if you don't know.

=head2 mysql_table_ests

MySQL: Table name for the EST sequences. Ask your administrator if you don't know.

=head2 mysql_table_hmmsearch

MySQL: Table name for the HMMsearch results. Ask your administrator if you don't know.

=head2 mysql_table_blast

MySQL: Table name for the BLAST results. Ask your administrator if you don't know.

=head2 mysql_table_core_orthologs

MySQL: Table name for the core ortholog sequences. Ask your administrator if you don't know.

=head2 output_directory

Output directory to use by Orthograph. It will be created if it does not exist.

=head2 quiet

Quiet operation: Orthograph will retain most of the status messages.

=head2 species_name

Name of the analyzed species. Will occur in the database as well as in all output files in appropriate places.

=head2 hmmsearch_score_threshold

Score threshold for the HMM search. Must be a number.

=head2 translate_program

The tool to use for translation of the EST sequence file. The program must accept a fasta file name as input and provide its output on STDOUT, which is then being redirected into a file that Orthograph uses.

=head2 verbose

Be verbose (output more information about what is going on). 

=head1 AUTHOR

Written by Malte Petersen <mptrsen@uni-bonn.de>

=head1 COPYRIGHT

Copyright (C) 2012 Malte Petersen 

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

=cut
#}}}}
