#!/usr/bin/env perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2012 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write good code
use warnings;       # cry if something seems odd

# Core modules
use Archive::Tar;   # handling tar archives
use Carp;           # alternative warn and die
use Config;         # allows checking for system configuration in $Config
use DBD::mysql;	    # database driver for MySQL
use DBI;	          # MySQL database interface 
use Data::Dumper;   # great for debugging
use Digest::SHA;    # SHA hashing: good idea or not?
use File::Basename; # parse path names
use File::Path qw(make_path remove_tree); # this also uses File::Spec
use File::Temp;     # temporary files
use Getopt::Long;   # parse command line arguments
use IO::Dir;        # object-oriented access to dirs
use IO::File;       # object-oriented access to files
# you might want to look into Log::Message.

# Custom modules
my @path         = fileparse($0);
my $program_file = $path[0];
my $libdir       = $path[1];
use lib qw($libdir);
use Wrapper::Hmmsearch;        # object-oriented interface to hmmsearch
use Wrapper::Blastp;           # object-oriented interface to blastp
use Wrapper::Orthocandidate;	  # manage candidate orthologs via a OO interface
use Seqload::Fasta qw(fasta2csv); # object-oriented access to fasta files, fasta2csv converter

my $program_name = 'Orthograph';
my $version = 'alpha1';
print "$program_name\: Orthology prediction using a Graph-based, ",
	"Reciprocal Approach with Profile Hidden Markov models\n",
	"Copyright 2012 Malte Petersen <mptrsen\@uni-bonn.de>\n",
	"Version $version\n\n";

#--------------------------------------------------
# Only use threads if the system supports it.
# The whole threads system is totally not implemented yet,
# do not attempt to use it!
#-------------------------------------------------- 
my $use_threads = 0;#{{{
if ($use_threads == 1 and $Config{'useithreads'}) {
  print "Using threads.\n\n";
  use Wrapper::Threaded;
}
elsif ($use_threads == 1 and !$Config{'useithreads'}) {
  warn "Warning: Cannot use threads: Your version of Perl was not compiled with threading support. Not using threads.\n\n";
	$use_threads = 0;
}
else {
	print "Not using threads.\n\n";
	$use_threads = 0;
}#}}}

#--------------------------------------------------
# # Config initialisation
#-------------------------------------------------- 
my $config;    # will hold the configuration from config file

#--------------------------------------------------
# # Parse config file
#-------------------------------------------------- 
(my $configfile = $0) =~ s/(\.pl)?$/.conf/;#{{{
# mini argument parser for the configfile
for (my $i = 0; $i < scalar @ARGV; ++$i) {
	if ($ARGV[$i] =~ /-c/) {
		if ($ARGV[$i+1] !~ /^-/) {
		  $configfile = $ARGV[$i+1];
			if (!-e $configfile) { die "Fatal: Config file '$configfile' not found!\n" }
		}
		else { warn "Warning: Config file name '$ARGV[$i+1]' not accepted (use './$ARGV[$i+1]' if you mean it). Falling back to '$configfile'\n" }
	}
}
if (-e $configfile) {
  print "Parsing config file '$configfile'.\n";
  $config = &parse_config($configfile);
}#}}}


#--------------------------------------------------
# # Programs in the order of their use
#-------------------------------------------------- 
my $alignment_program = $config->{'alignment_program'} ? $config->{'alignment_program'} : 'mafft --localpair --maxiterate 1000';#{{{
my $hmmbuild_program  = $config->{'hmmbuild_program'} ? $config->{'hmmbuild_program'} : 'hmmbuild';
my $translateprog     = $config->{'translate_program'} ? $config->{'translate_program'} : 'fastatranslate';
my $hmmsearchprog     = $config->{'hmmsearch_program'} ? $config->{'hmmsearch_program'} : 'hmmsearch';
my $blastprog         = $config->{'blast_program'}     ? $config->{'blast_program'}     : 'blastp';
my $makeblastdbprog   = $config->{'makeblastdb_program'} ? $config->{'makeblastdb_program'}     : 'makeblastdb';#}}}

#--------------------------------------------------
# # These variables can be set in the config file
#-------------------------------------------------- 
#{{{
my $aaoutdir       = $config->{'aaoutdir'}              ? $config->{'aaoutdir'}             : 'aa';
my $backup_ext     = $config->{'backup_extension'}      ? $config->{'backup_extension'}     : '.bak';
my $blast_max_hits = $config->{'blast_max_hits'}        ? $config->{'blast_max_hits'}       : 10;
my $blastoutdir    = $config->{'blastoutdir'}           ? $config->{'blastoutdir'}          : 'blastp';
my $blast_evalue_threshold = $config->{'blast_evalue_threshold'}        ? $config->{'blast_evalue_threshold'}       : 10;
my $blast_score_threshold  = $config->{'blast_score_threshold'}         ? $config->{'blast_score_threshold'}        : 10;
my $clear_data     = defined($config->{'clear_data'})  ? $config->{'clear_data'}           : 1;
my $debug          = $config->{'debug'}                ? $config->{'debug'}                : undef;
my $estfile        = $config->{'estfile'}              ? $config->{'estfile'}              : '';
my $hmmfile        = $config->{'hmmfile'}              ? $config->{'hmmfile'}              : '';
my $hmmoutdir      = $config->{'hmmsearch_output_dir'} ? $config->{'hmmsearch_output_dir'} : basename($hmmsearchprog);
my $hmmsearch_evalue_threshold = $config->{'hmmsearch_evalue_threshold'} ? $config->{'hmmsearch_evalue_threshold'}  : undef;
my $hmmsearch_score_threshold = $config->{'hmmsearch_score_threshold'}      ? $config->{'hmmsearch_score_threshold'}      : undef;
my $mysql_dbname   = $config->{'mysql_dbname'}         ? $config->{'mysql_dbname'}         : 'orthograph';
my $mysql_dbpwd    = $config->{'mysql_dbpassword'}     ? $config->{'mysql_dbpassword'}     : 'root';
my $mysql_dbserver = $config->{'mysql_dbserver'}       ? $config->{'mysql_dbserver'}       : 'localhost';
my $mysql_dbuser   = $config->{'mysql_dbuser'}          ? $config->{'mysql_dbuser'}         : 'root';
my $mysql_table_prefix = $config->{'mysql_table_prefix'} ? $config->{'mysql_table_prefix'} : 'orthograph';
# make sure there is exactly one underscore at the end of the prefix
$mysql_table_prefix =~ s/_*$/_/;

my $mysql_table_blast = $config->{'mysql_table_blast'} ?
	$mysql_table_prefix . $config->{'mysql_table_blast'} :
	$mysql_table_prefix . 'blast';
my $mysql_table_core_orthologs = $config->{'mysql_table_core_orthologs'} ?
	$mysql_table_prefix . $config->{'mysql_table_core_orthologs'} :
	$mysql_table_prefix . 'core_orthologs';
my $mysql_table_blastdbs = $config->{'mysql_table_blastdbs'} ?
	$mysql_table_prefix . $config->{'mysql_table_blastdbs'} :
	$mysql_table_prefix . 'blastdbs';
my $mysql_table_ests = $config->{'mysql_table_ests'} ?
	$mysql_table_prefix . $config->{'mysql_table_ests'} :
	$mysql_table_prefix . 'ests';
my $mysql_table_hmmsearch = $config->{'mysql_table_hmmsearch'} ?
	$mysql_table_prefix . $config->{'mysql_table_hmmsearch'} :
	$mysql_table_prefix . 'hmmsearch';
my $mysql_table_set_details = $config->{'mysql_table_set_details'} ?
	$mysql_table_prefix . $config->{'mysql_table_set_details'} :
	$mysql_table_prefix . 'set_details';
my $mysql_table_aaseqs = $config->{'aaseqs'} ?
	$mysql_table_prefix . $config->{'aaseqs'} :
	$mysql_table_prefix . 'aaseqs';
my $mysql_table_seqpairs       = $config->{'sequence_pairs'} ?
	$mysql_table_prefix . $config->{'sequence_pairs'} :
	$mysql_table_prefix . 'sequence_pairs';
my $mysql_table_taxa       = $config->{'taxa'} ?
	$mysql_table_prefix . $config->{'taxa'} :
	$mysql_table_prefix . 'taxa';
my $mysql_table_orthologs      = $config->{'orthologs'} ?
	$mysql_table_prefix . $config->{'orthologs'} :
	$mysql_table_prefix . 'orthologs';
my $outdir         = $config->{'output_directory'}      ? $config->{'output_directory'}     : undef;
my $orthoset       = $config->{'ortholog_set'}          ? $config->{'ortholog_set'}         : undef;
my $quiet          = $config->{'quiet'}                 ? $config->{'quiet'}                : undef;  # I like my quiet
my $reftaxa        = $config->{'reference_taxa'}        ? $config->{'reference_taxa'}       : undef;
my $sets_dir       = $config->{'sets_dir'}              ? $config->{'sets_dir'}             : 'sets';
my $species_name   = $config->{'species_name'}          ? $config->{'species_name'}         : undef;
my $verbose        = $config->{'verbose'}               ? $config->{'verbose'}              : undef;
#}}}

#--------------------------------------------------
# # More variables
#-------------------------------------------------- 
#{{{
my $count               = 0;
my $blastdb;
my $blastcount;
my $blasthitcount_total;
my $alndir              = '';
my $hmmdir              = '';
my $hmmresultfileref;
my $hmmcount;
my $hmmhitcount;
my $hmmhitcount_total   = 0;
my $listspecies         = 0;
my $mysql_dbi           = "dbi\:mysql\:$mysql_dbname\:$mysql_dbserver";
my $mysql_col_aaseq     = 'aa_seq';
my $mysql_col_blastdbpath   = 'blastdb_path';
my $mysql_col_date      = 'date';
my $mysql_col_end       = 'end';
my $mysql_col_evalue    = 'evalue';
my $mysql_col_start     = 'start';
my $mysql_col_hdr       = 'header';
my $mysql_col_hmm       = 'hmm';
my $mysql_col_id        = 'id';
my $mysql_col_digest    = 'digest';
my $mysql_col_name      = 'name';
my $mysql_col_orthoid   = 'ortholog_gene_id';
my $mysql_col_query     = 'query';
my $mysql_col_score     = 'score';
my $mysql_col_seq       = 'sequence';
my $mysql_col_seqpair   = 'sequence_pair';
my $mysql_col_setid     = 'setid';
my $mysql_col_spec      = 'spec';
my $mysql_col_target    = 'target';
my $mysql_col_taxid     = 'taxid';
my $mysql_col_taxon     = 'taxon';
my $num_ests;
my $num_hmms;
my $orthocount = 0;
my $preparedb;
my $protfile            = '';
my $timestamp_start     = time();
my @lt                  = localtime(time);
my $timestring          = sprintf("%04d-%02d-%02d_%02d:%02d", $lt[5] + 1900, $lt[4] + 1, $lt[3], $lt[2], $lt[1]);
my $tmpdir              = File::Temp->newdir(
                            'UNLINK' => 0, 
                            'TEMPLATE' => File::Spec->catdir($outdir, 'tmpXXXX'));
my @backup;
my @hmmfiles;
my @reftaxa;
my @seqobjs;
#}}}

#--------------------------------------------------
# # Get command line options. These may override variables set in the config file.
#-------------------------------------------------- 
#{{{
GetOptions( 'v'        => \$verbose,
	'c'                  => \$configfile,
  'd'                  => \$debug,
	'threads'            => \$use_threads,   # make using threads optional
	'estfile=s'          => \$estfile,
	'E=s'                => \$estfile,
	'blast_evalue=s'     => \$blast_evalue_threshold,
	'blast_score=s'      => \$blast_score_threshold,
	'hmmsearch_evalue=s' => \$hmmsearch_evalue_threshold,
	'hmmsearch_score=s'  => \$hmmsearch_score_threshold,
	'H=s'                => \$hmmfile,
	'hmmsearchprog=s'    => \$hmmsearchprog,
	'l|list_species'     => \$listspecies,
	'preparedb'          => \$preparedb,
	'quiet'              => \$quiet,
	'taxon=s'            => \$species_name,
) or die("Terminating.\n");#}}}

#--------------------------------------------------
# # Special case: Prepare the MySQL database by dropping and recreating all
# # tables if requested, then exit
#-------------------------------------------------- 
if ($preparedb) {#{{{
	$| = 1;
  print "Setting MySQL database $mysql_dbname to a clean slate... ";
	$| = 0;
  &preparedb;
  print "OK\nMySQL database now ready to run $program_name.\n";
  exit;
}#}}}

#--------------------------------------------------
# # Another special case: List the species for which analysis data is present,
# # then exit
#-------------------------------------------------- 
if ($listspecies) {
	&listspecies;
}

#--------------------------------------------------
# # Normal run. Input error checking, reporting etc
#-------------------------------------------------- 
&intro;

# prepare the HMMs
$hmmdir = &make_hmms($orthoset);
# prepare the BLAST database
$blastdb = &make_blastdb($orthoset);

#--------------------------------------------------
# # create list of reference taxa and HMM files 
#-------------------------------------------------- 
@reftaxa = split(/\s*,\s*/, $reftaxa);	# split by comma
@hmmfiles = &hmmlist($hmmdir);
$num_hmms = scalar(@hmmfiles);


unless ($quiet) {#{{{
  print "Using HMM dir $hmmdir with ", scalar(@hmmfiles), " HMM files.\n" 
    if $hmmdir;
  print "Using HMM file $hmmfile.\n" 
    if $hmmfile;
  print "HMMsearch e-Value cutoff: $hmmsearch_evalue_threshold.\n" 
    if $hmmsearch_evalue_threshold;
  print "Score cutoff: $hmmsearch_score_threshold.\n"
    if $hmmsearch_score_threshold;
}#}}}

#--------------------------------------------------
# # translate the ESTs to protein, feed that stuff to the database
#-------------------------------------------------- 
$protfile = &translate_est(File::Spec->catfile($estfile));#{{{

# clear database of data from the same species
if ($clear_data) {
	print "Clearing database of previous results from '$species_name'...\n" unless $quiet;
	&clear_db;
}
# store est data into the database:
print "Storing translated sequences to MySQL database '$mysql_dbname' on $mysql_dbserver...\n" unless $quiet;

# LOAD DATA INFILE; third arg must be ref to array of column names
$num_ests = &load_data_infile($protfile, $mysql_table_ests, [ $mysql_col_digest, $mysql_col_spec, $mysql_col_date, $mysql_col_hdr, $mysql_col_seq ]);

printf("%d sequences stored to database '%s' on %s. \n",
	$num_ests,
	$mysql_dbname,
	$mysql_dbserver) unless $quiet;

# get number of transcript sequences
$num_ests = &mysql_get("SELECT COUNT(*) FROM $mysql_table_ests WHERE $mysql_col_spec = '$species_name'");
$num_ests = $$num_ests[0][0];
if ($num_ests == 0) {
	warn "No sequences found. Something went wrong. Check your input. Exiting.\n";
	exit;
}
printf "%d sequences in database '%s' on %s. Sequence identifiers have been replaced with SHA256 digests of the combination (header, sequence). These are used for internal purposes.\n", 
	$num_ests,
	$mysql_dbname,
	$mysql_dbserver unless $quiet;

# get the transcripts with their new ID back from the database. TODO is this efficient?
$protfile = &get_transcripts();
#}}}

#--------------------------------------------------
# # Setup the Orthograph modules. These are all class methods.
#-------------------------------------------------- 

# verbose output #{{{
if ($verbose) {
	Wrapper::Hmmsearch->verbose(1);
	Wrapper::Blastp->verbose(1);
}

# debug output
if ($debug) {
	Wrapper::Hmmsearch->debug(1);
	Wrapper::Blastp->debug(1);
}

# score and e-value thresholds
Wrapper::Hmmsearch->evalue_threshold($hmmsearch_evalue_threshold)
	if $hmmsearch_evalue_threshold;
Wrapper::Hmmsearch->score_threshold($hmmsearch_score_threshold)
	if $hmmsearch_score_threshold;
Wrapper::Blastp->evalue_threshold($blast_evalue_threshold)
	if $blast_evalue_threshold;
# there is no score threshold for BLASTP
# but a maximum number of hits to save
Wrapper::Blastp->max_hits($blast_max_hits)
	if $blast_max_hits;

# the output directories
Wrapper::Hmmsearch->outdir($hmmoutdir);
Wrapper::Blastp->outdir($blastoutdir);

# the programs
Wrapper::Hmmsearch->searchprog($hmmsearchprog);
Wrapper::Blastp->searchprog($blastprog);

#}}}

#--------------------------------------------------
# # HMMsearch the protfile using all HMMs
#-------------------------------------------------- 
printf("HMMsearching the protein file using all %d HMMs in %s\:\n", scalar(@hmmfiles), $hmmdir)
	unless $quiet;
$hmmcount = 0;
$hmmhitcount = 0;

HMMFILE:
foreach my $hmmfile (@hmmfiles) {#{{{
	++$hmmcount;
	$blastcount = 0;	# reset counter

	# create new hmmobject with a hmm file, should have all the necessary info for doing hmmsearch
	my $hmmobj = Wrapper::Hmmsearch->new($hmmfile); 

	# now do the hmmsearch on the protfile
	$hmmobj->search($protfile);

	# count the hmmsearch hits
	printf("%4d hits for %s (%2.1f%% complete)\n", 
		$hmmobj->hitcount(),
		basename($hmmobj->hmmfile()),
		($hmmcount * 100 / $num_hmms)) unless $quiet;
	# and do not care further with HMM files that did not return any result
	if ($hmmobj->hitcount() == 0) { 
		next HMMFILE;
	}

	# add hitcount to total number of hmm hits,
	# print list of hits if verbose
	$hmmhitcount_total += $hmmobj->hitcount();
	if ($verbose) {
		my $hits = $hmmobj->hits_arrayref();
		for (my $i = 0; $i < scalar @$hits; $i++) {
			printf "     [%d] %s, e-value %2.1e\n", $i + 1, $hits->[$i]->{'target'}, $hits->[$i]->{'evalue'};
		}
	}

	#--------------------------------------------------
	# # push results to database 
	#-------------------------------------------------- 
	&insert_results_into_table($mysql_table_hmmsearch, $hmmobj->hits_arrayref());
	print "     ... pushed to database.\n" if $verbose;
	++$hmmhitcount;
	
	#--------------------------------------------------
	# # the reciprocal search
	#-------------------------------------------------- 

	# get hmmsearch results from database; use the first array item since they all share the query (HMM) ID 
	my @hmmresults = @{&get_hmmresults($hmmobj->hits_arrayref->[0]{'query'})};

	HMMRESULT:
	for (my $n = 0; $n < scalar(@hmmresults); ++$n) { #{{{
 		++$count;

		# setup a temporary file to hold the sequence to be blasted
		my $tmpfile = File::Temp->new(
			'UNLINK' => 1, 
			# if you unlink it right away, why bother with the template?
			#	...
			# ah, it used to be useful during testing
			'TEMPLATE' => File::Spec->catfile($tmpdir, basename($hmmobj->hmmfile) . '-XXXX'));
		# write fasta header and sequence to the tempfile
		printf($tmpfile ">%s\n%s\n", $hmmresults[$n]->[0], $hmmresults[$n]->[1]);

		#--------------------------------------------------
		# # run blastp 
		#-------------------------------------------------- 
		# shiny new blastp object
		my $blastobj = Wrapper::Blastp->new($blastdb);

		# generate a blast output file name from the HMM name and the hit number
		my $blastoutfile = File::Spec->catfile($blastoutdir, $hmmobj->hmmname . '-' . $hmmresults[$n]->[0] . '-' . basename($blastdb) .  '.blast');

		# do the blastp search; skip if no hits obtained
		$blastobj->blastp($tmpfile, $blastoutfile);

		printf("       %4d BLASTP hits detected for [%d] against %s, e-value below %2.1e\n",
			$blastobj->hitcount,
			$n + 1,
			basename($blastdb),
			$blast_evalue_threshold) if $verbose;

		$blasthitcount_total += $blastobj->hitcount();

		# skip to next if BLAST finds nothing
		if ($blastobj->hitcount() == 0) { next HMMRESULT }

		# insert the blast results into the db. 3-argument form.
		&insert_results_into_table($mysql_table_blast, $blastobj->blasthits_arrayref, basename($blastdb));
		print "            ... pushed to database.\n" if $verbose;
	} #}}}

	if ($hmmcount <= scalar(@hmmfiles) / 100) {
		print "\n(Don't be alarmed, the sequence identifiers are SHA256-hashed but their original label is preserved in the database and will be output at the end. Don't be alarmed)\n\n"
			if $verbose;
	}

	my $orthologs = &get_orthologs($hmmobj->hmmname, $hmmobj->hits_arrayref()->[0]->{'target'});
	next HMMFILE unless defined $$orthologs[0];	# skip empty results

	# write the result to output file
	my $outfh = IO::File->new(File::Spec->catfile($aaoutdir, $$orthologs[0][0] . '.fa'), 'w');
	for (0..$#{$orthologs}) { 
		printf $outfh ">%s:%s:%s\n%s\n", 
			$$orthologs[0][0],  # the ortholog id
			$$orthologs[$_][1],	# the taxon shorthand of the ortholog sequence
			$$orthologs[$_][3],	# the sequence id of the ortholog sequence
			$$orthologs[$_][4]  # the sequence
				or croak "Fatal: Could not write to output file $outfh: $!";
	}
	# the header and sequence of the hit
	# this is the best hit since the SQL query sorts by evalue and we take the first one
	printf $outfh ">%s:%s:%s\n%s\n",
		$$orthologs[0][0],  # the ortholog id
		$species_name,      # the name of the analyzed species 
		# TODO reftaxon id
		$$orthologs[0][5],  # the original sequence id
		$$orthologs[0][6];  # the sequence
	$outfh->close();
	# yay
	++$orthocount;
	printf "!! ^-------Possible orthology detected for %s, confirmed by reciprocal hit! Added to database.\n", $$orthologs[0][0];

	# get the ortholog results from the db
	my $orthocand = Wrapper::Orthocandidate->new($hmmobj->hmmname, $hmmobj->hits_arrayref()->[0]->{'target'});
	Wrapper::Orthocandidate->add($orthocand);

}#}}}	# End hmmlist loop

# report, end the program
printf "\n%s analysis for %s complete.\n", $program_name, $species_name;
printf "Searched %d sequences using %d HMMs.\nObtained %d HMM hits and verified %d as 1:1 orthologs (%2.2f%%).\n",
	$num_ests,
	$hmmcount,
	$hmmhitcount,
	$orthocount,
	((100 * $orthocount) / $hmmcount);
printf "Now go look in your output directory %s.\n", $outdir;

exit;


###################################################
# # Functions 
###################################################

# Sub: mysql_dbh
# Get a database handle
# Arguments: -
# Returns: Database handle
sub mysql_dbh {#{{{
	return DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
}#}}}

# Sub: mysql_get
# Get from the database the result of a SQL query
# Expects: QUERY as a string literal
# Returns: Reference to array of arrays (result lines->fields)
sub mysql_get {#{{{
	my $query = shift;
	unless ($query) { croak "Usage: mysql_get(QUERY)\n" }
  # prepare anonymous array
	my $results = [ ];
  # connect and fetch stuff
	my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
	my $sql = $dbh->prepare($query);
	$sql->execute() or return 0;
	while (my @result = $sql->fetchrow_array() ) {
		push(@$results, \@result);
	}
	$sql->finish();
	$dbh->disconnect; # disconnect ASAP
	return $results;
}#}}}

# Sub: mysql_do
# Connect to a database, execute a single query (for repetitive queries, you better do that by hand).
# Expects: scalar string SQL query. 
# Returns 1 on result, dies otherwise.

sub mysql_do {#{{{
	my $query = shift;
	unless ($query) { croak "Usage: mysql_do(QUERY)\n" }
	my @fields = @_;
	my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
	my $sql = $dbh->prepare($query);
	$sql->execute(@fields) or die;
	$dbh->disconnect();
	return 1;
}#}}}

# Sub: parse_config
# Parse a simple, ini-style config file where keys are separated from values by '='. 
# Sections are not supported. 
# outputdir = /home/foo/bar
sub parse_config {#{{{
	my $file = shift;
	my $conf = { };
	my $fh = IO::File->new($file) or die "Fatal: Coult not open config file '$file'\: $!\n";

	while (my $line = $fh->getline()) {
		next if $line =~ /^\s*$/; # skip empty lines
		next if $line =~ /^\s*#/; # skip comment lines starting with '#'
		if ($line !~ /^\s*\w+\s*=\s*[\/]?\w+/) {
			die "Fatal: Invalid format in line $. of config file $file:\n$line\n"
		}
		
		# split by '=' producing a maximum of two items
		my ($key, $val) = split('=', $line, 2);

		foreach ($key, $val) {
		  s/\s+$//; # remove all trailing whitespace
		  s/^\s+//; # remove all leading whitespace
		}

		die "Fatal: Configuration option '$key' defined twice in line $. of config file '$file'\n"
		  if defined $conf->{$key};
		$conf->{$key} = $val;
	}
	close($fh);
	return $conf;
}#}}}

# Sub: progress_bar
# Returns a wget-style progress bar.
# Arguments: 
sub progress_bar {#{{{
	my ($got, $total, $width, $char) = @_;
	$width ||= 25;
	$char ||= '=';
	my $num_width = length($total);
	$| = 1;
	printf("|%-${width}s| Progress: %${num_width}s of %s (%.2f%%)\r", $char x (($width-1)*$got/$total) . '>', $got, $total, 100*$got/$total);
	$| = 0;
}#}}}

# Sub: intro
# Checks input, file/dir presence, etc.
# Returns True if everything is OK.
sub intro {#{{{
	die "Fatal: Species name needed (-taxon NAME)!\n"
		unless ($species_name);
	
	die "Fatal: Ortholog set name required (ortholog_set)!\n"
		unless ($orthoset);

	# mutually exclusive options
	die "Fatal: Can't operate in both verbose and quiet mode\n"
		if ($verbose and $quiet);

	# mutually exclusive options
	die "Fatal: Can't use both e-value and score thresholds\n"
		if ($hmmsearch_evalue_threshold and $hmmsearch_score_threshold);

	# construct output directory paths
	# outdir may be defined in the config file
	$outdir = defined($outdir) ? $outdir : $species_name;
	$aaoutdir = File::Spec->catdir($outdir, $aaoutdir);
	$hmmoutdir = defined($hmmoutdir) ? File::Spec->catdir($outdir, $hmmoutdir) : File::Spec->catdir($outdir, basename($hmmsearchprog));
  $blastoutdir = defined($blastoutdir) ? File::Spec->catdir($outdir, $blastoutdir) : File::Spec->catdir($outdir, basename($blastprog));

	# the alignment directory (for ortholog set creation)
	unless ($alndir) { $alndir = File::Spec->catdir($sets_dir, $orthoset, 'aln') }
	if (-d $alndir) {
		print "Alignment dir $alndir exists.\n" unless $quiet;
	}
	else {
		print "Alignment dir $alndir does not exist, creating...\n" unless $quiet;
		&makedir($alndir);
	}

	# the HMM directory
	unless ($hmmdir) { $hmmdir = File::Spec->catdir($sets_dir, $orthoset, 'hmms') }
	if (-d $hmmdir) {
		print "HMM dir $hmmdir exists.\n" unless $quiet;
	}
	else {
		print "HMM dir $hmmdir does not exist, creating...\n" unless $quiet;
		&makedir($hmmdir);
	}

	# the EST file
	if (-e $estfile) {
		print "EST file $estfile exists.\n" unless $quiet;
	}
	else {
		die "Fatal: EST file $estfile does not exist!\n";
	}

	# the HMMsearch output directory
	if (-d $hmmoutdir) {
		print "HMMsearch output dir $hmmoutdir exists.\n" unless $quiet;
		if ($clear_data) {
			&cleardir($hmmoutdir);
			print "Purged HMMsearch output dir $hmmoutdir of old result files.\n" unless $quiet;
		}
		else {
			&schedule_for_backup($hmmoutdir);
		}
	}
	else {
		print "HMMsearch output dir $hmmoutdir does not exist, creating...\n" unless $quiet;
		&makedir($hmmoutdir);
	}

  # the BLASTP output directory
  if (-d $blastoutdir) {
    print "BLASTP output dir $blastoutdir exists.\n" unless $quiet;
		if ($clear_data) {
			&cleardir($blastoutdir);
			print "Purged BLAST output dir $blastoutdir of old result files.\n"
				unless $quiet;
		}
		else {
			&schedule_for_backup($blastoutdir);
		}
  }
  else {
    print "BLASTP output dir $blastoutdir does not exist, creating...\n" unless $quiet;
    &makedir($blastoutdir);
  }
	# the aa output directory
	if (-d $aaoutdir) {
		print "AA output dir $aaoutdir exists.\n" unless $quiet;
		if ($clear_data) {
			&cleardir($aaoutdir);
			print "Purged AA output dir $aaoutdir of old result files.\n"
				unless $quiet;
		}
		else {
			&schedule_for_backup($aaoutdir);
		}
	}
	else {
		print "AA output dir $aaoutdir does not exist, creating...\n"
			unless $quiet;
		&makedir($aaoutdir);
	}

	# do the backup; create a tarball if desired
	unless ($clear_data) {
		my $tarfile = &create_tarball(@backup);
		print "Old output files backed up in $tarfile.\n";
		# and clear the directories
		&cleardir($hmmoutdir);
		&cleardir($blastoutdir);
		&cleardir($aaoutdir);
		undef(@backup);	# not needed anymore
		undef($tarfile);
	}

	# does the set exist?
	my $settest = &mysql_get("SELECT *
	FROM $mysql_table_set_details
	WHERE $mysql_col_name = '$orthoset'
	LIMIT 1");
	die("Set '$orthoset' does not exist in database '$mysql_dbname'. Typo in config file $configfile? Use $program_file\_manager first to set up your ortholog sets. Ask your administrator.\n") unless $$settest[0][0];

}#}}}

# Sub: hmmlist
# Expects: scalar string directory path
# Returns: array hmmfiles
sub hmmlist {#{{{
	my $hmmdir = shift;
	if (-e $hmmdir) {
		my $dir = IO::Dir->new(File::Spec->catdir($hmmdir));
		while (my $file = $dir->read()) {
		  push(@hmmfiles, File::Spec->catfile($hmmdir, $file)) if ($file =~ /\.hmm$/);
		}
		$dir->close();
		return(sort(@hmmfiles));
	}
	else {
		print "single hmm\n"
		  if $verbose;
		push(@hmmfiles, $hmmfile);
		return(@hmmfiles);
	}
}#}}}

# Sub: translate_est
# Translate a nucleotide fasta file to protein in all six reading frames
# Expects: scalar string filename
# Returns: scalar string filename (protfile)
sub translate_est {#{{{
  my ($infile) = shift;
  (my $outfile = $infile) =~ s/(\.[^.]*$)/_prot$1/;
  print "Translating $estfile in all six reading frames...\n" unless $quiet;
  if (-e $outfile) {
    print "$outfile exists, using this one.\n" unless $quiet;
    return($outfile);
  }
  my @translateline = qq($translateprog $infile > $outfile);
  system(@translateline) and die();
  return($outfile);
}#}}}

# sub: backup_old_output_files
# input: reference to list of relevant contigs
sub schedule_for_backup {#{{{
  my $outfile = shift @_;
	if (-d $outfile) {	# it's a directory
		my $dirh = IO::Dir->new($outfile);
		while (my $file = $dirh->read()) {
			next if $file =~ /^\./;
			&schedule_for_backup(File::Spec->catfile($outfile, $file));
		}
		$dirh->close();
	}
  elsif (-f $outfile) {
    push(@backup, $outfile);
  }
}#}}}

# sub: create_tarball
# writes a compressed tar archive
# Expects: list of files
# Returns: scalar string tarfilename
sub create_tarball {#{{{
	my @files = @_;
	my $tarfile = File::Spec->catfile($outdir, 'backup-' . $timestring . '.tar.bz2');
	my $tarball = Archive::Tar->new();
	$tarball->setcwd($outdir);
	$tarball->add_files(@files);
	$tarball->write($tarfile, COMPRESS_BZIP) or die("Fatal: Could not create tarball: $!\n");
	return $tarfile;
}#}}}

# Sub: makedir
# Creates a directory with parent directories if it does not already exist
# Expects: scalar string dirname
# Returns: True if successful
sub makedir {#{{{
  my $dir = shift;
  if (-e $dir and not -d $dir) {
    die "Fatal: $dir exists, but is not a directory! This will most likely lead to problems later.\n";
  }
  else {
    make_path $dir, { verbose => 0 } or die "Fatal: Could not create $dir: $!\n";
    return 1;
  }
  return 1;
}#}}}

# Sub: cleardir
# Empties a directory of non-dotfiles
# Arguments: scalar string dirname
sub cleardir {#{{{
	my $dir = shift(@_);
	opendir(my $dirh, $dir)
		or croak("Fatal: Couldn't open dir $dir\: $!");
	foreach (readdir($dirh)) {
		next if $_ =~ /^\.\.?$/;
		unlink(File::Spec->catfile($dir, $_))
			or carp("Warning: Could not delete file " . File::Spec->catfile($dir, $_) . ": $!");
	}
	closedir($dirh)
		or croak("Fatal: Couldn't close dir $dir\: $!");
	return 1;
}#}}}

# Sub: preparedb
# Generate a clean database, deleting all existing tables and starting from scratch
# Returns: True on success
sub preparedb {#{{{
	my $query_create_ests = "CREATE TABLE $mysql_table_ests ( 
		$mysql_col_id        INT NOT NULL AUTO_INCREMENT, INDEX($mysql_col_id),
		$mysql_col_digest    CHAR(32) NOT NULL,           UNIQUE INDEX($mysql_col_digest),
		$mysql_col_spec      VARCHAR(255) NOT NULL,       INDEX($mysql_col_spec),
		$mysql_col_date      INT(11) UNSIGNED,
		$mysql_col_hdr       VARCHAR(255) NOT NULL,       INDEX ($mysql_col_hdr),
		$mysql_col_seq       MEDIUMBLOB DEFAULT NULL)";

	my $query_create_hmmsearch = "CREATE TABLE $mysql_table_hmmsearch (
		$mysql_col_id        INT NOT NULL AUTO_INCREMENT, INDEX($mysql_col_id),
		$mysql_col_spec      VARCHAR(255) NOT NULL,       INDEX($mysql_col_spec),
		$mysql_col_query     VARCHAR(255) NOT NULL,       INDEX($mysql_col_query),
		$mysql_col_target    VARCHAR(255) NOT NULL,       INDEX ($mysql_col_target),
		UNIQUE INDEX($mysql_col_query, $mysql_col_target),
		$mysql_col_score     DOUBLE NOT NULL,
		$mysql_col_evalue    VARCHAR NOT NULL,
		$mysql_col_start     INT(4) NOT NULL,
		$mysql_col_end       INT(4) NOT NULL)";
	
	my $query_create_blast = "CREATE TABLE $mysql_table_blast (
		$mysql_col_id        INT NOT NULL AUTO_INCREMENT, INDEX ($mysql_col_id),
		$mysql_col_spec      VARCHAR(255) NOT NULL,       INDEX ($mysql_col_spec),
		$mysql_col_blastdbpath   VARCHAR(255) NOT NULL,
		$mysql_col_query     VARCHAR(255) NOT NULL,       INDEX ($mysql_col_query),
		$mysql_col_target    VARCHAR(255) NOT NULL,       INDEX ($mysql_col_target),
		UNIQUE INDEX($mysql_col_query, $mysql_col_target),
		$mysql_col_score     DOUBLE NOT NULL,
		$mysql_col_evalue    VARCHAR NOT NULL)";
	
	# open connection
	my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);

	# drop all tables
	foreach ($mysql_table_ests, $mysql_table_hmmsearch, $mysql_table_blast) {
		my $query_drop = "DROP TABLE IF EXISTS $_";
		print "$query_drop;\n" if $verbose;
		my $sql = $dbh->prepare($query_drop);
		$sql->execute()
		  or die "Could not execute SQL query: $!\n";
	}

	# create all tables
	foreach my $query ($query_create_ests, $query_create_hmmsearch, $query_create_blast) {
		printf "$query;\n" if $verbose;
		my $sql = $dbh->prepare($query);
		$sql->execute()
		  or die "Could not execute SQL query: $!\n";
	}

	# disconnect
	$dbh->disconnect();

	return 1;
} #}}}

# Sub: clear_db
# clears the database of previous results from the same species 
sub clear_db {#{{{
	# clear previous results from the same species
	my $query_clear_ests           = "DELETE FROM $mysql_table_ests 
		                                WHERE $mysql_col_spec = '$species_name'";
	my $query_clear_hmmsearch      = "DELETE FROM $mysql_table_hmmsearch 
		                                WHERE $mysql_col_spec = '$species_name'";
	my $query_clear_blast          = "DELETE FROM $mysql_table_blast 
		                                WHERE $mysql_col_spec = '$species_name'";

	# open connection
	my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);

	my $sql = $dbh->prepare($query_clear_ests);
	$sql->execute() or die "$!\n";
	$sql = $dbh->prepare($query_clear_hmmsearch);
	$sql->execute() or die "$!\n";
	$sql = $dbh->prepare($query_clear_blast);
	$sql->execute() or die "$!\n";

	# disconnect ASAP
	$dbh->disconnect;
	return 1;
}#}}}

# Sub: insert_results_into_table
#	inserts the results of either hmmsearch or blastp into a mysql database
# Expects: scalar string TABLENAME, reference to array HITS, scalar string BLASTDATABASE (optional)
# Returns: Number of inserted results (hitcount)
sub insert_results_into_table {#{{{
	my $table = shift;
	my $hits  = shift;
	# may have been called with 3 args, then we are dealing with a blast result
	my $blastdb = (scalar @_ == 1) ? shift : undef;
	if (ref $blastdb) { confess 'Usage: insert_results_into_table($table, $columns_ref, $blastdb)' }
	my $hitcount;
	
	# this is a BLASTP result, we need the column 'blastdb'
	if ($blastdb) {
		my $query_insert_result = "INSERT IGNORE INTO $table (
			`$mysql_col_spec`,
			`$mysql_col_blastdbpath`,
			`$mysql_col_query`,
			`$mysql_col_target`,
			`$mysql_col_score`,
			`$mysql_col_evalue`) VALUES (
			?,
			?,
			?,
			?,
			?,
			?)";
		my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
		my $sql = $dbh->prepare($query_insert_result);

		# this is a reference to an array of hashes
		foreach my $hit (@$hits) {
			$sql->execute(
				$species_name,
				$blastdb,
				$hit->{'query'},  # query (HMM)
				$hit->{'target'}, # target (header)
				$hit->{'score'},  # score
				$hit->{'evalue'}  # evalue
			) or die "Fatal: Could not push to database!\n";
			++$hitcount;
		}
		$dbh->disconnect;
		return $hitcount;
	}
	# this is a HMMsearch result, need 7 columns
	else {
		# SQL query for pushing HMMsearch results to the db
		my $query_insert_result = "INSERT IGNORE INTO $table (
			`$mysql_col_spec`,
			`$mysql_col_query`,
			`$mysql_col_target`,
			`$mysql_col_score`,
			`$mysql_col_evalue`,
			`$mysql_col_start`,
			`$mysql_col_end`) VALUES (
			?,
			?,
			?,
			?,
			?,
			?,
			?)";

		my $dbh = DBI->connect($mysql_dbi, $mysql_dbuser, $mysql_dbpwd);
		my $sql = $dbh->prepare($query_insert_result);

		# this is a reference to an array of hashes
		foreach my $hit (@$hits) {
			$sql->execute(
				$species_name,
				$hit->{'query'},  # query (HMM)
				$hit->{'target'}, # target (header)
				$hit->{'score'},  # score
				$hit->{'evalue'}, # evalue
				$hit->{'start'},	# start of hit domain
				$hit->{'end'}			# end of hit domain
			) or die "Fatal: Could not push to database!\n";
			++$hitcount;
		}
		$dbh->disconnect;
		return $hitcount;
	}
}#}}}

# Sub: get_blastdir_for
# returns the BLASTP database path for a given reference taxon
# Expects: scalar string REFTAXON
# Returns: scalar string PATH TO BLASTDB
sub get_blastdir_for {#{{{
	my $query = "SELECT $mysql_table_blastdbs.blastdb_path FROM $mysql_table_blastdbs INNER JOIN $mysql_table_set_details ON $mysql_table_set_details.id = $mysql_table_blastdbs.setid LIMIT 1";
	my $result = &mysql_get($query);
	my $blastdir = File::Spec->catfile($$result[0][0], $orthoset);
	return $blastdir;
}#}}}

# Sub: file_is_empty
# tests whether a file is empty (i.e., contains nothing or only empty lines)
# Expects: scalar string path to file
# Returns: True if file is empty, false otherwise
sub file_is_empty {
	my $file = shift;
	my $fh = IO::File->new($file);
	while (<$fh>) {
		/^\s*$/ ? next : return 0;	# skip empty lines
	}
	return 1;
}

# Sub: make_hmms
# Generate HMMs for a given core-ortholog set
# Arguments: scalar string ortholog set name
# Returns: True if successful
sub make_hmms {#{{{
	my $set = shift;
	my $hmmsuffix = '.hmm';
	my $data = {};
	my $query = "SELECT o.$mysql_col_orthoid, a.id, a.$mysql_col_seq
		FROM $mysql_table_orthologs AS o
    INNER JOIN $mysql_table_seqpairs AS p
    ON o.$mysql_col_seqpair = p.id
    INNER JOIN $mysql_table_aaseqs AS a
    ON a.id = p.$mysql_col_aaseq
    INNER JOIN $mysql_table_set_details AS d
    ON d.id = o.$mysql_col_setid
    WHERE d.$mysql_col_name = '$set'";

	# does the alignment dir exist?
	if (!-e $alndir) {
		&makedir($alndir);
	}
	# does the HMM dir exist?
	if (!-e $hmmdir) {
		&makedir($hmmdir);
	}
	print "Generating ortholog set $set...  This may take a long time, please be patient.\n" unless $quiet;

	# get the ortholog set from the database
	my $dbh = &mysql_dbh();
	my $sql = $dbh->prepare($query);
	$sql->execute() or die;
	while (my @row = $sql->fetchrow_array()) {
		# load the whole set into memory, i don't give a frak
		$$data{$row[0]}{$row[1]} = $row[2];
	}
	$dbh->disconnect();	# disc asap

	my $num_orthoids = scalar(keys(%$data));
	my $o = 0;
	foreach my $orthoid (keys(%$data)) {
		&progress_bar($o, $num_orthoids, 25, '-');
		++$o;
		my $hmmfile = File::Spec->catfile($hmmdir, $orthoid . $hmmsuffix);

		# does this HMM already exist?
		# if so, skip to the next
		if (-e $hmmfile and !&file_is_empty($hmmfile)) { next }

		# if it exists, but the file is empty (this happens if you cancel the build
		# process), rebuild this HMM
		elsif (-e $hmmfile and &file_is_empty($hmmfile)) { warn("Warning: Rebuilding HMM for $orthoid due to empty HMM file\n") }

		# no, create new fasta file and so on
		my $fafile = File::Spec->catfile($alndir, $orthoid . '.fa');
		my $fafh = IO::File->new($fafile, 'w');
		foreach my $id (keys(%{$data->{$orthoid}})) {
			printf($fafh ">%s\n%s\n", $id, $$data{$orthoid}{$id})
				or die("Fatal: Could not write to file '$fafh'\: $!\n");
		}
		$fafh->close();

		# align
		my $alnfile = &align($fafile, $orthoid)
			or die("Fatal: Alignment failed for '$fafh'\: $!\n");

		# convert to stockholm
		my $stockhfile = &fasta2stockholm($alnfile, $orthoid)
			or die("Fatal: Conversion to Stockholm format failed for '$alnfile'\: $!\n");

		# build HMM
		&hmmbuild($stockhfile, $hmmfile)
			or die("Fatal: HMM generation failed for '$alnfile'\: $!\n");
	}
	undef($data);	# free memory... well, it's bound to go out of scope anyway
	return($hmmdir);
}#}}}

# Sub: align
# Generate a fasta alignment from a fasta file
# Arguments: Scalar string filename, scalar string setname
# Returns: Scalar string alignment filename on success, false otherwise
sub align {#{{{
	my $fafile = shift;
	my $orthoid = shift;
	(my $fasuffix = $fafile) =~ /(\.(fa|fas|fasta))/;
	my $alnsuffix = '.aln';
	my @alignment_cmd = qq($alignment_program $fafile 2> /dev/null);	# this prints the alignment to STDOUT, must be captured somehow
	print "@alignment_cmd\n" if $debug;
	my $alnf = File::Spec->catfile($alndir, $orthoid . '.aln.fa');
	my $alnfh = IO::File->new($alnf, 'w');
	print $alnfh `@alignment_cmd`
		or croak("Fatal: Could not write to file $alnf\: $!\n");
	$alnfh->close();
	return $alnf;
}#}}}

# Sub: fasta2stockholm
# Converts a fasta file into a stockholm file. Warning: Does no validity checking whatsoever!
# Arguments: Scalar string filename
# Returns: Scalar string filename
sub fasta2stockholm {#{{{
	my $fafile = shift;
	my $orthoid = shift;
	my $fh = Seqload::Fasta->open($fafile);
	my $stockhf = File::Spec->catfile($alndir, $orthoid . '.stockh');
	my $stockhfh = IO::File->new($stockhf, 'w');
	print $stockhfh "# STOCKHOLM 1.0\n";
	while (my ($h, $s) = $fh->next_seq()) {
		printf($stockhfh "%-50s %s\n", $h, $s)
			or croak("Fatal: Could not write to file $stockhfh\: $!");
	}
	print $stockhfh "//";
	close($stockhfh);
	return $stockhf;
}#}}}

# Sub: hmmbuild
# Generates a hidden Markov model (HMM) file from an alignment (fasta) file.
# Arguments: Scalar string filename, scalar string setname
# Returns: True on success, false otherwise
sub hmmbuild {#{{{
	my $alnfile = shift;
	my $hmmfile = shift;
	my $alnsuffix = '.aln';
	my $hmmsuffix = '.hmm';
	my $hmmname = basename($hmmfile, $hmmsuffix);
	my @hmmbuild_cmd = qq($hmmbuild_program -n $hmmname $hmmfile $alnfile > /dev/null);
	system(@hmmbuild_cmd) and
		return 0;
	return $hmmfile;
}#}}}

# Sub: make_blastdb 
# Create a BLAST database from a file. Pulls everything from the MySQL database.
# Arguments: Scalar string ortholog set name
# Returns: Scalar string path_to_blastdbfile
sub make_blastdb {#{{{
	my $setname = shift or croak('Usage: make_blastdb($setname)');

	# build the paths for input and output
	my $blastpath = &mysql_get("SELECT DISTINCT $mysql_col_blastdbpath
		FROM $mysql_table_blastdbs
		INNER JOIN $mysql_table_set_details
		ON $mysql_table_set_details.name = '$setname'
		LIMIT 1");
	my $dbfile = File::Spec->catfile($sets_dir, $setname, 'blast', $setname);
	my $infile = File::Spec->catfile($dbfile . ".fa");

	# check whether a database already exists
	if (-e File::Spec->catfile($dbfile . '.psq')) {
		print "BLAST DB for set $setname exists in $dbfile.\n"
			unless $quiet;
		return $dbfile;
	}

	# database not extant, we have to create it
	$| = 1;
	print "BLAST DB for set $setname does not exist, creating in $dbfile... "
		unless $quiet;
	$| = 0;
	# get the sequences from the database
	my $query = "SELECT $mysql_table_aaseqs.id, $mysql_table_aaseqs.sequence
		FROM $mysql_table_aaseqs
		INNER JOIN $mysql_table_seqpairs
		ON $mysql_table_seqpairs.aa_seq = $mysql_table_aaseqs.id
		INNER JOIN $mysql_table_orthologs
		ON $mysql_table_orthologs.sequence_pair = $mysql_table_seqpairs.id
		INNER JOIN $mysql_table_set_details
		ON $mysql_table_set_details.id = $mysql_table_orthologs.setid
		WHERE $mysql_table_set_details.name = '$setname'";
	my $infh = File::Temp->new();
	my $dbh = &mysql_dbh();
	my $sth = $dbh->prepare($query);
	$sth->execute();
	# write to output file
	while (my ($h, $s) = $sth->fetchrow_array()) {
		# make sure the sequence has only valid characters
		if ($s !~ /^[ACDEFGHIKLMNPQRSTVWXYZUX]+$/) {
			warn("Warning: Invalid characters in protein sequence $h. Let's hope BLAST will not choke on this one:\n$s");
		}
		printf($infh ">%s\n%s\n", $h, $s)
			or croak("Fatal: Could not write to file $infile\: $!\n");
	}
	$dbh->disconnect();
	close($infh);

	# make blast database
	my @makeblastdbcmd = qq($makeblastdbprog -in $infh -out $dbfile -input_type fasta -dbtype prot -title $orthoset > /dev/null);
	system(@makeblastdbcmd) and croak("Fatal: makeblastdb failed: $!\n");
	print "\n";
	return $dbfile;
}#}}}

# Sub: load_data_infile
# LOAD DATA LOCAL INFILE into a table
# Arguments: scalar string filename, scalar string tablename, reference to list of columns
# Returns: scalar int number of loaded rows
sub load_data_infile {#{{{
	my $protfile = shift(@_);
	my $table = shift(@_) or croak 'Usage: &load_data_infile($protfile, $mysql_table_ests [, $columns_reference])';
	my $columns;
	my $list;
	if (scalar(@_)) {
		$columns = shift(@_);
		unless (ref($columns)) {
			croak 'Usage: &load_data_infile($protfile, $mysql_table_ests [, $columns_reference])';
		}
		$list = join(',', @$columns);
	}

	# Create temporary csv file for high-speed reading into database
	my $tmpfh = File::Temp->new('UNLINK' => 0, 'TEMPLATE' => File::Spec->catfile('/tmp', 'XXXX'));
	my $protfh = Seqload::Fasta->open($protfile);
	while (my ($h, $s) = $protfh->next_seq()) {
		$h =~ s/,/ /g;	# remove all commas, they confuse the csv parser
		$s =~ s/-//g;	# remove all gaps from the sequence
		if ($s =~ /([^ACDEFGHIKLMNPQRSTVWYX*])/i) {
			warn("Warning: Sequence $h contains nonstandard amino acid symbol '$1'! Make sure your alignment program tolerates this.\n");
		}
		printf($tmpfh "%s,%s,%d,%s,%s\n", 
			# good idea or not?
			Digest::SHA->sha256_hex($h, $s),
			$species_name,
			$timestamp_start,
			$h,
			$s
		);
	}
	$tmpfh->close();
	# no need to close the protfh since we're already through it, it gets closed automagically

	# load data from csv file into database
	my $query = "LOAD DATA LOCAL INFILE '$tmpfh' INTO TABLE $table FIELDS TERMINATED BY ',' ($list)";

	# open connection
	my $dbh = &mysql_dbh();
	$num_ests = $dbh->do($query);
	# disconnect ASAP
	$dbh->disconnect;
	defined($DBI::errstr) ? warn($DBI::errstr, "\n") : print "OK\n";
	return $num_ests;
}#}}}

# Sub: get_transcripts 
# Get transcript sequences from the database, using their ID as header
# Arguments: None
# Returns: Filehandle
sub get_transcripts {#{{{
	my $tmpfh = File::Temp->new('UNLINK' => 0, 'TEMPLATE' => File::Spec->catfile($tmpdir, 'XXXX'));
	my $query = "SELECT $mysql_col_digest, $mysql_col_seq FROM $mysql_table_ests WHERE $mysql_col_spec = '$species_name'";
	my $dbh = &mysql_dbh();
	my $sth = $dbh->prepare($query);
	$sth->execute();
	while (my ($h, $s) = $sth->fetchrow_array()) {
		printf($tmpfh ">%s\n%s\n", $h, $s)
			or croak("Fatal: Could not write to file $tmpfh\: $!\n");
	}
	$dbh->disconnect();
	return $tmpfh;
}#}}}

# Sub: get_hmmresults
# Get hmmsearch results from the database.
# Arguments: scalar string hmmsearch query
# Returns: reference to array of arrays
sub get_hmmresults {#{{{
	my $hmmquery = shift;
	my $query_get_sequences = "SELECT $mysql_table_ests.$mysql_col_digest, $mysql_table_ests.$mysql_col_seq
		FROM $mysql_table_ests 
		INNER JOIN $mysql_table_hmmsearch
		ON $mysql_table_hmmsearch.$mysql_col_target = $mysql_table_ests.$mysql_col_digest
		WHERE $mysql_table_hmmsearch.$mysql_col_query = '" . $hmmquery . "'";

	# get the sequences from the database (as array->array reference)
	my $results = &mysql_get($query_get_sequences);
	return($results);
}#}}}

# Sub: get_orthologs
# Get orthologous sequences from the database, the final result handler
# Arguments: ortholog id
# Returns: filename
sub get_orthologs {#{{{
	my $orthoid = shift;
	my $estdigest = shift;
	# what do we want from the database?
	my $query = "SELECT DISTINCT
			$mysql_table_orthologs.$mysql_col_orthoid AS orthogroup,
			$mysql_table_taxa.$mysql_col_name	        AS name,
			$mysql_table_ests.$mysql_col_digest       AS EST_digest,
      $mysql_table_aaseqs.$mysql_col_hdr        AS AA_header,
      $mysql_table_aaseqs.$mysql_col_seq        AS AA_seq,
      $mysql_table_ests.$mysql_col_hdr          AS EST_hdr,
      $mysql_table_ests.$mysql_col_seq          AS EST_seq
    FROM $mysql_table_aaseqs
		INNER JOIN $mysql_table_taxa
			ON $mysql_table_aaseqs.$mysql_col_taxid = $mysql_table_taxa.id
    INNER JOIN $mysql_table_blast 
			ON $mysql_table_aaseqs.id = $mysql_table_blast.$mysql_col_target 
    INNER JOIN $mysql_table_hmmsearch 
			ON $mysql_table_blast.$mysql_col_query = $mysql_table_hmmsearch.$mysql_col_target  
    INNER JOIN $mysql_table_ests 
			ON $mysql_table_hmmsearch.$mysql_col_target = $mysql_table_ests.$mysql_col_digest 
    INNER JOIN $mysql_table_orthologs 
			ON $mysql_table_hmmsearch.$mysql_col_query = $mysql_table_orthologs.$mysql_col_orthoid
		INNER JOIN $mysql_table_seqpairs
			ON $mysql_table_orthologs.$mysql_col_seqpair = $mysql_table_seqpairs.id 
		WHERE $mysql_table_orthologs.$mysql_col_orthoid = '$orthoid'
			AND $mysql_table_ests.$mysql_col_digest = '$estdigest'
			AND $mysql_table_seqpairs.$mysql_col_aaseq = $mysql_table_aaseqs.id
		ORDER BY $mysql_table_hmmsearch.$mysql_col_evalue, $mysql_table_blast.$mysql_col_evalue";
	my $dbh = &mysql_dbh();
	my $sql = $dbh->prepare($query);
	$sql->execute();
	my $result = $sql->fetchall_arrayref();
	$dbh->disconnect();
	return $result;
}#}}}

sub insert_orthocandidate {
	my $blah;
}

__END__

# Documentation#{{{
=head1 NAME

Orthograph

=head1 DESCRIPTION

F<Ortho>logy prediction using a F<G>raph-based, F<R>eciprocal F<A>pproach with
F<P>rofile F<H>idden F<M>odels

=head1 SYNOPSIS

orthograph [OPTIONS]

=head1 WARNING

B<This documentation is outdated!> It will catch up with recent development on
another day. However, careful work has been put into the README file, which
also contains a quickstart guide. Please refer to that. 

=head1 DESCRIPTION

Orthograph expects a certain table structure for the core-ortholog set. You may
run the provided script orthograph_manager with the B<-c> switch once, which
does exactly that.

=head1 OPTIONS

=head2 -c CONFIGFILE

Use CONFIGFILE instead of orthograph.conf. Any options on the command line override
options set in the config file.

=head2 -v

Verbose output. More information about the HMMsearch and BLAST hits. Normally
you don't want to see this. If you are really interested in what Orthograph is
thinking during the analysis, uncomment this. Verbose and quiet are mutually
exclusive.

=head2 -q

Quiet output. Uncomment this if you don't want to be bothered during the
analysis. Verbose and quiet are mutually exclusive.

No other options documented yet. Use the config file, please.

=head1 CONFIG FILE

The configuration file allows to set all options available on the command line
so that the user is spared having to use a very long command every time.

The config file has to be in ini-style: 

	# this is a comment
	translateprog  = fastatranslate
	hmmdir         = /home/malty/thesis/orthograph/hmms
	estfile        = /home/malty/data/cleaned/Andrena_vaga.fa
	mysql_dbname   = orthograph
	mysql_dbserver = localhost

etc. Empty lines and comments are ignored, keys and values have to be separated
by an equal sign. 

For your convenience, there is an example config file provided in this package.
You may customize it to your local environment.

=head2 AVAILABLE OPTIONS:

=head2 estfile

The fasta file containing the EST sequence database.

=head2 hmmsearch_evalue_threshold

e-Value threshold for the HMM search. Must be a number in scientific notation
like 1e-05 or something.

=head2 hmmdir

The directory containing the HMM files that are used to search the EST
database. See also F<hmmfile>.

=head2 hmmfile

The HMM file to use if you want to run Orthograph on a single HMM.

=head2 hmmsearch_output_dir

The directory name where the hmmsearch output files will be placed.

=head2 hmmsearchprog

The hmmsearch program. On most systems, this is 'hmmsearch', which is the
default. Change this if your binary has a different name.

=head2 mysql_dbname

MySQL: Database name. Ask your administrator if you don't know.

=head2 mysql_dbpassword

MySQL: Database password. Ask your administrator if you don't know.

=head2 mysql_dbserver

MySQL: Database server. Normally 'localhost'. Ask your administrator if you
don't know.

=head2 mysql_dbuser

MySQL: Database user name. Ask your administrator if you don't know.

=head2 mysql_table_ests

MySQL: Table name for the EST sequences. Ask your administrator if you don't
know.

=head2 mysql_table_hmmsearch

MySQL: Table name for the HMMsearch results. Ask your administrator if you
don't know.

=head2 mysql_table_blast

MySQL: Table name for the BLAST results. Ask your administrator if you don't
know.

=head2 mysql_table_core_orthologs

MySQL: Table name for the core ortholog sequences. Ask your administrator if
you don't know.

=head2 output_directory

Output directory to use by Orthograph. It will be created if it does not exist.

=head2 quiet

Quiet operation: Orthograph will retain most of the status messages.

=head2 species_name

Name of the analyzed species. Will occur in the database as well as in all
output files in appropriate places.

=head2 hmmsearch_score_threshold

Score threshold for the HMM search. Must be a number.

=head2 translate_program

The tool to use for translation of the EST sequence file. The program must
accept a fasta file name as input and provide its output on STDOUT, which is
then being redirected into a file that Orthograph uses.

=head2 verbose

Be verbose (output more information about what is going on). 

=head1 AUTHOR

Written by Malte Petersen <mptrsen@uni-bonn.de>

=head1 COPYRIGHT

Copyright (C) 2012 Malte Petersen 

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details. You
should have received a copy of the GNU General Public License along with this
program; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
Suite 330, Boston, MA 02111-1307 USA

=cut
#}}}}
