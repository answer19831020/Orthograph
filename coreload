#!/usr/bin/perl
# Documentation before the code#{{{
=head1 NAME 

B<coreload> - prepare a MySQL database for running Forage

=head1 SYNOPSIS

B<coreload> FASTAFILE

=head1 DESCRIPTION

Prepares a core orthologs database for running Forage. Basically, reads a fasta
file and loads its content into a temporary table. Due to the usage of the
MySQL LOAD INFILE routine, this process is pretty fast. After that, the content
is processed and distributed into the Forage database structure.

This script is designed to work with fasta files generated by OrthoDB5
(http://cegg.unige.ch/orthodb5). Therefore, the headers have to be formatted
in a certain way:

  >TAXSH:xxxxxx SomeIdentifier EOG5XXXXX OriginalIdentifier 

Where the following applies: 

=over 2

=item * TAXSH is the 5-letter taxon shorthand that OrthoDB uses

=item * SomeIdentifier is just some other identifier (I haven't figured out what this corresponds to)

=item * EOG5XXXXX is the OrthoDB ID. This will later be used to cluster the orthologs together.

=item * OriginalIdentifier is the original (i.e. official gene set) identifier for this particular orthologous sequence.

=back

None of these need to be unique, but the combination of all three must be.

The fields must be separated by whitespace and in this particular order. The
coreload script does not perform any recognition on the fields whatsoever. If
you download your orthologous sequences from OrthoDB, no problems should arise.

B<coreload> expects a certain table structure. You may create it by hand using
the SQL statement found at the end of this manual by or whatever workflow you
fancy, or you may run B<coreload -c> once, which does the same thing.


=cut#}}}

use strict;
use warnings;
use Carp;
use Getopt::Long;
use File::Temp;     # temporary files
use File::Spec;
use Seqload::Fasta qw(fasta2csv); # object-oriented access to fasta files, fasta2csv converter
use DBI;
use DBD::mysql;
use Seqload::Fasta;


my $dbname       = 'forage';
my $dbserver     = '127.0.0.1';
my $username     = undef;
my $name         = undef;
my $pwd          = undef;
my $setname      = undef;
my $prefix       = 'forage_';
my $blastdir     = '';
my $create       = 0;
my $overwrite    = 0;
my $temptable    = 'temp';
my @tables       = qw(
	blast_dbs
	ogs
	ortholog_set
	sequence_pairs
	sequences_aa
	sequences_nt
	set_details
	taxa
	usernames
	temp
);
my %names;
my $description;
my $ogs_name;


#{{{POD: Options
=head1 OPTIONS

=head2 -p password

Password for the connection. No default; this must be set.

=head2 -t temptable

Temporary table name to use. Defaults to 'temp'.

=head2 -u usernamename

Username for the connection. No default; this must be set.

=head2 -c

(Re-)creates the necessary table structure. Careful, this will wipe out everything
you had in the table. You should not do this more than once in the process of using
Forage unless you know what you are doing.

=head2 -D database

Database name to use. Defaults to 'forage'.

=head2 -h host

Database server. Defaults to '127.0.0.1', which is (mostly) equivalent to
'localhost'.

=head2 -b /blast/database/prefix

BLAST database prefix. Must point to a directory containing the BLAST databases. These themselves must be each in its own directory, e.g., like so:

  /home/username/blast/apismellifera
  /home/username/blast/drosophilamelanogaster

The directory name of each BLAST database must match with the taxon name in the fasta headers, and the BLAST database inside it must be named as F<taxon_prot>.

If all is setup like described, the prefix would be specified as: B<-b /home/username/blast>.

=cut#}}}

GetOptions(
	'D=s'      => \$dbname,
	'prefix=s' => \$prefix,
	'blastdir=s' => \$blastdir,
	'c'        => \$create,
	'h=s'      => \$dbserver,
	'n=s'      => \$name,
	'o'        => \$overwrite,
	'p=s'      => \$pwd,
	's=s'      => \$setname,
	't=s'      => \$temptable,
	'u=s'      => \$username,
	);
my $infile = shift @ARGV;

# make sure there is at least one underscore at the end of the prefix
$prefix =~ s/_$//;
$prefix .= '_';
# prepend the prefix to the table names. useful for dropping all of 'em.
@tables = map { $prefix.$_ } @tables;

# name == username unless defined name
$name = $username unless defined($name);

# to start off with nt and aa sequence types
my $insert_seqtypes = "INSERT INTO " . $prefix . "seqtypes (string) VALUES ('nt'),('aa')";

# the queries for the individual tables
my %create_table = (#{{{
	# table: blast_dbs
	'blast_dbs' => "CREATE TABLE `" . $prefix . "blast_dbs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxon_id`     INT(10) UNSIGNED DEFAULT NULL,
    `blastdb_path` VARCHAR(255) DEFAULT NULL)",
	
	# table: ogs
	'ogs' => "CREATE TABLE `" . $prefix . "ogs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `type`         CHAR(3),
    `taxid`        INT(10) UNSIGNED,
    `version`      VARCHAR(255))",
	
	# table: ortholog_set
	'ortholog_set' => "CREATE TABLE `" . $prefix . "ortholog_set` (
    `id`               INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `setname`          INT(10) UNSIGNED,
    `ortholog_gene_id` INT(10) UNSIGNED,
    `sequence_pair`    INT(10) UNSIGNED)",

	# table: sequence_pairs
	'sequence_pairs' => "CREATE TABLE `" . $prefix . "sequence_pairs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxon_id`     INT(10) UNSIGNED,
    `ogs_id`       INT(10) UNSIGNED,
    `aa_seq`       INT(10) UNSIGNED,
    `nt_seq`       INT(10) UNSIGNED,
    `date`         INT(10) UNSIGNED,
    `username`     INT(10) UNSIGNED)",

	# table: sequences_aa
	'sequences_aa' => "CREATE TABLE `" . $prefix . "sequences_aa` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxid`        INT(10),
    `header`       VARCHAR(255), INDEX(header),
    `sequence`     MEDIUMBLOB,
    `username`     INT(10) UNSIGNED,
    `date`         INT(10) UNSIGNED )",

	# table: sequences_nt
	'sequences_nt' => "CREATE TABLE `" . $prefix . "sequences_nt` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxid`        INT(10),
    `header`       VARCHAR(255), INDEX(header),
    `sequence`     MEDIUMBLOB,
    `username`     INT(10) UNSIGNED,
    `date`         INT(10) UNSIGNED )",

	# table: set_details
	'set_details' => "CREATE TABLE `" . $prefix . "set_details` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(255),
    `description`  TINYBLOB)",

	# table: taxa
	'taxa' => "CREATE TABLE `" . $prefix . "taxa` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(20),
    `longname`     VARCHAR(255))",
	
	# table: usernames
	'usernames' => "CREATE TABLE `" . $prefix . "usernames` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(255), INDEX(name))",
	# table: seqtypes
	'seqtypes' => "CREATE TABLE `" . $prefix . "seqtypes` (
		`id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
		`string`       CHAR(4))",
);#}}}

unless (defined $username and defined $pwd ) {
	die "Fatal: You must specify database usernamename (-u) and password (-p) AND core-ortholog set name (-s).\n";
}

#--------------------------------------------------
# # if you only want me to create the tables, fine. this will give you a clean slate.
#-------------------------------------------------- 
if ($create) {
	&create_tables;
	print "OK.\n";
	exit;
}

#--------------------------------------------------
# # otherwise, continue and gather information
#-------------------------------------------------- 

# TODO stop here if db structure is not present!

$infile or die "Usage: $0 FASTAFILE\n";
print "Setting up core ortholog set in $dbname on $dbserver... (press CTRL+C to abort)\n";
unless ($setname) {
	print "Enter a name for the set (required): ";
	$setname = <STDIN>;
	chomp $setname;
}
if (&mysql_check("SELECT name FROM " . $prefix . "set_details WHERE name = '$setname'")) {
	warn "Warning: An ortholog set with this name already exists in $dbname on $dbserver.\n";
	unless ($overwrite) {
		die "Pick a different name or use -o for overwriting.\n";
	}
	print "Overwriting existing entries (may cause data disintegration)\n";
	$| = 1;
	print "Are you sure (y/n)? ";
	$| = 0;
	my $yn = readline(STDIN);
	chomp $yn;
	unless ($yn eq 'y') {
		print "OK, exiting.\n";
		exit;
	}
}

unless ($blastdir) {
	print "Enter the location where the BLAST database directories are located (required): ";
	$blastdir = <STDIN>;
	chomp $blastdir;
}
print "Enter a description for the set (optional but recommended): "; 
$description = <STDIN>;
chomp $description;

unless (defined $setname) { croak "Fatal: You must specify the core-ortholog set name (-s).\n" }

#--------------------------------------------------
# # read the input file and create a CSV file with everything we know 
#-------------------------------------------------- 

my $tmpfile = File::Temp->new();

my $faobj = Seqload::Fasta->open($infile);
no warnings;	# disable warnings for printing of the NULL column
while (my ($hdr, $seq) = $faobj->next_seq()) {
	my @line = split(/\s+/, $hdr, 5);	# maximum of five fields, the last one may contain whitespace
	$line[0] =~ s/:.*//;	# remove everything from the colon
	printf $tmpfile "%s,%s,%s,%s,%s,%s,%s,%s\n", 
		$line[0],     # taxon shorthand
		undef,        # this will later be the full name
		$setname,	    # set name
		$line[2],     # orthodb id, e.g. EOG500001
		File::Spec->catfile($blastdir, $line[0], $line[0] . '_prot'), # blast database for this taxon, may change later
		$line[3],     # original proteome id
		$seq,         # sequence
		$description; # set description
}
use warnings;
$faobj->close();

#--------------------------------------------------
# # create a temporary table for high-speed loading of the data. we can sort it out later.
#-------------------------------------------------- 

# for each sequence, load into the db, taking into account the following:
# a) record its id
# b) where it comes from (orthodb set id)
# c) etc
# btw fuck you

my $create_temp_table_query = "CREATE TABLE $temptable (
    `name`     VARCHAR(255), INDEX(name),
    `longname` VARCHAR(255),
		`orthoset` VARCHAR(255),
		`hmm`      VARCHAR(255),
		`blastdb`  VARCHAR(255),
		`header`   VARCHAR(255),
		`sequence` VARCHAR(255),
		`description` VARCHAR(255))";
my $loadquery = "LOAD DATA LOCAL INFILE '$tmpfile' IGNORE 
  INTO TABLE $temptable FIELDS TERMINATED BY ',' (
		name,
		longname,
		orthoset,
		hmm,
		blastdb,
		header,
		sequence,
		description)";

my $dbh = DBI->connect("DBI:mysql:$dbname:$dbserver", $username, $pwd);
$dbh->do("DROP TABLE IF EXISTS $temptable") or die "Could not DROP TABLE $temptable: $!\n";
$dbh->do($create_temp_table_query) or die "Could not CREATE TABLE $temptable: $!\n";
my $sql = $dbh->prepare($loadquery);
$sql->execute() or die;
$sql->finish();
$dbh->disconnect;

print "Successfully loaded $infile into $temptable on $dbserver.\n";

# get name and longname from the temp table; they do not get updated automatically
$dbh = DBI->connect("DBI:mysql:$dbname:$dbserver", $username, $pwd);
$sql = $dbh->prepare("SELECT DISTINCT name, longname FROM temp");
$sql->execute();
while (my @result = $sql->fetchrow) {
	$names{$result[0]} = '';
}
$dbh->disconnect;

# ask the username for the taxon names
foreach (sort(keys %names)) {
	unless ($names{$_}) {
		print "Enter complete name for the shorthand '$_': ";
		$names{$_} = <STDIN>;
		chomp $names{$_};
	}
}

# update the temptable with the collected info
$dbh = &mysql_dbh;
foreach (keys %names) {
	$sql = $dbh->prepare("UPDATE $temptable SET longname='" . $names{$_} . "' WHERE name='" . $_ . "'");
	$sql->execute();
}
$dbh->disconnect;

# temptable is now complete. we can insert the data into the main table now.

# check whether username already exists; use that one of course
my $results = &mysql_get("SELECT name FROM " . $prefix . "usernames");
unless (grep(/^$name$/, @$results)) {
	
}

my @queries = (
	# taxa (name, longname)
	"INSERT INTO " . $prefix . "taxa (name, longname) 
		SELECT DISTINCT $temptable.name, $temptable.longname FROM $temptable",
	# blast databases
	"INSERT INTO " . $prefix . "blast_dbs (taxon_id, blastdb_path) 
		SELECT DISTINCT " . $prefix . "taxa.id, $temptable.blastdb 
		FROM $temptable INNER JOIN " . $prefix . "taxa ON " . $prefix . "taxa.name = $temptable.name",
	# set name + description
	"INSERT INTO " . $prefix . "set_details (name, description)
		SELECT DISTINCT $temptable.name, $temptable.description FROM $temptable LIMIT 1"
);

$dbh = &mysql_dbh;
foreach (@queries) {
	print $_ . "\n";
	$dbh->do($_) or die;
}
$dbh->disconnect;


exit; 

#--------------------------------------------------
# # Functions follow 
#-------------------------------------------------- 
sub mysql_dbh {
	return DBI->connect("DBI:mysql:$dbname:$dbserver", $username, $pwd);
}


# Sub: mysql_check
# Check whether the result of a query is present or not, return appropriate
# Expects: Scalar string QUERY
# Returns: 1 or 0 depending on presence of result
sub mysql_check {
	my $query = shift;
	unless ($query) { croak "Usage: mysql_check(QUERY)\n"; }
	my @results;
	my $dbh = &mysql_dbh;
	my $sql = $dbh->prepare($query);
	$sql->execute();
	if ($sql->fetchrow_array()) {
		return 1;
	}
	return 0;
}

# Sub: mysql_get
# Get from the database the result of a SQL query
# Expects: QUERY as a string literal
# Returns: Reference to array of arrays (result lines->fields)
sub mysql_get {#{{{
	my $query = shift;
	unless ($query) { croak "Usage: mysql_get(QUERY)\n" }
  # prepare anonymous array
	my $results = [ ];
  # connect and fetch stuff
	my $dbh = &mysql_dbh;
	my $sql = $dbh->prepare($query);
	$sql->execute();
	while (my @result = $sql->fetchrow_array() ) {
		push(@$results, \@result);
	}
	$sql->finish();
	$dbh->disconnect; # disconnect ASAP
	return $results;
}#}}}

# drop all tables. no really, all that start with $prefix.
sub drop_tables {
	my $dbh = DBI->connect("DBI:mysql:$dbname:$dbserver", $username, $pwd)
		or die "Could not connect to MySQL database server: $!\n";
	print 'DROPing tables: ', join(", ", @tables), "\n";
	foreach my $table (@tables) {
		$dbh->do("DROP TABLE IF EXISTS $table") or die "Could not execute drop query: $!\n";
	}
}


# create tables. makes use of the %create_table hash.
sub create_tables {
	&drop_tables;
	my $dbh = DBI->connect("DBI:mysql:$dbname:$dbserver", $username, $pwd);
	foreach (values %create_table) {
		print $_, ";\n";
		$dbh->do($_) or die "Could not exec query: $!\n";
	}
	$dbh->do($insert_seqtypes);	# start off with 'nt' and 'aa' seqtypes
	$dbh->disconnect;
}

#{{{ POD: Appendix
=head1 APPENDIX 

=head2 SQL Statement for creating the database structure

  -- table: blast_dbs
  CREATE TABLE `blast_dbs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxon_id`     INT(10) UNSIGNED DEFAULT NULL,
    `blastdb_path` VARCHAR(255) DEFAULT NULL);
	
  -- table: ogs
  CREATE TABLE `ogs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(255) DEFAULT NULL);
	
  -- table: ortholog_set
  CREATE TABLE `ortholog_set` (
    `id`               INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `set_id`           INT(10) UNSIGNED DEFAULT NULL,
    `ortholog_gene_id` INT(10) UNSIGNED DEFAULT NULL,
    `sequence_pair`    INT(10) UNSIGNED DEFAULT NULL);

  -- table: sequence_pairs
  CREATE TABLE `sequence_pairs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxon_id`     INT(10) UNSIGNED DEFAULT NULL,
    `ogs_id`       INT(10) UNSIGNED DEFAULT NULL,
    `aa_seq`       INT(10) UNSIGNED DEFAULT NULL,
    `nt_seq`       INT(10) UNSIGNED DEFAULT NULL,
    `date`         INT(10) UNSIGNED DEFAULT NULL,
    `username`         INT(10) UNSIGNED DEFAULT NULL);

  -- table: sequences_aa
  CREATE TABLE `sequences_aa` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
		`header`       VARCHAR(255),
    `sequence`     MEDIUMBLOB,
    `username`         INT(10) UNSIGNED DEFAULT NULL,
    `date`         INT(10) UNSIGNED DEFAULT NULL);

  -- table: sequences_nt
  CREATE TABLE `sequences_nt` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
		`header`       VARCHAR(255),
    `sequence`     MEDIUMBLOB,
    `username`         INT(10) UNSIGNED DEFAULT NULL,
    `date`         INT(10) UNSIGNED DEFAULT NULL);

  -- table: set_details
  CREATE TABLE `set_details` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `description`  TINYBLOB);

  -- table: taxa
  CREATE TABLE `taxa` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(20) DEFAULT NULL,
    `longname`     VARCHAR(255) DEFAULT NULL);
	
  -- table: usernames
  CREATE TABLE `usernames` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(255) DEFAULT NULL);

=head1 AUTHOR

Written by Malte Petersen <mptrsen@uni-bonn.de>

=head1 COPYRIGHT

Copyright (C) 2012 Malte Petersen 

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
=cut#}}}
