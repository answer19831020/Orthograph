#!/usr/bin/perl
# Documentation before the code#{{{
=head1 NAME 

B<coreload> - prepare a MySQL database for running Forage

=head1 SYNOPSIS

B<coreload> FASTAFILE

=head1 DESCRIPTION

Prepares a core orthologs table for running Forage. Basically, reads a fasta file
and loads its content into the database. Due to the usage of the MySQL LOAD
INFILE command, this process is pretty fast. 

The fasta headers need to be formatted in a certain way:

  >HMM|TAXON|ID

where HMM is the name of the pHMM that will be used for searching, TAXON the taxon name of the sequence in question, and ID a sequence identifier. None of these need to be unique, but the combination of all three must be.

B<coreload> expects a certain table structure. You may create it yourself by hand
using the following SQL statement or whatever workflow you fancy, or you may run
B<coreload -c> once, which does the same thing.

	DROP TABLE IF EXISTS core_orthologs;
  CREATE TABLE core_orthologs (
    id          INT(11) AUTO_INCREMENT PRIMARY KEY,
    taxon       VARCHAR(255) NOT NULL,
    orthoset    VARCHAR(255) NOT NULL,
    hmm         VARCHAR(255) NOT NULL,
    blastdb     VARCHAR(255) NOT NULL, INDEX (blastdb),
    header      VARCHAR(255) NOT NULL, INDEX (header),
    sequence    MEDIUMBLOB);

=cut#}}}

use strict;
use warnings;
use Carp;
use Getopt::Long;
use File::Temp;     # temporary files
use File::Spec;
use Seqload::Fasta qw(fasta2csv); # object-oriented access to fasta files, fasta2csv converter
use DBI;
use DBD::mysql;
use Seqload::Fasta;


my $dbname       = 'forage';
my $dbserver     = '127.0.0.1';
my $user         = undef;
my $pwd          = undef;
my $setname      = undef;
my $prefix       = 'forage_';
my $blastdir     = '';
my $create       = 0;
my $temptable    = 'temp';
my @tables       = qw(
	blast_dbs
	ogs
	ortholog_set
	sequence_pairs
	sequences_aa
	sequences_nt
	set_details
	taxa
	users
	temp
);
my %names;
my $description;
my $ogs_name;


#{{{POD: Options
=head1 OPTIONS

=head2 -c

(Re-)creates the necessary table structure. Careful, this will wipe out everything
you had in the table. You should not do this more than once in the process of using
Forage unless you know what you are doing.

=head2 -D database

Database name to use. Defaults to 'forage'.

=head2 -h host

Database server. Defaults to '127.0.0.1', which is (mostly) equivalent to
'localhost'.

=head2 -b /blast/database/prefix

BLAST database prefix. Must point to a directory containing the BLAST databases. These themselves must be each in its own directory, e.g., like so:

  /home/user/blast/apismellifera
  /home/user/blast/drosophilamelanogaster

The directory name of each BLAST database must match with the taxon name in the fasta headers, and the BLAST database inside it must be named as F<taxon_prot>.

If all is setup like described, the prefix would be specified as: B<-b /home/user/blast>.

=head2 -p password

Password for the connection. No default; this must be set.

=head2 -t temptable

Temporary table name to use. Defaults to 'temp'.

=head2 -u username

Username for the connection. No default; this must be set.

=head1 AUTHOR

Written by Malte Petersen <mptrsen@uni-bonn.de>

=head1 COPYRIGHT

Copyright (C) 2012 Malte Petersen 

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
=cut#}}}

GetOptions(
	'D=s'      => \$dbname,
	'prefix=s' => \$prefix,
	'blastdir=s' => \$blastdir,
	'c'        => \$create,
	'h=s'      => \$dbserver,
	'p=s'      => \$pwd,
	's=s'      => \$setname,
	't=s'      => \$temptable,
	'u=s'      => \$user,
	);
my $infile = shift @ARGV;

# make sure there is at least one underscore at the end of the prefix
$prefix =~ s/_$//;
$prefix .= '_';
# prepend the prefix to the table names. useful for dropping all of 'em.
@tables = map { $prefix.$_ } @tables;

# the queries for the individual tables
my %create_table = (#{{{
	# table: blast_dbs
	'blast_dbs' => "CREATE TABLE `" . $prefix . "blast_dbs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxon_id`     INT(10) UNSIGNED DEFAULT NULL,
    `blastdb_path` VARCHAR(255) DEFAULT NULL)",
	
	# table: ogs
	'ogs' => "CREATE TABLE `" . $prefix . "ogs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(255) DEFAULT NULL)",
	
	# table: ortholog_set
	'ortholog_set' => "CREATE TABLE `" . $prefix . "ortholog_set` (
    `id`               INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `set_id`           INT(10) UNSIGNED DEFAULT NULL,
    `ortholog_gene_id` INT(10) UNSIGNED DEFAULT NULL,
    `sequence_pair`    INT(10) UNSIGNED DEFAULT NULL)",

	# table: sequence_pairs
	'sequence_pairs' => "CREATE TABLE `" . $prefix . "sequence_pairs` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `taxon_id`     INT(10) UNSIGNED DEFAULT NULL,
    `ogs_id`       INT(10) UNSIGNED DEFAULT NULL,
    `aa_seq`       INT(10) UNSIGNED DEFAULT NULL,
    `nt_seq`       INT(10) UNSIGNED DEFAULT NULL,
    `date`         INT(10) UNSIGNED DEFAULT NULL,
    `user`         INT(10) UNSIGNED DEFAULT NULL)",

	# table: sequences_aa
	'sequences_aa' => "CREATE TABLE `" . $prefix . "sequences_aa` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `sequence`     MEDIUMBLOB,
    `user`         INT(10) UNSIGNED DEFAULT NULL,
    `date`         INT(10) UNSIGNED DEFAULT NULL)",

	# table: sequences_nt
	'sequences_nt' => "CREATE TABLE `" . $prefix . "sequences_nt` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `sequence`     MEDIUMBLOB,
    `user`         INT(10) UNSIGNED DEFAULT NULL,
    `date`         INT(10) UNSIGNED DEFAULT NULL)",

	# table: set_details
	'set_details' => "CREATE TABLE `" . $prefix . "set_details` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `description`  TINYBLOB)",

	# table: taxa
	'taxa' => "CREATE TABLE `" . $prefix . "taxa` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(20) DEFAULT NULL,
    `longname`     VARCHAR(255) DEFAULT     NULL)",
	
	# table: users
	'users' => "CREATE TABLE `" . $prefix . "users` (
    `id`           INT(10) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name`         VARCHAR(255) DEFAULT NULL)",
);#}}}

unless (defined $user and defined $pwd ) {
	die "Fatal: You must specify database username (-u) and password (-p) AND core-ortholog set name (-s).\n";
}

#--------------------------------------------------
# # if you only want me to create the tables, fine. this will give you a clean slate.
#-------------------------------------------------- 
if ($create) {
	&create_tables;
	print "OK.\n";
	exit;
}

#--------------------------------------------------
# # otherwise, continue and gather information
#-------------------------------------------------- 
$infile or die "Usage: $0 FASTAFILE\n";
print "Setting up core ortholog set in $dbname on $dbserver... (press CTRL+C to abort)\n";
unless ($setname) {
	print "Enter a name for the set (required): ";
	$setname = <STDIN>;
	chomp $setname;
}
unless ($blastdir) {
	print "Enter the location where the BLAST database directories are located (required): ";
	$blastdir = <STDIN>;
	chomp $blastdir;
}
print "Enter a description for the set (optional but recommended): "; 
$description = <STDIN>;
chomp $description;

unless (defined $setname) { croak "Fatal: You must specify the core-ortholog set name (-s).\n" }

#--------------------------------------------------
# # read the input file and create a CSV file with everything we know 
#-------------------------------------------------- 

my $tmpfile = File::Temp->new();

my $faobj = Seqload::Fasta->open($infile);
no warnings;	# disable warnings for printing of the NULL column
while (my ($hdr, $seq) = $faobj->next_seq()) {
	my @line = split(/\|/, $hdr);
	printf $tmpfile "%s,%s,%s,%s,%s,%s,%s,%s\n", 
		$line[1], 
		undef,
		$setname,
		$line[0], 
		File::Spec->catfile($blastdir, $line[1], $line[1] . '_prot'),
		$line[2],
		$seq,
		$description;
}
use warnings;
$faobj->close();

#--------------------------------------------------
# # create a temporary table for high-speed loading of the data. we can sort it out later.
#-------------------------------------------------- 
my $create_temp_table_query = "CREATE TABLE $temptable (
    `name`     VARCHAR(255),
    `longname` VARCHAR(255),
		`orthoset` VARCHAR(255),
		`hmm`      VARCHAR(255),
		`blastdb`  VARCHAR(255),
		`header`   VARCHAR(255),
		`sequence` VARCHAR(255),
		`description` VARCHAR(255))";
my $loadquery = "LOAD DATA LOCAL INFILE '$tmpfile' IGNORE 
  INTO TABLE $temptable FIELDS TERMINATED BY ',' (
		name,
		longname,
		orthoset,
		hmm,
		blastdb,
		header,
		sequence,
		description)";

my $dbh = DBI->connect("DBI:mysql:$dbname:$dbserver", $user, $pwd);
$dbh->do("DROP TABLE IF EXISTS $temptable") or die "Could not DROP TABLE $temptable: $!\n";
$dbh->do($create_temp_table_query) or die "Could not CREATE TABLE $temptable: $!\n";
my $sql = $dbh->prepare($loadquery);
$sql->execute() or die;
$sql->finish();
$dbh->disconnect;

print "Successfully loaded $infile into $dbname on $dbserver.\n";

# get name and longname from the temp table; they do not get updated automatically
$dbh = DBI->connect("DBI:mysql:$dbname:$dbserver", $user, $pwd);
$sql = $dbh->prepare("SELECT DISTINCT name, longname FROM temp");
$sql->execute();
while (my @result = $sql->fetchrow) {
	$names{$result[0]} = $result[1];
}
$dbh->disconnect;

# ask the user for the taxon names
foreach (keys %names) {
	unless ($names{$_}) {
		print "Enter complete name for the shorthand '$_': ";
		$names{$_} = <STDIN>;
		chomp $names{$_};
	}
}

# update the temptable with the collected info
$dbh = &mysql_dbh;
foreach (keys %names) {
	$sql = $dbh->prepare("UPDATE $temptable SET longname='" . $names{$_} . "' WHERE name='" . $_ . "'");
	$sql->execute();
}
$dbh->disconnect;

# temptable is now complete. we can insert the data into the main table now.
my @queries = (
	"INSERT INTO " . $prefix . "taxa (name, longname) 
		SELECT DISTINCT $temptable.name, $temptable.longname FROM $temptable",
	"INSERT INTO " . $prefix . "blast_dbs (taxon_id, blastdb_path) 
		SELECT DISTINCT " . $prefix . "taxa.id, $temptable.blastdb 
		FROM $temptable INNER JOIN " . $prefix . "taxa ON " . $prefix . "taxa.name = $temptable.name"
);

$dbh = &mysql_dbh;
foreach (@queries) {
	print $_ . "\n";
	$dbh->do($_) or die;
}
$dbh->disconnect;


exit; 

#--------------------------------------------------
# # Functions follow 
#-------------------------------------------------- 
sub mysql_dbh {
	return DBI->connect("DBI:mysql:$dbname:$dbserver", $user, $pwd);
}
# drop all tables. no really, all that start with $prefix.
sub drop_tables {
	my $dbh = DBI->connect("DBI:mysql:$dbname:$dbserver", $user, $pwd)
		or die "Could not connect to MySQL database server: $!\n";
	print 'DROPing tables: ', join(", ", @tables), "\n";
	foreach my $table (@tables) {
		$dbh->do("DROP TABLE IF EXISTS $table") or die "Could not execute drop query: $!\n";
	}
}


# create tables. makes use of the %create_table hash.
sub create_tables {
	&drop_tables;
	my $dbh = DBI->connect("DBI:mysql:$dbname:$dbserver", $user, $pwd);
	foreach (values %create_table) {
		print $_, ";\n";
		$dbh->do($_) or die "Could not exec query: $!\n";
	}
	$dbh->disconnect;
}
