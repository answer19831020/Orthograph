#!/usr/bin/env perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2014 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write clean code
use warnings;       # cry if something seems odd
use autodie;        # die automatically on I/O functions

# Core modules
use Carp;           # carp and croak: warn and die with call stack
use Data::Dumper;   # great for debugging
use FindBin;        # locate the dir of this script during compile time
use Getopt::Long;   # command line options
use IO::File;       # object-oriented access to files
use List::Util qw( first min max sum );  # list functions
use Time::HiRes qw(time);    # high-resolution timer

# Custom modules
use lib $FindBin::Bin;                 # $Bin is the directory of the original script
use Orthograph::Config;                # configuration in global hashref $config
use Orthograph::Functions;             # functions for all Orthograph tools
use Wrapper::Exonerate;
use IO::Tee;

my $config = $Orthograph::Config::config;	# copy config variables

#--------------------------------------------------
# # Database settings
#-------------------------------------------------- 
# which database backend do we use?
my $database_backend = $config->{'database-backend'};
my $use_mysql        = $database_backend eq 'mysql'  ? 1 : 0;
my $use_sqlite       = $database_backend eq 'sqlite' ? 1 : 0;
my $database         = undef;
if ($use_mysql)      {
	use Wrapper::Mysql;
	$database = $config->{'mysql-database'};
}
elsif ($use_sqlite) {
	use Wrapper::Sqlite;
	$database = $config->{'sqlite-database'};
}
# MySQL settings
my $mysql_table_blast          = $config->{'mysql_table_blast'};
my $mysql_table_blastdbs       = $config->{'mysql_table_blastdbs'};
my $mysql_table_ests           = $config->{'mysql_table_ests'};
my $mysql_table_hmmsearch      = $config->{'mysql_table_hmmsearch'};
my $mysql_table_set_details    = $config->{'mysql_table_set_details'};
my $mysql_table_aaseqs         = $config->{'aaseqs'};
my $mysql_table_seqpairs       = $config->{'sequence-pairs'};
my $mysql_table_taxa           = $config->{'taxa'};
my $mysql_table_orthologs      = $config->{'orthologs'};

# directory and output settings
my $outdir                     = $config->{'output-directory'};
my $aaoutdir                   = File::Spec->catdir($outdir, $config->{'aaoutdir'});
my $ntoutdir                   = File::Spec->catdir($outdir, $config->{'ntoutdir'});
my $logdir                     = File::Spec->catdir($outdir, 'log');
my $debug                      = $config->{'debug'};
my $quiet                      = $config->{'quiet'};
my $concat_sep                 = $config->{'concatenation-header-separator'};
my $sep                        = $config->{'header-separator'};
my $verbose                    = $config->{'verbose'};

# settings for this specific analysis
my $blast_evalue_threshold     = $config->{'blast-evalue-threshold'};
my $exonerate_program          = $config->{'exonerate-program'};
my $translate_program          = $config->{'translate-program'};
my $fill_with_x                = $config->{'fill-with-x'};
my $hmmsearch_evalue_threshold = $config->{'hmmsearch-evalue-threshold'};
my $hmmsearch_score_threshold  = $config->{'hmmsearch-score-threshold'};
my $orthoid_list_file          = $config->{'cog-list-file'};
my $orf_overlap_minimum        = $config->{'orf-overlap-minimum'};
my $reference_taxa             = $config->{'reference-taxa'};
my $setname                    = $config->{'ortholog-set'};
my $soft_threshold             = $config->{'soft-threshold'};
my $speciesname                = $config->{'species-name'};

# make a nice time string
my @lt                   = localtime time;
my $timestring           = sprintf "%04d-%02d-%02d_%02d:%02d", $lt[5] + 1900, $lt[4] + 1, $lt[3], $lt[2], $lt[1];

# open log and table output files 
my $logfile = File::Spec->catfile($logdir, 'report-' . $timestring . '.log');
my $logfh = IO::File->new($logfile, 'w')
	or die "Fatal: Could not open report file '$logfile'\: $!\n";
my $tablefile = File::Spec->catfile($logdir, 'table.txt');

# read the list of orthoids from file
my $list_of_wanted_orthoids;
if ($orthoid_list_file) {
	$list_of_wanted_orthoids = Orthograph::Functions::file2arrayref($orthoid_list_file);
}

# setup IO::Tee
my $stdout = IO::Tee->new(
	\*STDOUT,
	$logfh,
);
my $stderr = IO::Tee->new(
	\*STDERR,
	$logfh,
);

# also be verbose if debugging
if ($debug) { $verbose = 1; Wrapper::Exonerate->debug(1) }

# More variables
my $bin_size             = 500;
my $blastresults         = undef;
my $count                = 0;
my $data_by_orthoid      = { };
my $out                  = { };
my $data_by_transcript   = { };
my $data_by_evalue       = { };
my $hitcount             = 0;
my $hmmresults           = undef;
my $insert_n             = 1;
my $n_complete_orthoids  = 0;
my $table                = [ ];
my @reftaxa              = ( );
my $strict               = 0;
my $species_id           = 0;
my $set_id               = 0;
my $match                = 0;
my $mismatches           = 0;
my $max_mismatches       = $soft_threshold;
my $results              = undef;
my ($t0, $t1)            = 0;
my $stats                = { };
my $starttime            = scalar time;
my $endtime              = 0;
my $totaltime            = 0;

# get exonerate and fastatranslate path from config file
Wrapper::Exonerate->searchprog($exonerate_program);
Wrapper::Exonerate->translateprog($translate_program);
Wrapper::Exonerate->outdir($logdir);

# get the species id from the database
$species_id = get_taxid_for_species($speciesname);
unless ($species_id) {
	print $stderr "Fatal: No such species in database: '$speciesname'\n";
	exit(1);
}

# get real table names
($mysql_table_ests, $mysql_table_hmmsearch, $mysql_table_blast) = get_real_table_names($species_id);

# get the set id from the database
$set_id = get_set_id($setname);
unless ($set_id) {
	print $stderr "Fatal: No such set in database: '$setname'\n";
	exit(1);
}

# Create the list of reference taxa
# This can be set in the config file, otherwise get all taxa in the set
if ($reference_taxa) {
	$reference_taxa =~ s/\s*$//;
	@reftaxa = split(/\s*,\s*/, $reference_taxa);
}
else { @reftaxa = get_taxa_in_set($set_id) }

# get a orthoid => list_of_aaseq_ids relationship from the db
my $aaseqs_in_orthoid = get_orthologs_for_set_hashref($set_id);

# get list of hmmsearch alignment scores
my $scores = get_scores_list($species_id, $set_id);
my $num_scores = scalar @$scores;

# generate a table
my $transcripts_mapped_to = { };

# this will hold all transcripts that were found so we can check for redundancy
my @transcript_list;

# okay let's do the loop come on baby let's do the loop
my $c = 0;
SCORE:
foreach my $score (@$scores) {

	$c++;
	print $stdout "Fetching next batch of results for HMM alignment score $score...\n" if $verbose;
	$t0 = scalar time;
	$hmmresults = get_hmmresults_for_single_score($set_id, $score);
	$t1 = scalar time;
	# skip empty results
	unless (@$hmmresults) { next SCORE }

	printf $stdout "Fetched %6d rows for HMM alignment score %7.1f in %.1f seconds (%.1f %%)\n",
		scalar @$hmmresults,
		$score,
		$t1 - $t0,
		$c / $num_scores * 100
			unless $quiet;

	RESULT:
	foreach my $result (@$hmmresults) {
		my $orthoid = $result->{'orthoid'};
		# skip this result if it concerns a ortholog group that we didn't want
		if ($list_of_wanted_orthoids) {
			next unless grep { /$orthoid/ } @$list_of_wanted_orthoids;
		}

		print $stdout "Checking $orthoid for ortholog hits...\n" if $verbose;

		printf $stdout "Fetching BLAST results for %s (HMMsearch id %d, alignment score %7.1f)...\n",
			$result->{'header'},
			$result->{'hmmsearch_id'},
			$score,
				if $verbose;
		$blastresults = get_blastresults_for_hmmsearch_id($set_id, $result->{'hmmsearch_id'});


		# so, was this a reciprocal match?
		if (my $this_match = is_reciprocal_match($orthoid, $blastresults)) {

			# yeah - here should be the part where the actual sequences are output
			printf $stdout "Orthology detected for %s! Trying to add %s[%d:%d] to %s.\n",
				$orthoid,
				$this_match->{'hmmhit'},
				$this_match->{'hmm_start'},
				$this_match->{'hmm_end'},
				$orthoid,
				if $debug;

			# if this orthoid has been hit before, check whether the new cancidate
			# overlaps on hmm (gene) level with previous hits
			if (exists $transcripts_mapped_to->{$orthoid}) {

				if (hmm_overlap($transcripts_mapped_to->{$orthoid}, $this_match)) {
					# yep, it overlaps, so we can't assign this transcript because better
					# e-values have precedence. just go to the next one
					printf $stdout "Overlap with previous hit on hmm level for %s: discarded %s.\n",
						$orthoid,
						$this_match->{'hmmhit'}
							if $verbose;
					next RESULT;
				}

				# or does it overlap on transcript level?
				elsif (transcript_overlap($transcripts_mapped_to->{$orthoid}, $this_match)) {
					printf $stdout "Overlap with previous hit on transcript level for %s: discarded %s.\n",
						$orthoid,
						$this_match->{'hmmhit'}
							if $verbose;
					next RESULT;
				}

				else {
					# does not overlap, add to list of transcripts for this ortholog group
					push @{ $transcripts_mapped_to->{$orthoid} }, $this_match;
					printf $stdout ">> No overlap with previous hits: added '%s' [%d:%d] to %s.\n",
						$this_match->{'header'},
						$this_match->{'env_start'},
						$this_match->{'env_end'},
						$orthoid
							unless $quiet;
					# this transcript can't be found again
					push @transcript_list, $this_match->{'hmmhit'};
					# ok, next one
					next RESULT;
				}

			}

			else {

				# this has not been hit before, just assign
				printf $stdout ">> Assigned '%s' [%d:%d] to %s.\n",
					$this_match->{'header'},
					$this_match->{'env_start'},
					$this_match->{'env_end'},
					$orthoid
						unless $quiet;
				push @{ $transcripts_mapped_to->{$orthoid} }, $this_match;

				# this transcript can't be found again
				push @transcript_list, $this_match->{'hmmhit'};

				# reset 
				undef $this_match;
			}

		}

		else {
			# this orthoid has no match
			print $stdout "No orthology detected for $orthoid.\n"
				if $verbose;
		}

	# END RESULT
	} 

# END SCORE
}

print $stdout "\n";
print $stdout "####################################\n";
print $stdout "Finished fetching from the database.\n";
print $stdout "Starting output.\n";
print $stdout "####################################\n";


# a tablefile
my $tfh = IO::File->new($tablefile, 'w')
	or print $stderr "Fatal: Could not open table file $tablefile\: $!\n" and exit(1);

my $num_n = 0;
my $num_orthologs = scalar keys %$transcripts_mapped_to;
my $l_counter = length $num_orthologs;
my $counter = 0;

# walk the orthologs, concatenate in order if multiple
ORTHOID:
foreach my $orthoid (sort {$a cmp $b} keys %$transcripts_mapped_to) {
	# get the transcripts and sort by descending hmm alignment length
	my $list_of_hits = $transcripts_mapped_to->{$orthoid};
	$list_of_hits = [ sort { $b->{'ali_end'} - $b->{'ali_start'} <=> $a->{'ali_end'} - $a->{'ali_start'} } @$list_of_hits ];
	my ($hdr, $seq, $cdnahdr, $cdnaseq, $reftaxon, $reftaxon_score);
	$hitcount            = 0;
	my $firsttime        = 1;
	my $i                = 0;
	my $output_sequences = [ ];

	++$counter;
	printf $stdout "Finalizing %s... (%${l_counter}d of %${l_counter}d)\n", $orthoid, $counter, $num_orthologs;
	# each reciprocal hit
	HIT:
	while (my $hit = shift @$list_of_hits) {
		++$hitcount;
		++$i;

		# get the sequences from the database
		my $proteome_sequence;
		($proteome_sequence, $hit->{'reftaxon'}) = get_reference_sequence($hit->{'blast_hit'});
		my $est_sequence = get_nucleotide_transcript_for($hit->{'hmmhit'});

		# exonerate the orf (correct for frameshifts etc and produce corresponding nt sequence)
		( $hit->{'orf_aa_sequence'},
			$hit->{'orf_cdna_sequence'},
			$hit->{'orf_cdna_start'},
			$hit->{'orf_cdna_end'},
			$hit->{'orf_aa_start'},
			$hit->{'orf_aa_end'} ) = get_orf($proteome_sequence, $est_sequence);

		# exonerate got an alignment
		if ($hit->{'orf_cdna_sequence'}) {
			printf $stdout "Got an ORF for '%s'[%d-%d] (ORF coords %d-%d)\n",
				$hit->{'hmmhit'},
				$hit->{'env_start'},
				$hit->{'env_end'},
				$hit->{'orf_cdna_start'},
				$hit->{'orf_cdna_end'}
					if $debug;
			if ($debug > 1) {
				print $hit->{'orf_cdna_sequence'}, "\n";
			}

			# check whether the overlap to the hmm alignment is sufficient
			my $orf_overlap = orf_overlaps_hmm($hit);

			# the overlap is sufficient, so this is ok
			if ($orf_overlap >= $orf_overlap_minimum) {
				printf $stdout "ORF (%d-%d) overlaps HMM alignment region (%d-%d) by %.2f %%\n",
					$hit->{'orf_aa_start'},
					$hit->{'orf_aa_end'},
					$hit->{'ali_start'},
					$hit->{'ali_end'},
					$orf_overlap * 100,
						if $verbose;

				# check whether this ORF overlaps with any previous hits
				if (overlaps_previous_hit($output_sequences, $hit)) {
					print $stdout "Skipping this transcript\n" if $verbose;
					next HIT;
				}

				# ok, this can be added to the output sequences
				push @$output_sequences, $hit;

				# write the ortholog gene id to the table, but only once
				if ($firsttime) {
					print $tfh $orthoid;
					$firsttime = 0;
				}

				# write the transcripts to the table
				printf $tfh "\t%s[len %d]",
					$hit->{'header'},                 # transcript ID
					length $hit->{'orf_aa_sequence'}, # ORF sequence length
				;

				# assign (new) reference taxon if blast score higher
				if (not defined $reftaxon) { 
					$reftaxon       = $hit->{'reftaxon'};
					$reftaxon_score = $hit->{'blast_score'};
				}
				elsif ($hit->{'blast_score'} > $reftaxon_score) {
					$reftaxon       = $hit->{'reftaxon'};
					$reftaxon_score = $hit->{'blast_score'};
				}
			}
			else {
				printf $stdout "ORF (%d-%d) overlaps HMM alignment region (%d-%d) only by %.2f %%, skipping this transcript\n", 
					$hit->{'orf_aa_start'},
					$hit->{'orf_aa_end'},
					$hit->{'ali_start'},
					$hit->{'ali_end'},
					$orf_overlap * 100,
						if $verbose;
				next HIT;
			}
		}
		# exonerate didn't get an alignment
		else {
			if ($verbose) {
				printf $stdout "Could not get an ORF for '%s'[%d:%d] and '%s'\n",
					$hit->{'header'},
					$hit->{'env_start'},
					$hit->{'env_end'},
					$hit->{'blast_hit'},
				;
				print $stdout "Skipping this transcript\n";
			}
			next HIT;
		}

	}

	print $tfh "\n";

	# skip the rest since no sequence could be gathered
	unless (@$output_sequences) {
		print $stdout "No ORFs found for $orthoid, skipping...\n" unless $quiet;
		next ORTHOID;
	}

	# concatenate headers and sequences in order
	($hdr, $seq, $cdnahdr, $cdnaseq) = concatenate_sequences($output_sequences);

	# get the core ortholog sequences for this group
	my $core_sequences = get_ortholog_group($set_id, $orthoid);
	# new fasta file
	my $fafn = File::Spec->catfile($aaoutdir, $orthoid . '.fa');
	my $fafh = IO::File->new($fafn, 'w');
	# print the core orthologs
	printf $fafh ">%s|%s|%s\n%s\n",
		$orthoid, # ortholog id
		$$_[0],   # reftaxon name
		$$_[1],   # header
		$$_[2]    # sequence
			foreach (sort @$core_sequences);
	# prepend orthoid, reference taxon, and taxon name
	$hdr = join $sep, ($orthoid, $reftaxon, $speciesname, $hdr);
	# print the concatenated sequence
	printf $fafh ">%s\n%s\n", $hdr, $seq;
	print $stdout "wrote concatenated sequence $hdr to file $fafn\n" if $debug;
	undef $fafh;

	# do the same for the nucleotide sequences
	my $core_sequences_nt = get_ortholog_group_nucleotide($set_id, $orthoid);
	# new fasta file
	$fafn = File::Spec->catfile($ntoutdir, $orthoid . '.fa');
	$fafh = IO::File->new($fafn, 'w');
	# print the core orthologs
	printf $fafh ">%s|%s|%s\n%s\n",
		$orthoid, # ortholog id
		$$_[0],   # reftaxon name
		$$_[1],   # header
		$$_[2]    # sequence
			foreach (sort @$core_sequences_nt);
	# prepend orthoid, reference taxon, and taxon name
	$hdr = join $sep, ($orthoid, $reftaxon, $speciesname, $hdr);
	# print the concatenated sequence
	printf $fafh ">%s\n%s\n", $hdr, $cdnaseq;
	print $stdout "wrote concatenated sequence $hdr to file $fafn\n" if $debug;
	undef $fafh;

	# one more
	$n_complete_orthoids++;
	printf $stdout "Mapped %d transcripts to %s\n",
		scalar @$output_sequences,
		$orthoid
			unless $quiet;
}
undef $tfh;

# yay
$endtime = scalar time;
printf $stdout "## Orthograph report for %s completed in %.2f total seconds\n", $speciesname, $endtime - $starttime;
printf $stdout "## Found %d putative orthologs\n", $n_complete_orthoids unless $quiet;
exit;


=head2 binify(BIN_SIZE, VALUE_COUNT)

binifies a value->count hashref, i.e. generates an arrayref of bins (order
based on the numerical order of the hash keys), each of which contain a hashref
with the min and max boundary of the bin:

  [
    {
      'min' => min(THIS_BIN),
      'max' => max(THIS_BIN)
    },
    { 
      'min' => min(THIS_BIN),
      'max' => max(THIS_BIN)
    }
  ]

This is useful for constructing database queries using BETWEEN filters, because
these would take forever on very large datasets.

=cut

sub binify {
	my $bin_size    = shift;
	my $value_count = shift;
	my $bins        = [ ];
	my $sum         = 0;
	my @bin         = ( );
	foreach my $value (sort {$a <=> $b} keys %$value_count) {
		# if adding this count would not exceed the bin size
		if ($sum + $value_count->{$value} < $bin_size) {
			push @bin, $value;
			$sum += $value_count->{$value};
		}
		# this is too large, start a new bin
		else {
			# if the bin has content
			if (scalar @bin) {
				# put min and max into @$bins
				push @$bins, { 'min' => min(@bin), 'max' => max(@bin) };
				# empty this bin
				@bin = ( );
				$sum = 0;
			}
			# put this count into the bin
			push @bin, $value;
			$sum += $value_count->{$value};
		}
	}
	# in case there is only one bin (happens when there are only few results), return that
	if (scalar @$bins == 0) { push @$bins, { 'min' => min(@bin), 'max' => max(@bin) } }
	return $bins;
}

sub is_reciprocal_match {
	my $orthoid = shift;
	my $blastresults = shift;

	# set the mismatch counter
	$mismatches = 0;

	foreach my $result (@$blastresults) {
		if ( first { /$result->{'blast_hit'}/ } @{$aaseqs_in_orthoid->{$orthoid}} ) {

			printf $stdout "    reciprocal hit %s for %s used in %s!\n",
				$result->{'blast_hit'},
				$result->{'hmmhit'},
				$orthoid
					if $verbose;

			$match = $result;

			# one hit is enough if not in strict mode
			return $match unless $strict;
		}
		else {  # not found
			# cry
			++$mismatches;
			printf $stdout "    reciprocal hit %s not used in this HMM (mismatch #%d) :(\n",
				$result->{'blast_hit'},
				$mismatches
					if $verbose;

			# in a strict search, that's it for this orthoid
			return undef if $strict;

			# no match
			undef $match;

			# too many mismatches, we don't trust this one anymore
			if ($mismatches >= $max_mismatches) {
				print $stdout "    Too many mismatches, we don't trust this one anymore.\n" if $verbose;
				return undef;
			}
		}
	}

	return undef;
}

sub hmm_overlap {
	my $already_assigned = shift;
	my $candidate = shift;
	# test whether the candidate overlaps on hmm level, return 1 or 0
	foreach my $assigned_transcript (@$already_assigned) {
		# the hmm coords do not overlap
		if ($$candidate{'hmm_end'} <= $$assigned_transcript{'hmm_start'} or $$candidate{'hmm_start'} >= $$assigned_transcript{'hmm_end'}) {
			print_no_overlap($candidate, $assigned_transcript)
				if $verbose;
		}
		else {
			print_overlap($candidate, $assigned_transcript, 'hmm')
				if $verbose;
			return 1;
		}
	}
	return 0;
}

sub transcript_overlap {
	my $already_assigned = shift;
	my $candidate = shift;
	# test whether the candidate overlaps on transcript level, return 1 or 0
	foreach my $assigned_transcript (@$already_assigned) {
		# the hmm coords do not overlap
		if ($$candidate{'env_end'} <= $$assigned_transcript{'env_start'} or $$candidate{'env_start'} >= $$assigned_transcript{'env_end'}) {
			print_no_overlap($candidate, $assigned_transcript)
				if $verbose;
		}
		else {
			print_overlap($candidate, $assigned_transcript, 'transcript')
				if $verbose;
			return 1;
		}
	}
	return 0;
}

sub print_overlap {
	my $candidate = shift;
	my $transcript = shift;
	my $level      = shift;
	printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) overlap on %s level.\n", 
		$$transcript{'hmmhit'},
		$$transcript{'env_start'},
		$$transcript{'env_end'},
		$$transcript{'hmm_start'},
		$$transcript{'hmm_end'},
		$$candidate{'hmmhit'},
		$$candidate{'env_start'},
		$$candidate{'env_end'},
		$$candidate{'hmm_start'},
		$$candidate{'hmm_end'},
		$level
	;
}

sub print_no_overlap {
	my $candidate = shift;
	my $transcript = shift;
	my $level      = shift;
	printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) do not overlap on %s level.\n", 
		$$transcript{'hmmhit'},
		$$transcript{'env_start'},
		$$transcript{'env_end'},
		$$transcript{'hmm_start'},
		$$transcript{'hmm_end'},
		$$candidate{'hmmhit'},
		$$candidate{'env_start'},
		$$candidate{'env_end'},
		$$candidate{'hmm_start'},
		$$candidate{'hmm_end'},
		$level
	;
}

=head2 overlap

Calculates whether or not a given transcript overlaps with already assigned other transcripts, on both HMM (=OG) coordinates and transcript coordinates (env coords).

Returns 0 if nothing overlaps.
Returns 1 if the candidate overlaps only on transcript coordinates, but not on the HMM.
Returns 2 if the candidate overlaps on the HMM coords. This should not be accepted.

Arguments: arrayref (already matched transcripts), hashref (candidate transcript)

=cut

sub overlap {
	my $already_assigned = shift;
	my $candidate = shift;
	my $overlap   = 0;
	for (my $i = 0; $i < scalar @$already_assigned; ++$i) {
		# the hmm coords do not overlap
		if ($$candidate{'hmm_end'} <= $$already_assigned[$i]{'hmm_start'} or $$candidate{'hmm_start'} >= $$already_assigned[$i]{'hmm_end'}) {
			# the transcript coords do not overlap
			if ($$candidate{'env_end'} <= $$already_assigned[$i]{'env_start'} or $$candidate{'env_start'} >= $$already_assigned[$i]{'env_end'}) {
				printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) do not overlap.\n", 
					$$already_assigned[$i]{'hmmhit'},
					$$already_assigned[$i]{'env_start'},
					$$already_assigned[$i]{'env_end'},
					$$already_assigned[$i]{'hmm_start'},
					$$already_assigned[$i]{'hmm_end'},
					$$candidate{'hmmhit'},
					$$candidate[$i]{'env_start'},
					$$candidate[$i]{'env_end'},
					$$candidate{'hmm_start'},
					$$candidate{'hmm_end'}
						if $verbose;
				# this is ok, best case
			}
			# the transcript coords overlap
			elsif ($$candidate{'env_end'} >= $$already_assigned[$i]{'env_start'} or $$candidate{'env_start'} <= $$already_assigned[$i]{'env_end'}) {
				printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) do overlap.\n", 
					$$already_assigned[$i]{'hmmhit'},
					$$already_assigned[$i]{'env_start'},
					$$already_assigned[$i]{'env_end'},
					$$already_assigned[$i]{'hmm_start'},
					$$already_assigned[$i]{'hmm_end'},
					$$candidate{'hmmhit'},
					$$candidate[$i]{'env_start'},
					$$candidate[$i]{'env_end'},
					$$candidate{'hmm_start'},
					$$candidate{'hmm_end'}
						if $verbose;
				return 1;  # this is not ok, the transcript coords should be unified
			}
		}
		# the hmm coords overlap
		else {
			# this is totally not ok
			printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) overlap.\n", 
				$$already_assigned[$i]{'hmmhit'},
				$$already_assigned[$i]{'env_start'},
				$$already_assigned[$i]{'env_end'},
				$$already_assigned[$i]{'hmm_start'},
				$$already_assigned[$i]{'hmm_end'},
				$$candidate{'hmmhit'},
				$$candidate[$i]{'env_start'},
				$$candidate[$i]{'env_end'},
				$$candidate{'hmm_start'},
				$$candidate{'hmm_end'}
					if $verbose;
			return 2;
		}
	}
	if ($overlap == 0) { return 0 }
	return 2;
}

sub transcripts_overlap {
	my $already_matched = shift;
	my $candidate = shift;
	my $overlap = 0;
	foreach my $assigned_transcript (@$already_matched) {
		# the candidate is either before or after the already assigned transcript
		# this is ok
		if ($$candidate{'env_end'} <= $$assigned_transcript{'env_start'} or $$candidate{'env_start'} >= $$assigned_transcript{'env_end'}) {
			printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) do not overlap.\n", 
				$$already_matched{'hmmhit'},
				$$already_matched{'env_start'},
				$$already_matched{'env_end'},
				$$already_matched{'hmm_start'},
				$$already_matched{'hmm_end'},
				$$candidate{'hmmhit'},
				$$candidate{'env_start'},
				$$candidate{'env_end'},
				$$candidate{'hmm_start'},
				$$candidate{'hmm_end'}
					if $verbose;
			# this is ok, best case
		}
		else {
			
		}
	}
}


# Finds the ORF for two sequences by aligning them using Exonerate. The program
# clips sequences if it detects frameshift errors and stuff like that.

sub get_orf {
	my $proteome_sequence = shift;
	my $est_sequence      = shift;
	unless ($proteome_sequence and $est_sequence) { return undef }
	my $alignment = Wrapper::Exonerate->new($proteome_sequence, $est_sequence);
	$alignment->search();
	unless ($alignment->cdna_sequence()) { return undef }
	return (
		$alignment->translated_cdna(),
		$alignment->cdna_sequence(),
		$alignment->cdna_start(),
		$alignment->cdna_end(),
		$alignment->aa_start(),
		$alignment->aa_end()
	);
}

# determines whether the ORF overlaps with the HMM alignment by a certain percentage. 
sub orf_overlaps_hmm {
	my $cand        = shift;
	my $orf_overlap = 0;
	my $orf_length  = $cand->{'orf_aa_end'} - $cand->{'orf_aa_start'};
	# if the orf is somewhere else, there is no overlap
	if    ($cand->{'orf_aa_end'} < $cand->{'ali_start'})    { return 0 }
	elsif ($cand->{'ali_end'}    < $cand->{'orf_aa_start'}) { return 0 }
	# orf coords are identical to hmm coords (100% overlap)
	elsif ($cand->{'orf_aa_start'} == $cand->{'ali_start'} and $cand->{'orf_aa_end'} == $cand->{'ali_end'}) { return 1 }

	# calculate percentage overlap
	# orf and hmm start are the same
	if ($cand->{'orf_aa_start'} == $cand->{'ali_start'}) {
		# orf ends after hmm, start is the same (orf is longer than hmm)
		if ($cand->{'orf_aa_end'} > $cand->{'ali_end'}) { 
			$orf_overlap = $cand->{'ali_end'} - $cand->{'orf_aa_start'};
			return $orf_overlap / $orf_length;
		}
		# orf ends before hmm, start is the same (orf is shorter than hmm, fits completely)
		else {
			$orf_overlap = $cand->{'orf_aa_end'} - $cand->{'orf_aa_start'};
			return 1;
		}
	}
	# orf and hmm end are the same
	if ($cand->{'orf_aa_end'} == $cand->{'ali_end'}) {
		# orf starts after hmm, end is the same (orf is shorter than hmm, fits completely)
		if ($cand->{'orf_aa_start'} > $cand->{'ali_start'}) {
			return 1;
		}
		# orf starts before hmm, end is the same (orf is longer than hmm)
		else {
			$orf_overlap = $cand->{'orf_aa_end'} - $cand->{'ali_start'};
			return $orf_overlap / $orf_length;
		}
	}
	# orf starts before hmm, ends before hmm (partial overlap)
	if ($cand->{'orf_aa_start'} < $cand->{'ali_start'} and $cand->{'orf_aa_end'} < $cand->{'ali_end'}) {
			$orf_overlap = $cand->{'orf_aa_end'} - $cand->{'ali_start'};
			return $orf_overlap / $orf_length;
	}
	# orf starts after hmm, ends after hmm (partial overlap)
	if ($cand->{'orf_aa_start'} > $cand->{'ali_start'} and $cand->{'orf_aa_end'} > $cand->{'ali_end'}) {
			$orf_overlap = $cand->{'ali_end'} - $cand->{'orf_aa_start'};
			return $orf_overlap / $orf_length;
	}
	# orf starts before hmm, ends after hmm (orf is longer than hmm)
	if ($cand->{'orf_aa_start'} < $cand->{'ali_start'} and $cand->{'orf_aa_end'} > $cand->{'ali_end'}) {
			$orf_overlap = $cand->{'orf_aa_end'} - $cand->{'ali_start'};
			return $orf_overlap / $orf_length;
	}
	# orf starts after hmm, ends before hmm (shorter than hmm, fits completely)
	if ($cand->{'orf_aa_start'} > $cand->{'ali_start'} and $cand->{'orf_aa_end'} < $cand->{'ali_end'}) {
			return 1;
	}
}

sub overlaps_previous_hit {
	my $other_hits = shift;
	my $cand       = shift;
	foreach my $hit ( grep { defined $_->{'orf_aa_sequence'} } @$other_hits ) {
		# starts before other hit is over or ends after start of other hit
		if ($cand->{'orf_aa_start'} < $hit->{'orf_aa_end'} or $cand->{'orf_aa_end'} > $hit->{'orf_aa_start'}) {
			printf $stdout "ORF (%d-%d) overlaps other ORF (%d-%d)\n",
				$cand->{'orf_aa_start'}, 
				$cand->{'orf_aa_end'},
				$hit->{'orf_aa_start'},
				$hit->{'orf_aa_end'}
					if $verbose;
			return 1;
		}
	}
	# otherwise, it's fine, no overlap
	return 0;
}

sub concatenate_sequences {
	my $hits = shift;

	# sort by order on the output sequence
	$hits = [ sort { $a->{'orf_aa_start'} <=> $b->{'orf_aa_start'} } @$hits ];
	my $prev_end;
	my $seq = '';
	my $cdnaseq = '';
	my $hdr = '';
	my $cdnahdr = '';
	foreach my $hit (@$hits) {

		# before concatenating, fill gaps with 'X' if desired
		if ($fill_with_x) {
			if (defined $prev_end) {
				my $num_x = $hit->{'orf_aa_start'} - $prev_end;
				my $xes   = 'X' x $num_x;
				# 'N' sequences to fill the cdna sequence are three times longer
				my $ns    = 'N' x ($num_x * 3);
				$seq     .=  $xes;
				$cdnaseq .= $ns;
				print $stdout "Added $num_x 'X' to sequence\n" if $debug;
				printf $tfh "\t[%d ambigs]", $num_x;
			}
			$prev_end = $hit->{'orf_aa_end'};
		}

		# concatenate sequences
		$seq     .= $hit->{'orf_aa_sequence'};
		$cdnaseq .= $hit->{'orf_cdna_sequence'};
		printf $stdout "Appended sequence (%d/%d sites) to existing sequence (%d/%d sites)\n",
			length $seq,
			length $cdnaseq,
			length($seq) - length($hit->{'orf_aa_sequence'}),
			length($cdnaseq) - length($hit->{'orf_cdna_sequence'})
				if $debug;
	}
	# join aa headers
	$hdr = $hits->[0]->{'header'} . ':[len ' . length($hits->[0]->{'orf_aa_sequence'}) . ']';
	my $i = 1;
	while (defined $hits->[$i]->{'orf_aa_sequence'}) {
		$hdr .= $concat_sep . $hits->[$i]->{'header'} . ':[len ' . length($hits->[$i]->{'orf_aa_sequence'}) . ']';
		$i++;
	}
	# join cdna headers
	$cdnahdr = $hits->[0]->{'header'} . ':[len ' . length($hits->[0]->{'orf_cdna_sequence'}) . ']';
	$i = 1;
	while (defined $hits->[$i]->{'orf_aa_sequence'}) {
		$hdr .= $concat_sep . $hits->[$i]->{'header'} . ':[len ' . length($hits->[$i]->{'orf_cdna_sequence'}) . ']';
		$i++;
	}
	return ($hdr, $seq, $cdnahdr, $cdnaseq);
}

sub get_ortholog_group {
	my $setid = shift;
	my $orthoid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_ortholog_group($setid, $orthoid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_ortholog_group($setid, $orthoid);
	}
}

sub get_ortholog_group_nucleotide {
	my $specid = shift;
	my $orthoid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_ortholog_group_nucleotide($set_id, $orthoid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_ortholog_group_nucleotide($set_id, $orthoid);
	}
}

sub get_taxid_for_species {
	my $specid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_taxid_for_species($specid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_taxid_for_species($specid);
	}
}

sub get_real_table_names {
	my $specid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_real_table_names($specid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_real_table_names($specid);
	}
}

sub get_set_id {
	my $setn = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_set_id($setn);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_set_id($setn);
	}
}

sub get_taxa_in_set {
	my $setid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_taxa_in_set($setid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_taxa_in_set($setid);
	}
}

sub get_orthologs_for_set_hashref {
	my $setid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_orthologs_for_set_hashref($setid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_orthologs_for_set_hashref($setid);
	}
}

sub create_log_evalues_view {
	my $specid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::create_log_evalues_view($specid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::create_log_evalues_view($specid);
	}
}

sub get_logevalue_count {
	my $specid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_logevalue_count($specid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_logevalue_count($specid);
	}
}

sub get_results_for_logevalue {
	my $setid = shift;
	my $specid = shift;
	my $min = shift;
	my $max = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_results_for_logevalue($setid, $specid, $min, $max);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_results_for_logevalue($setid, $specid, $min, $max);
	}
}

sub get_reference_sequence {
	my $hit = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_reference_sequence($hit);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_reference_sequence($hit);
	}
}

sub get_nucleotide_transcript_for {
	my $hmmhit = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_nucleotide_transcript_for($hmmhit);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_nucleotide_transcript_for($hmmhit);
	}
}

sub get_scores_list {
	my $specid = shift;
	my $setid = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_scores_list($specid, $setid);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_scores_list($specid, $setid);
	}
}

sub get_hmmresults_for_single_score {
	my $setid = shift;
	my $score = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_hmmresults_for_single_score($setid, $score);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_hmmresults_for_single_score($setid, $score);
	}
}

sub get_blastresults_for_hmmsearch_id {
	my $setid = shift;
	my $id = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_blastresults_for_hmmsearch_id($setid, $id);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_blastresults_for_hmmsearch_id($setid, $id);
	}
}

sub get_results_for_single_score {
	my $setid = shift;
	my $score = shift;
	if ($use_mysql) {
		return Wrapper::Mysql::get_results_for_single_score($setid, $score);
	}
	elsif ($use_sqlite) {
		return Wrapper::Sqlite::get_results_for_single_score($setid, $score);
	}
}
