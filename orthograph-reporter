#!/usr/bin/env perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2012 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write clean code
use warnings;       # cry if something seems odd
use autodie;        # die automatically on I/O functions

# Core modules
use Carp;           # carp and croak: warn and die with call stack
use Data::Dumper;   # great for debugging
use DBD::mysql;     # MySQL database driver
use DBI;            # database interface
use FindBin;        # locate the dir of this script during compile time
use Getopt::Long;   # command line options
use IO::File;       # object-oriented access to files
use List::Util qw( first min max sum );  # list functions
use Time::HiRes;    # high-resolution timer

# Custom modules
use lib $FindBin::Bin;                 # $Bin is the directory of the original script
use Orthograph::Config;                # configuration in global hashref $config
use Orthograph::Functions;             # functions for all Orthograph tools
use Wrapper::Mysql;
use Wrapper::Exonerate;
use IO::Tee;

my $config = $Orthograph::Config::config;	# copy config variables

# MySQL settings
my $mysql_table_blast          = $config->{'mysql_table_blast'};
my $mysql_table_blastdbs       = $config->{'mysql_table_blastdbs'};
my $mysql_table_ests           = $config->{'mysql_table_ests'};
my $mysql_table_hmmsearch      = $config->{'mysql_table_hmmsearch'};
my $mysql_table_set_details    = $config->{'mysql_table_set_details'};
my $mysql_table_aaseqs         = $config->{'aaseqs'};
my $mysql_table_seqpairs       = $config->{'sequence-pairs'};
my $mysql_table_taxa           = $config->{'taxa'};
my $mysql_table_orthologs      = $config->{'orthologs'};

# directory and output settings
my $outdir                     = $config->{'output-directory'};
my $aaoutdir                   = File::Spec->catdir($outdir, $config->{'aaoutdir'});
my $logdir                     = File::Spec->catdir($outdir, 'log');
my $quiet                      = $config->{'quiet'};
my $verbose                    = $config->{'verbose'};

# settings for this specific analysis
my $setname                    = $config->{'ortholog-set'};
my $speciesname                = $config->{'species-name'};
my $reference_taxa             = $config->{'reference-taxa'};
my $blast_evalue_threshold     = $config->{'blast-evalue-threshold'};
my $soft_threshold             = $config->{'soft-threshold'};
my $hmmsearch_evalue_threshold = $config->{'hmmsearch-evalue-threshold'};
my $hmmsearch_score_threshold  = $config->{'hmmsearch-score-threshold'};


# open log and table output files 
my $logfile = File::Spec->catfile($logdir, 'report.log');
my $logfh = IO::File->new($logfile, 'w')
	or die "Fatal: Could not open report file '$logfile'\: $!\n";
my $tablefile = File::Spec->catfile($logdir, 'table.txt');

# setup IO::Tee
my $stdout = IO::Tee->new(
	\*STDOUT,
	$logfh,
);
my $stderr = IO::Tee->new(
	\*STDERR,
	$logfh,
);

# mutually exclusive options
if ($verbose and $quiet) {
	print $stderr "Fatal: Can't operate in both verbose and quiet mode\n";
	exit(1);
}

# mutually exclusive options
if ($hmmsearch_evalue_threshold and $hmmsearch_score_threshold) {
	print $stderr "Fatal: Can't use both e-value and score thresholds\n";
	exit(1);
}

# More variables
my $bin_size             = 500;
my $count                = 0;
my $data_by_orthoid      = { };
my $out                  = { };
my $data_by_transcript   = { };
my $data_by_evalue       = { };
my $insert_n             = 1;
my $table                = [ ];
my $strict               = 0;
my @reftaxa              = ( );
my $species_id           = 0;
my $set_id               = 0;
my $match                = 0;
my $mismatches           = 0;
my $max_mismatches       = $soft_threshold;
my $results              = undef;
my ($t0, $t1)            = 0;

# get the species id from the database
$species_id = Wrapper::Mysql::get_taxid_for_species($speciesname);
unless ($species_id) {
	print $stderr "Fatal: No such species in database: '$speciesname'\n";
	exit(1);
}

# get the set id from the database
$set_id = Wrapper::Mysql::get_set_id($setname);
unless ($set_id) {
	print $stderr "Fatal: No such set in database: '$setname'\n";
	exit(1);
}

# create view (a virtual table) for the log-evalues
Wrapper::Mysql::create_log_evalues_view($species_id)
	or print $stderr "Fatal: Could not create view: $!\n" and exit(1);

# Create the list of reference taxa
# This can be set in the config file, otherwise get all taxa in the set
if ($reference_taxa) { @reftaxa = split(/\s*,\s*/, $reference_taxa) }
else { @reftaxa = Wrapper::Mysql::get_taxa_in_set($set_id) }

# get a orthoid => list_of_aaseq_ids relationship from the db
my $aaseqs_in_orthoid = Wrapper::Mysql::get_orthologs_for_set_hashref($set_id);

# get a log-evalue->count relationship from the database
# classify the log-evalues into "bins" that hold a limited number of values
# this is done in order to speed up the database queries
my $logevalue_count = Wrapper::Mysql::get_logevalue_count($species_id);
my @logevalues = sort { $a <=> $b } keys %$logevalue_count;
my $logevalues_bins = &binify($bin_size, $logevalue_count);

# generate a table
my $transcripts_mapped_to = { };

# this will hold all transcripts that were found so we can check for redundancy
my @transcript_list;

print "The first query may take a while, please be patient...\n" unless $quiet;

# okay let's do the loop come on baby let's do the loop
BIN:
foreach my $bin (@$logevalues_bins) {

	# get the results in the form:
	# evalue => {
	#   orthoid => [
	#     reciprocal_hit,
	#     reciprocal_hit,
	#     reciprocal_hit,
	#     etc.
	#   ]
	# }
	$t0 = scalar time;
	# only one evalue
	if ($bin->{'min'} == $bin->{'max'}) {
		$results = Wrapper::Mysql::get_results_for_logevalue($set_id, $species_id, $bin->{'min'});
	}
	# evalue range
	else {
		$results = Wrapper::Mysql::get_results_for_logevalue($set_id, $species_id, $bin->{'min'}, $bin->{'max'});
	}
	$t1 = scalar time;
	printf $stdout "Fetched %d rows in %.2f seconds\n", scalar keys %$results, $t1 - $t0 if $verbose;

	EVALUE:
	while (my ($logevalue, $result) = each %$results) {
		ORTHOID:
		while (my ($orthoid, $list) = each (%$result)) {
			# reset the mismatch counter
			$mismatches = 0;

			print "Checking $orthoid for ortholog hits...\n" if $verbose;

			

			#-------------------------------------------------- 
			# so, was this a match we can trust?
			if (my $this_match = &get_reciprocal_match($orthoid, $list)) {

				# yeah - here should be the part where the actual sequences are output
				printf $stdout "Orthology detected for %s! Trying to add %s[%d:%d] to %s.\n",
					$orthoid,
					$this_match->{'hmmhit'},
					$this_match->{'start'},
					$this_match->{'end'},
					$orthoid,
					unless $quiet;

				# if this orthoid has been hit before, check whether the new cancidate
				# overlaps with previous hits
				if (exists $transcripts_mapped_to->{$orthoid}) {
					if (&overlap($transcripts_mapped_to->{$orthoid}, $this_match)) {
						# yep, it overlaps, so we can't assign this transcript because better
						# e-values have precedence. just go to the next one
						printf $stdout "Overlap with previous hit for %s: discarded %s.\n", $orthoid, $this_match->{'hmmhit'} unless $quiet;
						next ORTHOID;
					}
					else {
						# does not overlap, add to list of transcripts for this ortholog group
						push @{ $transcripts_mapped_to->{$orthoid} }, $this_match;
						printf $stdout "No overlap with previous hits: added %s to %s.\n", $this_match->{'hmmhit'}, $orthoid unless $quiet;
						# this transcript can't be found again
						push @transcript_list, $this_match->{'hmmhit'};
						# ok, next one
						next ORTHOID;
					}
				}

				# this has not been hit before, just assign
				printf $stdout "Assigned %s to %s\n", $this_match->{'hmmhit'}, $orthoid;
				push @{ $transcripts_mapped_to->{$orthoid} }, $this_match;

				# this transcript can't be found again
				push @transcript_list, $this_match->{'hmmhit'};

				# reset 
				undef $this_match;
			}
			else {
				# this orthoid has no match
				print $stdout "No orthology detected for $orthoid.\n"
					unless $quiet;
			}

		# END ORTHOID
		} 

	# END EVALUE
	}
# END RESULT
}



# a tablefile
my $tfh = IO::File->new($tablefile, 'w')
	or print $stderr "Fatal: Could not open table file $tablefile\: $!\n" and exit(1);

my $fill_with_x = 1;
my $num_n = 0;

# walk the orthologs, concatenate in order if multiple
while (my ($orthoid, $transcripts) = each %$transcripts_mapped_to) {
	my ($hdr, $seq, $prev_end);
	$transcripts = [ sort { $a->{'start'} <=> $b->{'start'} } @$transcripts ];
	print $tfh $orthoid;
	foreach my $hit (@$transcripts) {
		my $corresponding_nuc = Wrapper::Mysql::get_nuc_for_pep($hit->{'blast_hit'});
		exit;
		my $length = $hit->{'end'} - $hit->{'start'};
		printf $tfh "\t%s[%d:%d]",
			$hit->{'hmmhit'},
			$hit->{'start'},
			$hit->{'end'};
		if ($fill_with_x) {
			if (defined $prev_end) {
				my $xes = 'X' x ($hit->{'start'} - $prev_end);
				$seq .=  $xes . $hit->{'sequence'};
			}
			$prev_end = $hit->{'end'};
			$seq .= $hit->{'sequence'};
		}
		else {
			$seq .= $hit->{'sequence'};
		}
	}
	print $tfh "\n";

	# get the core ortholog sequences for this group
	my $core_sequences = Wrapper::Mysql::get_ortholog_group($set_id, $orthoid);
	# new fasta file
	my $fafh = IO::File->new(File::Spec->catfile($aaoutdir, $orthoid . '.fa'), 'w');
	# print the core orthologs
	printf $fafh ">%s\n%s\n", $$_[0], $$_[1] foreach (@$core_sequences);
	# join the headers
	$hdr = join ' ', ( map { $_->{'header'} . ':[' . $_->{'start'} . '-' . $_->{'end'} . ']' } @$transcripts );
	# print the concatenated sequence
	printf $fafh ">%s\n%s\n", $hdr, $seq;
	undef $fafh;
}
undef $tfh;

# yay
exit;


=head2 binify(BIN_SIZE, VALUE_COUNT)

binifies a value->count hashref, i.e. generates an arrayref of bins (order
based on the numerical order of the hash keys), each of which contain a hashref
with the min and max boundary of the bin:

  [
    {
      'min' => min(THIS_BIN),
      'max' => max(THIS_BIN)
    },
    { 
      'min' => min(THIS_BIN),
      'max' => max(THIS_BIN)
    }
  ]

This is useful for constructing database queries using BETWEEN filters, because
these would take forever on very large datasets.

=cut

sub binify {
	my $bin_size    = shift;
	my $value_count = shift;
	my $bins        = [ ];
	my $sum         = 0;
	my @bin         = ( );
	foreach my $value (sort {$a <=> $b} keys %$value_count) {
		# if adding this count would not exceed the bin size
		if ($sum + $value_count->{$value} < $bin_size) {
			push @bin, $value;
			$sum += $value_count->{$value};
		}
		# this is too large, start a new bin
		else {
			# if the bin has content
			if (scalar @bin) {
				# put min and max into @$bins
				push @$bins, { 'min' => min(@bin), 'max' => max(@bin) };
				# empty this bin
				@bin = ( );
				$sum = 0;
			}
			# put this count into the bin
			push @bin, $value;
			$sum += $value_count->{$value};
		}
	}
	# in case there is only one bin (happens when there are only few results), return that
	if (scalar @$bins == 0) { push @$bins, { 'min' => min(@bin), 'max' => max(@bin) } }
	return $bins;
}

sub get_reciprocal_match {
	my $orthoid = shift;
	my $list = shift;
	foreach my $reciprocal_hit ( sort { $a->{'blast_evalue'} <=> $b->{'blast_evalue'} } @$list ) {
		# find out if the aaseq_id is one of those used for this orthoid
		#print $stdout "  checking out hit " , Dumper($reciprocal_hit) if $verbose;

		# has this aaseq been used in building this hmm and has this transcript
		# not been found previously? 
		# the function first from List::Util returns after the first occurence. 
		if ( first { /$reciprocal_hit->{'blast_hit'}/ } @{$aaseqs_in_orthoid->{$orthoid}}
			and not first {/$reciprocal_hit->{'hmmhit'}/} @transcript_list ) {

			print $stdout "    reciprocal hit $reciprocal_hit->{'blast_hit'} used in $orthoid!\n" if $verbose;

			$match = $reciprocal_hit;

			# one hit is enough if not in strict mode
			return $match unless $strict;
		}
		else {  # not found
			# cry
			++$mismatches;
			print $stdout "    reciprocal hit $reciprocal_hit->{'blast_hit'} not used in this HMM (mismatch #", $mismatches, ") :(\n" if $verbose;

			# in a strict search, that's it for this orthoid
			return undef if $strict;

			# no match
			undef $match;

			# too many mismatches, we don't trust this one anymore
			if ($mismatches >= $max_mismatches) {
				print $stdout "    Too many mismatches, we don't trust this one anymore.\n" if $verbose;
				return undef;
			}
		}

	# END RH
	}
}

sub overlap {
	my $already_matched = shift;
	my $candidate = shift;
	my $overlap   = 0;
	# the fragments do not overlap
	for (my $i = 0; $i < scalar @$already_matched; ++$i) {
		if ($$candidate{'end'} <= $$already_matched[$i]{'start'} or $$candidate{'start'} >= $$already_matched[$i]{'end'}) {
			printf $stdout "%s[%d:%d] and %s[%d:%d] do not overlap.\n", 
				$$already_matched[$i]{'hmmhit'},
				$$already_matched[$i]{'start'},
				$$already_matched[$i]{'end'},
				$$candidate{'hmmhit'},
				$$candidate{'start'},
				$$candidate{'end'}
					if $verbose;
			$overlap = 0;
		}
		# the fragments do overlap
		else {
			printf $stdout "%s[%d:%d] and %s[%d:%d] overlap.\n", 
				$$already_matched[$i]{'hmmhit'},
				$$already_matched[$i]{'start'},
				$$already_matched[$i]{'end'},
				$$candidate{'hmmhit'},
				$$candidate{'start'},
				$$candidate{'end'}
					if $verbose;
		 	return 1;
		}
	}
	if ($overlap == 0) { return 0 }
	return 1;
}
