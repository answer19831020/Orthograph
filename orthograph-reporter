#!/usr/bin/env perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2013 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write clean code
use warnings;       # cry if something seems odd
use autodie;        # die automatically on I/O functions

# Core modules
use Carp;           # carp and croak: warn and die with call stack
use Data::Dumper;   # great for debugging
use DBI;            # database interface
use FindBin;        # locate the dir of this script during compile time
use Getopt::Long;   # command line options
use IO::File;       # object-oriented access to files
use List::Util qw( first min max sum );  # list functions
use Time::HiRes;    # high-resolution timer

# Custom modules
use lib $FindBin::Bin;                 # $Bin is the directory of the original script
use Orthograph::Config;                # configuration in global hashref $config
use Orthograph::Functions;             # functions for all Orthograph tools
use Orthograph::Ortholog;              # ortholog class
use Wrapper::Mysql;
use Wrapper::Exonerate;
use IO::Tee;

my $config = $Orthograph::Config::config;	# copy config variables

# which database engine do we use?
my $database_engine = $config->{'database-engine'};
my $use_mysql               = $database_engine eq 'mysql'  ? 1 : 0;
my $use_sqlite              = $database_engine eq 'sqlite' ? 1 : 0;

# database settings
my $db_table_blast          = $config->{'db_table_blast'};
my $db_table_blastdbs       = $config->{'db_table_blastdbs'};
my $db_table_ests           = $config->{'db_table_ests'};
my $db_table_hmmsearch      = $config->{'db_table_hmmsearch'};
my $db_table_set_details    = $config->{'db_table_set_details'};
my $db_table_aaseqs         = $config->{'aaseqs'};
my $db_table_seqpairs       = $config->{'sequence-pairs'};
my $db_table_taxa           = $config->{'taxa'};
my $db_table_orthologs      = $config->{'orthologs'};

# directory and output settings
my $outdir                     = $config->{'output-directory'};
my $aaoutdir                   = File::Spec->catdir($outdir, $config->{'aaoutdir'});
my $ntoutdir                   = File::Spec->catdir($outdir, $config->{'ntoutdir'});
my $logdir                     = File::Spec->catdir($outdir, 'log');
my $debug                      = $config->{'debug'};
my $quiet                      = $config->{'quiet'};
my $verbose                    = $config->{'verbose'};
my $sep                        = $config->{'header-separator'};

# settings for this specific analysis
my $blast_evalue_threshold     = $config->{'blast-evalue-threshold'};
my $exonerate_program          = $config->{'exonerate-program'};
my $hmmsearch_evalue_threshold = $config->{'hmmsearch-evalue-threshold'};
my $hmmsearch_score_threshold  = $config->{'hmmsearch-score-threshold'};
my $reference_taxa             = $config->{'reference-taxa'};
my $setname                    = $config->{'ortholog-set'};
my $soft_threshold             = $config->{'soft-threshold'};
my $speciesname                = $config->{'species-name'};

# open log and table output files 
my $logfile = File::Spec->catfile($logdir, 'report.log');
my $logfh = IO::File->new($logfile, 'w')
	or die "Fatal: Could not open report file '$logfile'\: $!\n";
my $tablefile = File::Spec->catfile($logdir, 'table.txt');

# setup IO::Tee
my $stdout = IO::Tee->new(
	\*STDOUT,
	$logfh,
);
my $stderr = IO::Tee->new(
	\*STDERR,
	$logfh,
);

# mutually exclusive options
if ($verbose and $quiet) {
	print $stderr "Fatal: Can't operate in both verbose and quiet mode\n";
	exit(1);
}

# also be verbose if debugging
if ($debug) { $verbose = 1 }

# mutually exclusive options
if ($hmmsearch_evalue_threshold and $hmmsearch_score_threshold) {
	print $stderr "Fatal: Can't use both e-value and score thresholds\n";
	exit(1);
}

# More variables
my $bin_size             = 500;
my $count                = 0;
my $data_by_orthoid      = { };
my $out                  = { };
my $data_by_transcript   = { };
my $data_by_evalue       = { };
my $hitcount             = 0;
my $insert_n             = 1;
my $table                = [ ];
my $strict               = 0;
my @reftaxa              = ( );
my $species_id           = 0;
my $set_id               = 0;
my $match                = 0;
my $mismatches           = 0;
my $max_mismatches       = $soft_threshold;
my $results              = undef;
my ($t0, $t1)            = 0;
my $stats                = { };
my $starttime            = scalar time;
my $endtime              = 0;
my $totaltime            = 0;

# get the species id from the database
$species_id = get_taxid_for_species($speciesname);
unless ($species_id) {
	print $stderr "Fatal: No such species in database: '$speciesname'\n";
	exit(1);
}

# get real table names
($db_table_ests, $db_table_hmmsearch, $db_table_blast) = Wrapper::Mysql::get_real_table_names($species_id);

# get the set id from the database
$set_id = Wrapper::Mysql::get_set_id($setname);
unless ($set_id) {
	print $stderr "Fatal: No such set in database: '$setname'\n";
	exit(1);
}

# Create the list of reference taxa
# This can be set in the config file, otherwise get all taxa in the set
if ($reference_taxa) { @reftaxa = split(/\s*,\s*/, $reference_taxa) }
else { @reftaxa = Wrapper::Mysql::get_taxa_in_set($set_id) }

# get an orthoid => list_of_aaseq_ids relationship from the db
my $aaseqs_in_orthoid = Wrapper::Mysql::get_orthologs_for_set_hashref($set_id);

# create view (a virtual table) for the log-evalues
Wrapper::Mysql::create_scores_view($species_id)
	or print $stderr "Fatal: Could not create view: $!\n" and exit(1);


my @scores = Wrapper::Mysql::get_scores_list();

my $seen = {};
my $c = 0;
my $c_orthologs = 0;
my $c_nonorthologs = 0;
my $transcripts_mapped_to = {};

my $start = int time;

foreach my $score (@scores) {
	# this is an array of arrays, there may be multiple results with the same score
	my $hmmresults = Wrapper::Mysql::get_hmmresult_for_score($score);
	printf $stdout "Evaluating score %.1f...\n", $score
		unless $quiet;
	++$c;
	HMMHIT:
	foreach my $hmmhit (@$hmmresults) {
		printf $stdout "Evaluating HMM target %s[%d-%d]...\n", $hmmhit->{'target'}, $hmmhit->{'hmm_start'}, $hmmhit->{'hmm_end'} if $debug;
		my $orthoid   = $hmmhit->{'query'};
		my $digest    = $hmmhit->{'target'};

		# skip transcripts we have already handled
		if (seen_this_region_before($hmmhit)) {
			printf $stdout "Seen %s[%d] before (%d rows), skipping\n",
				$digest,
				$hmmhit->{'hmm_start'},
				$c,
					if $verbose;
			next;
		}
		my $blastresults = Wrapper::Mysql::get_blastresult_for_digest($digest);
		my $mismatches = 0;
		foreach my $blasthit (@$blastresults) {
			# ok, we got a reciprocal hit
			if (reciprocal_best_hit($blasthit, $aaseqs_in_orthoid->{$orthoid})) {
				printf $stdout "Orthology detected (%d in %s)! Trying to add %s[%d:%d] to %s.\n",
					$blasthit->{'target'},
					$orthoid,
					$hmmhit->{'target'},
					$hmmhit->{'hmm_start'},
					$hmmhit->{'hmm_end'},
					$orthoid,
						if $verbose;

				# if this orthoid has been hit before, check whether the new cancidate
				# overlaps on hmm (gene) level with previous hits
				if (exists $transcripts_mapped_to->{$orthoid}) {
					if (hmm_overlap($transcripts_mapped_to->{$orthoid}, $hmmhit)) {
						# yep, it overlaps, so we can't assign this transcript because better
						# scores have precedence. just go to the next one
						printf $stdout "Overlap with previous hit on hmm level for %s: discarded %s.\n", $orthoid, $hmmhit->{'target'} if $verbose;
						next HMMHIT;
					}
					# or does it overlap on transcript level?
					elsif (transcript_overlap($transcripts_mapped_to->{$orthoid}, $hmmhit)) {
						printf $stdout "Overlap with previous hit on transcript level for %s: discarded %s.\n", $orthoid, $hmmhit->{'target'} if $verbose;
						next HMMHIT;
					}
					else {
						# this is a valid hit, make an ortholog object and add it to the list of hits
						my $ortholog_transcript = Orthograph::Ortholog->new($hmmhit);
						$ortholog_transcript->hmm_name($orthoid);
						$ortholog_transcript->hmm_target($hmmhit->{'target'});
						$ortholog_transcript->blast_query($digest);
						$ortholog_transcript->blast_target($blasthit->{'target'});

						add_to_ortholog_group($orthoid, $ortholog_transcript);

						printf $stdout "No overlap with previous hits: added %s[%d:%d] to %s\n", 
							$ortholog_transcript->hmm_target(),
							$ortholog_transcript->hmm_start(),
							$ortholog_transcript->hmm_end(),
							$orthoid,
								unless $quiet;

						++$c_orthologs;
						next HMMHIT;
					}
				}
				else {
					# this is a valid hit, make an ortholog object and add it to the list of hits
					my $ortholog_transcript = Orthograph::Ortholog->new($hmmhit);
					$ortholog_transcript->hmm_name($orthoid);
					$ortholog_transcript->hmm_target($hmmhit->{'target'});
					$ortholog_transcript->blast_query($digest);
					$ortholog_transcript->blast_target($blasthit->{'target'});

					add_to_ortholog_group($orthoid, $ortholog_transcript);

					printf $stdout "Added %s[%d:%d] to %s\n", 
						$hmmhit->{'target'},
						$hmmhit->{'hmm_start'},
						$hmmhit->{'hmm_end'},
						$orthoid,
							unless $quiet;

					++$c_orthologs;
					next HMMHIT;
				}
			}
			else {
				++$mismatches;
				printf $stdout "%s not in %s: no joy (%d mismatches)\n",
					$blasthit->{'target'},
					$orthoid,
					$mismatches
						if $verbose;
				if ($mismatches >= $max_mismatches) {
					print $stdout "Too many mismatches, we don't trust this one anymore\n" if $verbose;
					++$c_nonorthologs;
					next HMMHIT;
				}
			}
		}
	}
}
my $end = int time;
printf "Took %d seconds to find %d orthologs and %d non-orthologs\n", $end-$start, scalar keys %$transcripts_mapped_to, $c_nonorthologs;

print "Finished fetching from the database.\n";
print "Starting output.\n";

#print Dumper $transcripts_mapped_to; exit;


# a tablefile
my $tfh = IO::File->new($tablefile, 'w')
	or print $stderr "Fatal: Could not open table file $tablefile\: $!\n" and exit(1);

my $fill_with_x = 1;
my $num_n = 0;

# walk the orthologs, concatenate in order if multiple
ORTHOID:
while (my ($orthoid, $transcripts) = each %$transcripts_mapped_to) {
	my ($hdr_aa, $hdr_nt, $seq, $cdnaseq, $prev_end);
	$hitcount = 0;
	my $firsttime = 1;
	$transcripts = [ sort { $a->hmm_start() <=> $b->hmm_start() } @$transcripts ];

	print "Evaluating $orthoid...\n";
	# each reciprocal hit
	HIT:
	foreach my $hit (@$transcripts) {
		++$hitcount;

		# get the sequences from the database
		my $proteome_sequence = Wrapper::Mysql::get_reference_sequence($hit->blast_target());
		my $est_sequence = Wrapper::Mysql::get_nucleotide_transcript_for($hit->hmm_target());

		# trim the transcript sequence to the domain coordinates
		$proteome_sequence = substr($proteome_sequence, $hit->env_start-1, $hit->env_end() - $hit->env_start()-1);

		# exonerate the orf (correct for frameshifts etc and produce corresponding nt sequence)
		my ($orf_aa_sequence, $orf_cdna_sequence) = get_orf($proteome_sequence, $est_sequence);
		($hit->{'orf_aa_sequence'}, $hit->{'orf_cdna_sequence'}) = get_orf($proteome_sequence, $est_sequence);

		# exonerate didn't get an alignment
		if ($hit->{'orf_cdna_sequence'}) {
			printf $stdout "Got this ORF for %s[%d-%d]:\n%s\n",
				$hit->hmm_target(),
				$hit->env_start(),
				$hit->env_end(),
				$hit->{'orf_cdna_sequence'}
					if $debug;

			# write the ortholog gene id to the table, but only once
			if ($firsttime) {
				print $tfh $orthoid;
				$firsttime = 0;
			}

			# write the transcripts to the table
			printf $tfh "\t%s[len %d]",
				$hit->hmm_target(),                 # transcript ID
				length $hit->{'orf_aa_sequence'}, # ORF sequence length
			;
			# before concatenating, fill gaps with 'X' if desired
			if ($fill_with_x) {
				if (defined $prev_end) {
					my $num_x = $hit->hmm_start() - $prev_end;
					my $xes = 'X' x $num_x;
					# 'N' sequences to fill the cdna sequence are three times longer
					my $ns  = 'N' x ($num_x * 3);
					$seq .=  $xes;
					$cdnaseq .= $ns;
					print $stdout "Added $num_x 'X' to sequence\n" if $debug;
				}
				$prev_end = $hit->hmm_end();
			}
			# concatenate
			$hit->real_header( Wrapper::Mysql::get_real_header($hit->hmm_target()) );
			$hdr_aa .= $hit->real_header() . ':[len ' . length($hit->{'orf_aa_sequence'}) . ']';
			$hdr_nt .= $hit->real_header() . ':[len ' . length($hit->{'orf_cdna_sequence'}) . ']';
			$seq .= $hit->{'orf_aa_sequence'};
			$cdnaseq .= $hit->{'orf_cdna_sequence'};
			print $stdout "Concatenated sequences\n" if $debug;
		}
		else {
			if ($verbose) {
				printf $stdout "Could not get an ORF for %s[%d-%d] and %s\n",
					$hit->hmm_target(),
					$hit->env_start(),
					$hit->env_end(),
					$hit->blast_target(),
				;
				print $stdout "Skipping this transcript\n";
			}
			next HIT;
		}
	}

	print $tfh "\n";

	# skip the rest since no sequence could be gathered
	unless (defined $seq) {
		print $stdout "No ORFs found for this orthoid, skipping...\n" if $verbose;
		next ORTHOID;
	}

	# get the core ortholog sequences for this group
	my $core_sequences = Wrapper::Mysql::get_ortholog_group($set_id, $orthoid);
	# new fasta file
	my $fafh = IO::File->new(File::Spec->catfile($aaoutdir, $orthoid . '.fa'), 'w');
	# print the core orthologs
	printf $fafh ">%s\n%s\n", $$_[0], $$_[1] foreach (@$core_sequences);
	# print the concatenated sequence
	printf $fafh ">%s\n%s\n", $hdr_aa, $seq;
	undef $fafh;
 
	# do the same for the nucleotide sequences
	my $core_sequences_nt = Wrapper::Mysql::get_ortholog_group_nucleotide($set_id, $orthoid);
	# new fasta file
	$fafh = IO::File->new(File::Spec->catfile($ntoutdir, $orthoid . '.fa'), 'w');
	# print the core orthologs
	printf $fafh ">%s\n%s\n", $$_[0], $$_[1] foreach (@$core_sequences_nt);
	# print the concatenated sequence
	printf $fafh ">%s\n%s\n", $hdr_nt, $cdnaseq;
	undef $fafh;
}
undef $tfh;

# yay
$endtime = scalar time;
$totaltime = $endtime - $starttime;
print $stdout "## Orthograph report for $speciesname completed in $totaltime total seconds\n";
exit;


=head2 binify(BIN_SIZE, VALUE_COUNT)

binifies a value->count hashref, i.e. generates an arrayref of bins (order
based on the numerical order of the hash keys), each of which contain a hashref
with the min and max boundary of the bin:

  [
    {
      'min' => min(THIS_BIN),
      'max' => max(THIS_BIN)
    },
    { 
      'min' => min(THIS_BIN),
      'max' => max(THIS_BIN)
    }
  ]

This is useful for constructing database queries using BETWEEN filters, because
these would take forever on very large datasets.

=cut

sub binify {
	my $bin_size    = shift;
	my $value_count = shift;
	my $bins        = [ ];
	my $sum         = 0;
	my @bin         = ( );
	foreach my $value (sort {$b <=> $a} keys %$value_count) {
		# if adding this count would not exceed the bin size
		if ($sum + $value_count->{$value} < $bin_size) {
			push @bin, $value;
			$sum += $value_count->{$value};
		}
		# this is too large, start a new bin
		else {
			# if the bin has content
			if (scalar @bin) {
				# put min and max into @$bins
				push @$bins, { 'min' => min(@bin), 'max' => max(@bin) };
				# empty this bin
				@bin = ( );
				$sum = 0;
			}
			# put this count into the bin
			push @bin, $value;
			$sum += $value_count->{$value};
		}
	}
	# in case there is only one bin (happens when there are only few results), return that
	if (scalar @$bins == 0) { push @$bins, { 'min' => min(@bin), 'max' => max(@bin) } }
	return $bins;
}

sub reciprocal_best_hit {
	my $blasthit = shift;
	my $aaseqs_in_orthoid = shift;
	if (grep /$blasthit->{'target'}/, @$aaseqs_in_orthoid) {
		return 1;
	}
	else {
		return 0;
	}
}

sub get_reciprocal_match {
	my $orthoid = shift;
	my $list_of_hits = shift;
	foreach my $reciprocal_hit ( sort { $a->{'blast_evalue'} <=> $b->{'blast_evalue'} } @$list_of_hits ) {
		# has this aaseq been used in building this hmm and has this transcript
		# not been found previously? 
		if ( first { /$reciprocal_hit->{'blast_hit'}/ } @{$aaseqs_in_orthoid->{$orthoid}}
			and not first {/$reciprocal_hit->{'hmmhit'}/} @$list_of_hits ) {

			print $stdout "    reciprocal hit $reciprocal_hit->{'blast_hit'} for $reciprocal_hit->{'hmmhit'} used in $orthoid!\n" if $verbose;

			$match = $reciprocal_hit;

			# one hit is enough if not in strict mode
			return $match unless $strict;
		}
		else {  # not found
			# cry
			++$mismatches;
			print $stdout "    reciprocal hit $reciprocal_hit->{'blast_hit'} not used in this HMM (mismatch #", $mismatches, ") :(\n" if $verbose;

			# in a strict search, that's it for this orthoid
			return undef if $strict;

			# no match
			undef $match;

			# too many mismatches, we don't trust this one anymore
			if ($mismatches >= $max_mismatches) {
				print $stdout "    Too many mismatches, we don't trust this one anymore.\n" if $verbose;
				return undef;
			}
		}

	# END RH
	}
}

sub insert_candidate {
	my $already_assigned = shift;
	my $candidate = shift;
	# insert the candidate at the appropriate position and return the arrayref of
	# assigned transcripts
}

sub hmm_overlap {
	my $already_assigned = shift;
	my $candidate = shift;
	# test whether the candidate overlaps on hmm level, return 1 or 0
	foreach my $assigned_transcript (@$already_assigned) {
		# the hmm coords do not overlap
		if ($$candidate{'hmm_end'} <= $$assigned_transcript{'hmm_start'} or $$candidate{'hmm_start'} >= $$assigned_transcript{'hmm_end'}) {
			print_no_overlap($candidate, $assigned_transcript)
				if $verbose;
		}
		else {
			print_overlap($candidate, $assigned_transcript)
				if $verbose;
			return 1;
		}
	}
	return 0;
}

sub transcript_overlap {
	my $already_assigned = shift;
	my $candidate = shift;
	# test whether the candidate overlaps on transcript level, return 1 or 0
	foreach my $assigned_transcript (@$already_assigned) {
		# the transcript coords do not overlap
		if ($$candidate{'env_end'} <= $$assigned_transcript{'env_start'} or $$candidate{'env_start'} >= $$assigned_transcript{'env_end'}) {
			print_no_overlap($candidate, $assigned_transcript)
				if $verbose;
		}
		else {
			print_overlap($candidate, $assigned_transcript)
				if $verbose;
			return 1;
		}
	}
	return 0;
}

sub print_overlap {
	my $candidate = shift;
	my $transcript = shift;
	printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) overlap.\n", 
		$$transcript{'target'},
		$$transcript{'env_start'},
		$$transcript{'env_end'},
		$$transcript{'hmm_start'},
		$$transcript{'hmm_end'},
		$$candidate{'target'},
		$$candidate{'env_start'},
		$$candidate{'env_end'},
		$$candidate{'hmm_start'},
		$$candidate{'hmm_end'}
	;
}

sub print_no_overlap {
	my $candidate = shift;
	my $transcript = shift;
	printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) do not overlap.\n", 
		$$transcript{'target'},
		$$transcript{'env_start'},
		$$transcript{'env_end'},
		$$transcript{'hmm_start'},
		$$transcript{'hmm_end'},
		$$candidate{'target'},
		$$candidate{'env_start'},
		$$candidate{'env_end'},
		$$candidate{'hmm_start'},
		$$candidate{'hmm_end'}
	;
}

=head2 overlap

Calculates whether or not a given transcript overlaps with already assigned other transcripts, on both HMM (=OG) coordinates and transcript coordinates (env coords).

Returns 0 if nothing overlaps.
Returns 1 if the candidate overlaps only on transcript coordinates, but not on the HMM.
Returns 2 if the candidate overlaps on the HMM coords. This should not be accepted.

Arguments: arrayref (already matched transcripts), hashref (candidate transcript)

=cut

sub overlap {
	my $already_assigned = shift;
	my $candidate = shift;
	my $overlap   = 0;
	for (my $i = 0; $i < scalar @$already_assigned; ++$i) {
		# the hmm coords do not overlap
		if ($$candidate{'hmm_end'} <= $$already_assigned[$i]{'hmm_start'} or $$candidate{'hmm_start'} >= $$already_assigned[$i]{'hmm_end'}) {
			# the transcript coords do not overlap
			if ($$candidate{'env_end'} <= $$already_assigned[$i]{'env_start'} or $$candidate{'env_start'} >= $$already_assigned[$i]{'env_end'}) {
				printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) do not overlap.\n", 
					$$already_assigned[$i]{'hmmhit'},
					$$already_assigned[$i]{'env_start'},
					$$already_assigned[$i]{'env_end'},
					$$already_assigned[$i]{'hmm_start'},
					$$already_assigned[$i]{'hmm_end'},
					$$candidate{'hmmhit'},
					$$candidate[$i]{'env_start'},
					$$candidate[$i]{'env_end'},
					$$candidate{'hmm_start'},
					$$candidate{'hmm_end'}
						if $verbose;
				# this is ok, best case
			}
			# the transcript coords overlap
			elsif ($$candidate{'env_end'} >= $$already_assigned[$i]{'env_start'} or $$candidate{'env_start'} <= $$already_assigned[$i]{'env_end'}) {
				printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) do overlap.\n", 
					$$already_assigned[$i]{'hmmhit'},
					$$already_assigned[$i]{'env_start'},
					$$already_assigned[$i]{'env_end'},
					$$already_assigned[$i]{'hmm_start'},
					$$already_assigned[$i]{'hmm_end'},
					$$candidate{'hmmhit'},
					$$candidate[$i]{'env_start'},
					$$candidate[$i]{'env_end'},
					$$candidate{'hmm_start'},
					$$candidate{'hmm_end'}
						if $verbose;
				return 1;  # this is not ok, the transcript coords should be unified
			}
		}
		# the hmm coords overlap
		else {
			# this is totally not ok
			printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) overlap.\n", 
				$$already_assigned[$i]{'hmmhit'},
				$$already_assigned[$i]{'env_start'},
				$$already_assigned[$i]{'env_end'},
				$$already_assigned[$i]{'hmm_start'},
				$$already_assigned[$i]{'hmm_end'},
				$$candidate{'hmmhit'},
				$$candidate[$i]{'env_start'},
				$$candidate[$i]{'env_end'},
				$$candidate{'hmm_start'},
				$$candidate{'hmm_end'}
					if $verbose;
			return 2;
		}
	}
	if ($overlap == 0) { return 0 }
	return 2;
}

sub transcripts_overlap {
	my $already_matched = shift;
	my $candidate = shift;
	my $overlap = 0;
	foreach my $assigned_transcript (@$already_matched) {
		# the candidate is either before or after the already assigned transcript
		# this is ok
		if ($$candidate{'env_end'} <= $$assigned_transcript{'env_start'} or $$candidate{'env_start'} >= $$assigned_transcript{'env_end'}) {
			printf $stdout "%s[%d:%d] (hmm %d:%d) and %s[%d:%d] (hmm %d:%d) do not overlap.\n", 
				$$already_matched{'hmmhit'},
				$$already_matched{'env_start'},
				$$already_matched{'env_end'},
				$$already_matched{'hmm_start'},
				$$already_matched{'hmm_end'},
				$$candidate{'hmmhit'},
				$$candidate{'env_start'},
				$$candidate{'env_end'},
				$$candidate{'hmm_start'},
				$$candidate{'hmm_end'}
					if $verbose;
			# this is ok, best case
		}
		else {
			
		}
	}
}


# Finds the ORF for two sequences by aligning them using Exonerate. The program
# clips sequences if it detects frameshift errors and stuff like that.

sub get_orf {
	my $proteome_sequence = shift;
	my $est_sequence      = shift;
	unless ($proteome_sequence and $est_sequence) { return undef }
	Wrapper::Exonerate->outdir($logdir);
	my $alignment = Wrapper::Exonerate->new($proteome_sequence, $est_sequence);
	$alignment->search();
	unless ($alignment->cdna_sequence()) { return undef }
	return ($alignment->aa_sequence(), $alignment->cdna_sequence(), $alignment->cdna_start(), $alignment->cdna_end());
}

sub add_to_ortholog_group {
	my $orthoid = shift;
	my $new_ortholog = shift;
	push @{$transcripts_mapped_to->{$orthoid}}, $new_ortholog;
}

sub seen_this_region_before {
	my $hmmhit = shift;
	while (my ($orthoid, $list_of_orthologs) = each %$transcripts_mapped_to) {
		if ( grep {
			# same transcript that got hit?
			$hmmhit->{'target'} eq $_->hmm_target()
			# and in a region that was hit before?
			and ($hmmhit->{'hmm_start'} >= $_->hmm_start() or $hmmhit->{'hmm_end'} <= $_->hmm_end())
			} @$list_of_orthologs ) {
			# then we don't need this
			return 1;
		}
	# otherwise, this is ok
	}
	return 0;
}

sub get_taxid_for_species {
	my $sn = shift;
	print "getting taxid for $sn\n";
	if ($use_mysql) { return Wrapper::Mysql::get_taxid_for_species($sn) }
	elsif ($use_sqlite) { return Wrapper::Sqlite::get_taxid_for_species($sn) }
}
