#!/usr/bin/env perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2012 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write clean code
use warnings;       # cry if something seems odd

# Core modules
use Carp;           # carp and croak: warn and die with call stack
use Data::Dumper;   # great for debugging
use DBD::mysql;     # MySQL database driver
use DBI;            # database interface
use FindBin;        # locate the dir of this script during compile time
use Getopt::Long;   # command line options
use IO::File;       # object-oriented access to files
use List::Util qw( min max sum );
use Time::HiRes;    # high-resolution timer
#use Devel::Size qw( total_size );  # get total memory size of variables

# Custom modules
use lib $FindBin::Bin;                 # $Bin is the directory of the original script
use Orthograph::Config;                # configuration in global hashref $config
use Orthograph::Functions;             # functions for all Orthograph tools
use Wrapper::Mysql;
use IO::Tee;

my $config = $Orthograph::Config::config;	# copy config var

# MySQL settings
my $mysql_table_blast          = $config->{'mysql_table_blast'};
my $mysql_table_blastdbs       = $config->{'mysql_table_blastdbs'};
my $mysql_table_ests           = $config->{'mysql_table_ests'};
my $mysql_table_hmmsearch      = $config->{'mysql_table_hmmsearch'};
my $mysql_table_set_details    = $config->{'mysql_table_set_details'};
my $mysql_table_aaseqs         = $config->{'aaseqs'};
my $mysql_table_seqpairs       = $config->{'sequence_pairs'};
my $mysql_table_taxa           = $config->{'taxa'};
my $mysql_table_orthologs      = $config->{'orthologs'};

my $outdir                     = $config->{'output_directory'};
my $quiet                      = $config->{'quiet'};
my $verbose                    = $config->{'verbose'};

my $setname                    = $config->{'ortholog_set'};
my $speciesname                = $config->{'species_name'};
my $reference_taxa             = $config->{'reference_taxa'};

my $blast_evalue_threshold     = $config->{'blast_evalue_threshold'};
my $soft_threshold             = $config->{'soft_threshold'};
my $hmmsearch_evalue_threshold = $config->{'hmmsearch_evalue_threshold'};
my $hmmsearch_score_threshold  = $config->{'hmmsearch_score_threshold'};

my $outputdir                  = $config->{'output_directory'};
my $logdir                     = File::Spec->catdir($outputdir, 'log');

# mutually exclusive options
die "Fatal: Can't operate in both verbose and quiet mode\n"
	if ($verbose and $quiet);

# mutually exclusive options
die "Fatal: Can't use both e-value and score thresholds\n"
	if ($hmmsearch_evalue_threshold and $hmmsearch_score_threshold);

# More variables
my $bin_size             = 500;
my $count                = 0;
my $data_by_orthoid      = { };
my $out                  = { };
my $data_by_transcript   = { };
my $data_by_evalue       = { };
my $table                = [ ];
my $strict               = 0;
my $sort_by              = 'blasteval';
my @reftaxa              = ( );
my $species_id           = 0;
my $set_id               = 0;
my $match                = 0;
my $mismatches           = 0;
my $max_mismatches       = $soft_threshold;
my ($t0, $t1)            = 0;

# get the species id from the database
$species_id = Wrapper::Mysql::get_taxid_for_species($speciesname);
die "Fatal: No such species in database: '$speciesname'\n" unless ($species_id);

# get the set id from the database
$set_id = Wrapper::Mysql::get_set_id($setname);
die "Fatal: No such set in database: '$setname'\n" unless ($set_id);

# Create the list of reference taxa
# This can be set in the config file, otherwise get all taxa in the set
if ($reference_taxa) { @reftaxa = split(/\s*,\s*/, $reference_taxa) }
else { @reftaxa = Wrapper::Mysql::get_taxa_in_set($set_id) }

# get a orthoid => list_of_aaseq_ids relationship from the db
my $aaseqs_in_orthoid = Wrapper::Mysql::get_orthologs_for_set_hashref($set_id);

my $logevalue_count = Wrapper::Mysql::get_logevalue_count();
my @logevalues = sort { $a <=> $b } keys %$logevalue_count;

my $logevalues_bins = &binify($bin_size, $logevalue_count);

# generate a table
my $transcripts_mapped_to = { };

# get the results in the form:
# evalue => {
#   orthoid => [
#     reciprocal_hit,
#     reciprocal_hit,
#     reciprocal_hit,
#     etc.
#   ]
# }
my $limit = 2000;
my $offset = 0;
my $from = -999;
my $to   = -600;
my $results;

# this will hold all transcripts that were found so we can check for redundancy
my @transcript_list;

# open log and table output files 
my $logfile = File::Spec->catfile($logdir, 'report.txt');
my $logfh = IO::File->new($logfile, 'w')
	or die "Fatal: Could not open report file $logfile\: $!\n";
my $tablefile = File::Spec->catfile($logdir, 'table.txt');

# setup IO::Tee
my $stdout = IO::Tee->new(
	\*STDOUT,
	$logfh,
);

# okay let's do the loop come on baby let's do the loop
BIN:
foreach my $bin (@$logevalues_bins) {

	print Dumper($bin);
	# only one evalue
	if ($bin->{'min'} == $bin->{'max'}) {
		$t0 = scalar time;
		$results = Wrapper::Mysql::get_results_for_logevalue($set_id, $species_id, $bin->{'min'});
		$t1 = scalar time;
		if ($verbose) { printf $stdout "Fetched %d rows in %.2f seconds\n", scalar @$results, $t1 - $t0 }
	}
	else {
		$t0 = scalar time;
		$results = Wrapper::Mysql::get_results_for_logevalue_range($set_id, $species_id, $bin->{'min'}, $bin->{'max'});
		$t1 = scalar time;
		if ($verbose) { printf $stdout "Fetched %d rows in %.2f seconds\n", scalar @$results, $t1 - $t0 }
	}

	EVALUE:
	while (my ($logevalue, $result) = each %$results) {
		ORTHOID:
		while (my ($orthoid, $list) = each (%$result)) {
			# reset the mismatch counter
			$mismatches = 0;

			# has this orthoid been assigned before?
			next ORTHOID unless exists $$aaseqs_in_orthoid{$orthoid};

			# sort by reciprocal hit evalue
			my $sorted_list = [ sort { $$a{'blast_evalue'} <=> $$b{'blast_evalue'} } @$list ];

			#print $stdout "checking out $orthoid with logevalue $logevalue: ", scalar @$sorted_list, " reciprocal hits\n" if $verbose;

			RH:
			foreach my $reciprocal_hit (@$sorted_list) {
				# find out if the aaseq_id is one of those used for this orthoid
				print $stdout "  checking out hit " , Dumper($reciprocal_hit)
					if $verbose;

				# has this aaseq been used in building this hmm and has this not been found previously?
				# grep is the nicer solution but may not be as fast as a loop that we can exit after one match.
				# the first function from List::Util also returns after the first occurence.
				# however no significant difference could be noted between the two in terms of runtime
				# (in a real-life example with arrays of > 4000 elements)
				if (grep(/$$reciprocal_hit{'blast_hit'}/, @{$$aaseqs_in_orthoid{$orthoid}}) and
						not grep(/$$reciprocal_hit{'hmmhit'}/, @transcript_list)) {

					$match = $reciprocal_hit;

					print $stdout "    $$reciprocal_hit{'blast_hit'} used in this HMM!\n"
						if $verbose;

					# one hit is enough if not in strict mode
					last RH unless $strict;
				}
				else {  # not found
					# cry
					print $stdout "    $$reciprocal_hit{'blast_hit'} not used in this HMM (mismatch #", ++$mismatches, ") :(\n"
						if $verbose;

					# in a strict search, that's it for this orthoid
					next ORTHOID if $strict;

					# no match
					undef $match;

					# too many mismatches, we don't trust this one anymore
					if ($mismatches >= $max_mismatches) {
						print $stdout ">>    Too many mismatches, we don't trust this one anymore\n"
							if $verbose;
						next ORTHOID;
					}
				}

			# END RH
			}
			# so, was this a match?
			if ($match) {

				# yeah - here should be the part where the actual sequences are output
				# in fasta format
				printf $stdout ">>    assigned %s to %s (%d with %.1e)\n",
					$$match{'hmmhit'},
					$orthoid,
					$$match{'blast_hit'},
					$$match{'blast_evalue'},
					unless $quiet;

				# this orthoid can't be found again
				delete $$aaseqs_in_orthoid{$orthoid};

				# this transcript can't be found again either
				push @transcript_list, $$match{'hmmhit'};

				$$transcripts_mapped_to{$orthoid} = $match;

				# reset 
				undef $match;
			}
			else {
				# this orthoid has no match
				print $stdout "    $orthoid could not be assigned :((\n"
					unless $quiet;
			}

		# END ORTHOID
		} 

	# END EVALUE
	}
# END RESULT
}



my $tfh = IO::File->new($tablefile, 'w')
	or die "Fatal: Could not open table file $tablefile\: $!\n";
while (my ($o, $t) = each %$transcripts_mapped_to) {
	printf $tfh "%s\t%s\n", $o, $$t{'hmmhit'};
}
undef $tfh;

=head2 binify(BIN_SIZE, VALUE_COUNT)

binifies a value->count hashref, i.e. generates an arrayref of bins (order
based on the numerical order of the hash keys), each of which contain a hashref
with the min and max boundary of the bin:

  [
    {
      'min' => min(THIS_BIN),
      'max' => max(THIS_BIN)
    },
    { 
      'min' => min(THIS_BIN),
      'max' => max(THIS_BIN)
    }
  ]

=cut

sub binify {
	my $bin_size    = shift;
	my $value_count = shift;
	my $bins        = [ ];
	my $sum         = 0;
	my @bin         = ( );
	foreach my $value (sort {$a <=> $b} keys %$value_count) {
		if ($sum + $value_count->{$value} < $bin_size) {
			push @bin, $value;
			$sum += $value_count->{$value};
		}
		else {
			if (scalar @bin) {
				push @$bins, { 'min' => min(@bin), 'max' => max(@bin) };
				@bin = ( );
				$sum = 0;
			}
			push @bin, $value;
			$sum += $value_count->{$value};
		}
	}
	return $bins;
}

# yay
exit;


