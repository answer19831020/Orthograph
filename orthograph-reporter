#!/usr/bin/env perl
#--------------------------------------------------
# This file is part of Orthograph.
# Copyright 2012 Malte Petersen <mptrsen@uni-bonn.de>
# 
# Orthograph is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
# 
# Orthograph is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# Orthograph. If not, see http://www.gnu.org/licenses/.
#-------------------------------------------------- 

# Pragmas
use strict;         # make me write clean code
use warnings;       # cry if something seems odd

# Core modules
use Carp;           # carp and croak: warn and die with call stack
use Data::Dumper;   # great for debugging
use DBD::mysql;     # MySQL database driver
use DBI;            # database interface
use FindBin;        # locate the dir of this script during compile time
use Getopt::Long;   # command line options
use IO::File;       # object-oriented access to files
use Devel::Size qw( total_size );  # get total memory size of variables

# Custom modules
use lib $FindBin::Bin;                 # $Bin is the directory of the original script
use Orthograph::Config;                # configuration in global hashref $config
use Orthograph::Functions;             # functions for all Orthograph tools
use Wrapper::Mysql;

my $config = $Orthograph::Config::config;	# copy config var

# MySQL settings
my $mysql_dbname               = $config->{'mysql_dbname'};
my $mysql_dbpwd                = $config->{'mysql_dbpassword'};
my $mysql_dbserver             = $config->{'mysql_dbserver'};
my $mysql_dbuser               = $config->{'mysql_dbuser'};

my $mysql_table_blast          = $config->{'mysql_table_blast'};
my $mysql_table_blastdbs       = $config->{'mysql_table_blastdbs'};
my $mysql_table_ests           = $config->{'mysql_table_ests'};
my $mysql_table_hmmsearch      = $config->{'mysql_table_hmmsearch'};
my $mysql_table_set_details    = $config->{'mysql_table_set_details'};
my $mysql_table_aaseqs         = $config->{'aaseqs'};
my $mysql_table_seqpairs       = $config->{'sequence_pairs'};
my $mysql_table_taxa           = $config->{'taxa'};
my $mysql_table_orthologs      = $config->{'orthologs'};
my $outdir                     = $config->{'output_directory'};
my $orthoset                   = $config->{'ortholog_set'};
my $quiet                      = $config->{'quiet'};
my $reftaxa                    = $config->{'reference_taxa'};
# substitution character for selenocysteine, which normally leads to blast freaking out
my $u_subst                    = $config->{'substitute_u_with'};
my $sets_dir                   = $config->{'sets_dir'};
my $species_name               = $config->{'species_name'};
my $verbose                    = $config->{'verbose'};

my $setname                    = $config->{'ortholog_set'} ;
my $speciesname                = $config->{'species_name'} ;
my $reference_taxa             = $config->{'reference_taxa'} ;



my $blast_evalue_threshold     = $config->{'blast_evalue_threshold'} ?
	                               $config->{'blast_evalue_threshold'} :
	                               10;
my $soft_threshold             = $config->{'soft_threshold'} ?
	                               $config->{'soft_threshold'} :
	                               5;
my $hmmsearch_evalue_threshold = $config->{'hmmsearch_evalue_threshold'} ?
	                               $config->{'hmmsearch_evalue_threshold'} :
	                               undef;
my $hmmsearch_score_threshold  = $config->{'hmmsearch_score_threshold'} ?
	                               $config->{'hmmsearch_score_threshold'} :
	                               undef;

# mutually exclusive options
die "Fatal: Can't operate in both verbose and quiet mode\n"
	if ($verbose and $quiet);

# mutually exclusive options
die "Fatal: Can't use both e-value and score thresholds\n"
	if ($hmmsearch_evalue_threshold and $hmmsearch_score_threshold);

# More variables
my $count                = 0;
my $data_by_orthoid      = { };
my $out                  = { };
my $data_by_transcript   = { };
my $data_by_evalue       = { };
my $table                = [ ];
my $strict               = 0;
my $sort_by              = 'blasteval';
my @reftaxa              = ( );
my $species_id;
my $set_id;
my $match                = 0;
my $mismatches           = 0;
my $max_mismatches       = $soft_threshold;

# get the species id from the database
$species_id = Wrapper::Mysql::get_taxid_for_species($speciesname);
die "Fatal: No such species in database: '$speciesname'\n" unless ($species_id);

# get the set id from the database
$set_id = Wrapper::Mysql::get_set_id($setname);
die "Fatal: No such set in database: '$setname'\n" unless ($set_id);

# Create the list of reference taxa
# This can be set in the config file, otherwise get all taxa in the set
if ($reference_taxa) { @reftaxa = split(/\s*,\s*/, $config->{'reference_taxa'}) }
else { @reftaxa = Wrapper::Mysql::get_taxa_in_set($set_id) }

# get a orthoid => list_of_aaseq_ids relationship from the db
my $aaseqs_in_orthoid = Wrapper::Mysql::get_orthologs_for_set_hashref($set_id);

# get the results in the form:
# evalue => {
#   orthoid => [
#     reciprocal_hit,
#     reciprocal_hit,
#     reciprocal_hit,
#     etc.
#   ]
# }
my $hitlist = Wrapper::Mysql::get_hitlist_hashref($species_id, $set_id);

# this will hold all transcripts that were found so we can check for redundancy
my @transcript_list;

# mysql can't sort evalues correctly when they are stored as char
# so we do the sorting ourselves
my @evalues_sorted = sort { $a <=> $b } keys %$hitlist;

# generate a table
my $transcripts_mapped_to = { };

# okay let's do the loop come on baby let's do the loop
EVALUE:
foreach my $evalue (@evalues_sorted) {

	ORTHOID:
	while (my ($orthoid, $list) = each (%{$$hitlist{$evalue}})) {
		# reset the mismatch counter
		$mismatches = 0;

		# has this orthoid been assigned before?
		next ORTHOID unless exists $$aaseqs_in_orthoid{$orthoid};

		# sort by reciprocal hit evalue
		my $sorted_list = [ sort { $$a{'blast_evalue'} <=> $$b{'blast_evalue'} } @$list ];

		print "checking out $orthoid with evalue $evalue: ", scalar @$sorted_list, " reciprocal hits\n"
			if $verbose;

		RH:
		foreach my $reciprocal_hit (@$sorted_list) {
			# find out if the aaseq_id is one of those used for this orthoid
			print "  checking out hit " , Dumper($reciprocal_hit)
				if $verbose;

			# has this aaseq been used in building this hmm and has this not been found previously?
			# grep is the nicer solution but may not be as fast as a loop that we can exit after one match.
			# the first function from List::Util also returns after the first occurence.
			# however no significant difference could be noted between the two in terms of runtime
			# (in a real-life example with arrays of > 4000 elements)
			if (grep(/$$reciprocal_hit{'blast_hit'}/, @{$$aaseqs_in_orthoid{$orthoid}}) and
			    not grep(/$$reciprocal_hit{'hmmhit'}/, @transcript_list)) {

				$match = $reciprocal_hit;

				print "    $$reciprocal_hit{'blast_hit'} used in this HMM!\n"
					if $verbose;

				# one hit is enough if not in strict mode
				last RH unless $strict;
			}
			else {  # not found
				# cry
				print "    $$reciprocal_hit{'blast_hit'} not used in this HMM (mismatch #", ++$mismatches, ") :(\n"
					if $verbose;

				# in a strict search, that's it for this orthoid
				next ORTHOID if $strict;

				# no match
				undef $match;

				# too many mismatches, we don't trust this one anymore
				if ($mismatches >= $max_mismatches) {
					print ">>    Too many mismatches, we don't trust this one anymore\n"
						if $verbose;
					next ORTHOID;
				}
			}

		# END RH
		}
		# so, was this a match?
		if ($match) {

			# yeah
			printf ">>    assigned %s to %s\n",
				$$match{'hmmhit'},
				$orthoid,
				#$$match{'blast_hit'},
				#$$match{'blast_evalue'},
				unless $quiet;

			# this orthoid can't be found again
			delete $$aaseqs_in_orthoid{$orthoid};

			# this transcript can't be found again either
			push @transcript_list, $$match{'hmmhit'};

			$$transcripts_mapped_to{$orthoid} = $$match{'hmmhit'};

			# reset 
			undef $match;
		}
		else {
			# this orthoid has no match
			print "    $orthoid could not be assigned :((\n"
				unless $quiet;
		}

	# END ORTHOID
	} 

# END EVALUE
}



while (my ($o, $t) = each %$transcripts_mapped_to) {
	warn sprintf("%s : %s\n", $o, $t);
}

exit;
#--------------------------------------------------
# this query selects all orthology candidates for which
# the reciprocal search also hit something good
#-------------------------------------------------- 
my $query = "
SELECT DISTINCT
	$mysql_table_orthologs.ortholog_gene_id AS orthoid,
	$mysql_table_hmmsearch.target           AS transcript,
	$mysql_table_hmmsearch.evalue           AS hmm_eval,
	$mysql_table_blast.target               AS blast_target,
	$mysql_table_blast.evalue               AS blast_eval,
	$mysql_table_taxa.name                  AS reftax
FROM $mysql_table_aaseqs
INNER JOIN $mysql_table_taxa
	ON $mysql_table_aaseqs.taxid            = $mysql_table_taxa.id
INNER JOIN $mysql_table_blast
	ON $mysql_table_aaseqs.id               = $mysql_table_blast.target
INNER JOIN $mysql_table_hmmsearch
	ON $mysql_table_blast.query             = $mysql_table_hmmsearch.target
INNER JOIN $mysql_table_ests
	ON $mysql_table_hmmsearch.target        = $mysql_table_ests.digest
INNER JOIN $mysql_table_orthologs
	ON $mysql_table_hmmsearch.query         = $mysql_table_orthologs.ortholog_gene_id
INNER JOIN $mysql_table_seqpairs
	ON $mysql_table_orthologs.sequence_pair = $mysql_table_seqpairs.id
	AND $mysql_table_aaseqs.id              = $mysql_table_seqpairs.aa_seq
INNER JOIN $mysql_table_set_details
	ON $mysql_table_set_details.id          = $set_id
WHERE $mysql_table_ests.taxid             = $species_id
AND $mysql_table_hmmsearch.evalue         < $hmmsearch_evalue_threshold
AND $mysql_table_blast.evalue             < $blast_evalue_threshold
ORDER BY $mysql_table_hmmsearch.evalue
";

# get data, store in hash->array->hash
my $dbh = DBI->connect("dbi:mysql:$mysql_dbname:$mysql_dbserver", $mysql_dbuser, $mysql_dbpwd);
my $sql = $dbh->prepare($query);
$sql->execute();
while (my $line = $sql->fetchrow_arrayref()) {
	# the orthoid shall be the key
	# a hash of arrays
	push @{$$data_by_orthoid{$$line[0]}}, {	# 0: orthoid
		'digest'      => $$line[1],	# 1: SHA256 digest
		'hmmeval'     => sprintf("%e", $$line[2]),	# 2: hmmsearch evalue
		'blasttarget' => $$line[3],	# 3: blast target id	
		'blasteval'   => sprintf("%e", $$line[4]),	# 4: blast evalue
		'reftaxon'    => $$line[5]	# 5: reference taxon
	};
	# the same structure, but keyed by transcript digest
	push @{$$data_by_transcript{$$line[1]}}, {
		'orthoid'     => $$line[0],
		'hmmeval'     => sprintf("%e", $$line[2]),	# 2: hmmsearch evalue
		'blasttarget' => $$line[3],
		'blasteval'   => sprintf("%e", $$line[4]),
		'reftaxon'    => $$line[5]
	};
	# keyed by e-value
	# a hash of hashes of arrays
	push @{$$data_by_evalue{sprintf("%e", $$line[2])}{$$line[0]}}, {
		'digest'      => $$line[1],
		'blasttarget' => $$line[3],
		'blasteval'   => sprintf("%e", $$line[4]),
		'reftaxon'    => $$line[5]
	};
}
$dbh->disconnect;

# sort by blast evalue or hmmsearch evalue or the number of your mom's chest hairs
foreach my $eog (keys %$data_by_orthoid) {
	@{$$data_by_orthoid{$eog}} = sort {
		$$a{$sort_by} <=> $$b{$sort_by}
	} @{$$data_by_orthoid{$eog}};
}
foreach my $eval (keys %$data_by_evalue) {
	foreach my $key (keys %{$data_by_evalue->{$eval}}) {
		@{$$data_by_evalue{$eval}{$key}} = sort {
			$$a{$sort_by} <=> $$b{$sort_by}
		} @{$$data_by_evalue{$eval}{$key}};
	}
}
foreach my $transcript (keys %$data_by_transcript) {
	@{$$data_by_transcript{$transcript}} = sort {
		$$a{$sort_by} <=> $$b{$sort_by}
	} @{$$data_by_transcript{$transcript}};
}

# keys to the hashes
my @keys_orthoids    = keys %$data_by_orthoid    ;
my @keys_transcripts = keys %$data_by_transcript;
my @keys_evalues     = keys %$data_by_evalue     ;


# make a HTML table!
(my $filename = $speciesname . '.html') =~ s/\s+/_/g;
my $fh = IO::File->new($filename, 'w');
print $fh "<html><head><title>$speciesname</title></head><body>\n";
print $fh "<table>\n";
print $fh "<tr><th>&nbsp;</th>\n";	# first cell is empty 
printf $fh "<th align='left'>%s</th>\n", $_ foreach @keys_orthoids;	# header
print $fh "</tr>\n";
# columns
for (my $x = 0; $x < scalar @keys_transcripts; ++$x) {
	print $fh "<tr>\n";
	print $fh "<td><b>", $keys_transcripts[$x], "</b></td>";
	# rows
	for (my $y = 0; $y < scalar @keys_orthoids; ++$y) {
		# get the matching transcript from the list
		my $flag = 0;
		foreach my $hit (@{$$data_by_transcript{$keys_transcripts[$x]}}) {
			if ($$hit{'orthoid'} eq $keys_orthoids[$y]) {
				print $fh "<td>", $$hit{'hmmeval'}, "</td>" if $flag == 0;
				# connect these in the result table
				push @{$$table[$x][$y]}, {
					'hmmeval'     => $$hit{'hmmeval'},
					'blasteval'   => $$hit{'blasteval'},
					'blasttarget' => $$hit{'blasttarget'},
					'reftaxon'    => $$hit{'reftaxon'},
				};
				$flag = 1;
			}
		}
		if ($flag == 0) {
			# this is a non-match
			print $fh "<td>NULL</td>";
			$$table[$x][$y] = 0;
		}
		else {
			$flag = 0;
			@{$$table[$x][$y]} = sort {$$a{'hmmeval'} <=> $$b{'hmmeval'}} @{$$table[$x][$y]};
		}
	}
	print $fh "</tr>\n";
}
print $fh "</table>\n";
print $fh "</body></html>\n";
# close file
undef $fh;
#--------------------------------------------------
# 
# my $miscount = 0;
# my $reftaxa_hitcount = 0;
# my $hit = 0;
# # walk through the e-values and examine each hit pair
# # it's a hash of hashes (of arrays)
# foreach my $heval (sort {$a <=> $b} keys %$data_by_evalue) {
# 	# each e-value is associated with a orthoid that has generated a number of reciprocal hits
# 	# let's examine each orthoid individually
# 	foreach my $oid (keys %{$$data_by_evalue{$heval}}) {
# 		# each orthoid is associated with a list of reciprocal hits
# 		# which we'll traverse now
# 		foreach my $i (0 .. scalar( @{$$data_by_evalue{$heval}{$oid}} ) - 1) {
# 			# only if both orthoid and transcript have not been assigned before
# 			if (
# 				grep( /$$data_by_evalue{$heval}{$oid}[$i]{'digest'}/, @keys_transcripts )
# 				and grep( /$oid/, @keys_orthoids )
# 			)
# 			{
# 				# is the reftaxon of this hit in the reftaxa list?
# 				if ( $miscount < $max_miscount and grep /$$data_by_evalue{$heval}{$oid}[$i]{'reftaxon'}/, @reftaxa ) {
# 					# yes... but this is not enough!
# 					#--------------------------------------------------
# 					# printf "%.1e : %s and %s (%s: %.1e, hit #%d), count %d\n",
# 					# 	$heval,
# 					# 	$oid,
# 					# 	$$data_by_evalue{$heval}{$oid}[$i]{'digest'},
# 					# 	$$data_by_evalue{$heval}{$oid}[$i]{'reftaxon'},
# 					# 	$$data_by_evalue{$heval}{$oid}[$i]{'blasteval'},
# 					# 	$i + 1,
# 					# 	$reftaxa_hitcount + 1,
# 					# ;
# 					#-------------------------------------------------- 
# 					++$reftaxa_hitcount;
# 					$hit = $i;
# 				}
# 				else {
# 					++$miscount;
# 				}
# 			}
# 		}
# 		# all reference taxa were hit rectally
# 		if ($strict and $reftaxa_hitcount == scalar @reftaxa) {
# 			# make sure they only get assigned once by removing the id from the list
# 			&remove_from_lists($heval, $oid, $hit);
# 			print "==> all reftax hit (", $reftaxa_hitcount, " of ", scalar @reftaxa, "). removed this pair from the list of candidates.\n";
# 			# TODO insert this result into the database
# 			# make a new result table
# 			$count++;
# 		}
# 		# at least one reference taxon was hit
# 		elsif (not $strict and $reftaxa_hitcount > 0) {
# 			# do the same i guess
# 			# make sure they only get assigned once by removing the id from the list
# 			&remove_from_lists($heval, $oid, $hit);
# 			print "==> $reftaxa_hitcount reftax hit (", $reftaxa_hitcount, " of ", scalar @reftaxa, "). removed this pair from the list of candidates.\n";
# 			# TODO insert this result into the database
# 			# make a new result table
# 			$count++;
# 		}
# 		# reset counters
# 		$miscount         = 0;
# 		$reftaxa_hitcount = 0;
# 		$hit              = 0;
# 	}
# }
# print $count, " final hits\n";
# 
#-------------------------------------------------- 
exit;

=head2 remove_from_lists(KEY, ID)

Removes a hit pair (orthoid <-> transcript digest) at KEY (usually an e-value)
with the index INDEX of the list of hits from both the @keys_orthoids and
@keys_transcripts lists so they can't be found again (avoiding redundancy).
Returns 1.

=cut

sub remove_from_lists {
	my $heval = shift @_;
	my $oid = shift @_;
	my $id = shift @_;
	for (0 .. scalar(@keys_orthoids) - 1 ) {
		if ($keys_orthoids[$_] eq $oid) {
			splice(@keys_orthoids, $_, 1) and last;
		}
	}
	for (0 .. scalar(@keys_transcripts) - 1 ) {
		if ($keys_transcripts[$_] eq $oid) {
			splice(@keys_transcripts, $_, 1) and last;
		}
	}
	return 1;
}

# take only the reference taxa
my $num_reftaxa = scalar @reftaxa;
TR:
for my $x (0 .. $#keys_transcripts) {
	OG:
	for my $y (0 .. $#keys_orthoids) {
		# skip non-matches and already-removed entries
		next if not defined $$table[$x][$y] or $$table[$x][$y] == 0;

		# local list of reftaxa for this match
		my @this_reftaxa;
		push @this_reftaxa, $$_{'reftaxon'} foreach (@{$$table[$x][$y]});

		# intersection of @reftaxa and @this_reftaxa
		my %union = my %isect = ();
		foreach my $el (@reftaxa) { $union{$el} = 1 }
		foreach my $el (@this_reftaxa) { $isect{$el} = 1 if ($union{$el}) }

		# This orthoid-transcript combination matches all reference taxa!
		if (scalar keys %isect == $num_reftaxa) { 
			# strict match
			print "+\t$keys_orthoids[$y] and $keys_transcripts[$x]: ";
			printf "%s ", $_ foreach keys %isect;
			printf "with %.2e\n", $$table[$x][$y][0]{'hmmeval'};
			# but it may still be redundant... fuck.
			# remove it from the table to hopefully eliminate redundancy
			splice @{$$table[$_]}, $y, 1 foreach (0 .. $#{$table});
			splice @$table, $x, 1;
			last;
		}
		# this one matches at least one reference taxon
		elsif (scalar keys %isect) {
			# fuzzy match
			print "=\t$keys_orthoids[$y] and $keys_transcripts[$x]: ";
			printf "%s ", $_ foreach keys %isect;
			printf "with %.2e\n", $$table[$x][$y][0]{'hmmeval'};
			# but it may still be redundant... fuck.
			# remove it from the table to hopefully eliminate redundancy
			splice @{$$table[$_]}, $y, 1 foreach (0 .. $#{$table});
			splice @$table, $x, 1;
			last;
		}
		# this one matches none
		else {
			print "-\t$keys_orthoids[$y] and $keys_transcripts[$x]: ";
			printf "%s ", $_ foreach @this_reftaxa;
			print "\n";
		}

	}
}
print "Reftaxa: @reftaxa\n";
exit;

# output each eog with the correct transcript
# each transcript shall be assigned to only one ortholog group
foreach my $eog (keys %$data_by_orthoid) {
	# for all hits, see if they are in the reftaxa list
	REFTAXON:
	for my $i (0..$#{$$data_by_orthoid{$eog}}) {
		# is this reftaxon in our list?
		if ( grep /$$data_by_orthoid{$eog}[$i]{'reftaxon'}/ , @reftaxa ) {
			# ok it's there
			# take the best (hmm|blast) evalue
			# using a hash makes sure each ortholog group gets only one transcript
			if ( defined $$out{$$data_by_orthoid{$eog}[$i]{'digest'}} ) {
				if ( $$data_by_orthoid{$eog}[$i]{$sort_by} < $$out{$$data_by_orthoid{$eog}[$i]{'digest'}}{$sort_by} ) {
					$$out{$$data_by_orthoid{$eog}[$i]{'digest'}} = {
						'eog'       => $eog,
						'hmmeval'   => $$data_by_orthoid{$eog}[$i]{'hmmeval'},
						'blasteval' => $$data_by_orthoid{$eog}[$i]{'blasteval'},
						'reftaxon'  => $$data_by_orthoid{$eog}[$i]{'reftaxon'},
					};
				}
				# is this a strict search, i.e., do we need to hit ALL reftaxa?
				unless ($strict) { last; }
				else { next REFTAXON }
			}
			else {
				$$out{$$data_by_orthoid{$eog}[$i]{'digest'}} = {
					'eog'       => $eog,
					'hmmeval'   => $$data_by_orthoid{$eog}[$i]{'hmmeval'},
					'blasteval' => $$data_by_orthoid{$eog}[$i]{'blasteval'},
					'reftaxon'  => $$data_by_orthoid{$eog}[$i]{'reftaxon'},
				};
			}
		}
	}
}

printf "%s => %s\n", $_, $$data_by_orthoid{$_}[0]{'digest'} foreach keys %$data_by_orthoid;
